/******** BEGIN cachedTypes.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2011 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

/**
 * Emulates very small parts of cachedTypes.js and itemFields.js APIs for use with connector
 */

/**
 * @namespace
 */
Zotero.Connector_Types = new function() {
	/**
	 * Initializes types
	 * @param {Object} typeSchema typeSchema generated by Zotero.Connector.GetData#_generateTypeSchema
	 */
	this.init = function() {
		const schemaTypes = ["itemTypes", "creatorTypes", "fields"];

		// attach IDs and make referenceable by either ID or name
		for(var i=0; i<schemaTypes.length; i++) {
			var schemaType = schemaTypes[i];
			this[schemaType] = Zotero.Utilities.deepCopy(Zotero.Connector_Types.schema[schemaType]);
			for(var id in Zotero.Connector_Types.schema[schemaType]) {
				var entry = this[schemaType][id];
				entry.unshift(parseInt(id, 10));
				this[schemaType][entry[1]/* name */] = entry;
			}
		}

		var itemTypes = Zotero.Connector_Types["itemTypes"];
		var creatorTypes = Zotero.Connector_Types["creatorTypes"];
		var fields = Zotero.Connector_Types["fields"];

		Zotero.CachedTypes = function() {
			var thisType = Zotero.Connector_Types[this.schemaType];

			this.getID = function(idOrName) {
				var type = thisType[idOrName];
				return (type ? type[0]/* id */ : false);
			};

			this.getName = function(idOrName) {
				var type = thisType[idOrName];
				return (type ? type[1]/* name */ : false);
			};

			this.getLocalizedString = function(idOrName) {
				var type = thisType[idOrName];
				return (type ? type[2]/* localizedString */ : false);
			};
		}

		Zotero.ItemTypes = new function() {
			this.schemaType = "itemTypes";
			Zotero.CachedTypes.call(this);

			this.getImageSrc = function(idOrName) {
				var itemType = Zotero.Connector_Types["itemTypes"][idOrName];
				var icon = itemType ? itemType[6]/* icon */ : "treeitem-"+idOrName+".png";

				if(Zotero.isBookmarklet) {
					return ZOTERO_CONFIG.BOOKMARKLET_URL+"images/"+icon;
				} else if(Zotero.isFx) {
					return "chrome://zotero/skin/"+icon;
				} else if(Zotero.isChrome) {
					return chrome.extension.getURL("images/"+icon);
				} else if(Zotero.isSafari) {
					return safari.extension.baseURI+"images/"+icon;
				}
			};
		}

		Zotero.CreatorTypes = new function() {
			this.schemaType = "creatorTypes";
			Zotero.CachedTypes.call(this);

			this.getTypesForItemType = function(idOrName) {
				var itemType = itemTypes[idOrName];
				if(!itemType) return false;

				var itemCreatorTypes = itemType[3]/* creatorTypes */,
					n = itemCreatorTypes.length,
					outputTypes = new Array(n);

				for(var i=0; i<n; i++) {
					var creatorType = creatorTypes[itemCreatorTypes[i]];
					outputTypes[i] = {"id":creatorType[0]/* id */,
						"name":creatorType[1]/* name */};
				}
				return outputTypes;
			};

			this.getPrimaryIDForType = function(idOrName) {
				var itemType = itemTypes[idOrName];
				if(!itemType) return false;
				return itemTypes[3]/* creatorTypes */[0];
			};
		}

		Zotero.ItemFields = new function() {
			this.schemaType = "fields";
			Zotero.CachedTypes.call(this);

			this.isValidForType = function(fieldIdOrName, typeIdOrName) {
				var field = fields[fieldIdOrName], itemType = itemTypes[typeIdOrName];

				// mimics itemFields.js
				if(!field || !itemType) return false;

				       /* fields */        /* id */
				return itemType[4].indexOf(field[0]) !== -1;
			};

			this.getFieldIDFromTypeAndBase = function(typeIdOrName, fieldIdOrName) {
				var baseField = fields[fieldIdOrName], itemType = itemTypes[typeIdOrName];

				if(!baseField || !itemType) return false;

				// get as ID
				baseField = baseField[0]/* id */;

				// loop through base fields for item type
				var baseFields = itemType[5];
				for(var i in baseFields) {
					if(baseFields[i] === baseField) {
						return i;
					}
				}

				return false;
			};

			this.getBaseIDFromTypeAndField = function(typeIdOrName, fieldIdOrName) {
				var field = fields[fieldIdOrName], itemType = itemTypes[typeIdOrName];
				if(!field || !itemType) {
					throw new Error("Invalid field or type ID");
				}

				var baseField = itemType[5]/* baseFields */[field[0]/* id */];
				return baseField ? baseField : false;
			};

			this.getItemTypeFields = function(typeIdOrName) {
				return itemTypes[typeIdOrName][4]/* fields */.slice();
			};
		}
	};

	/**
	 * Passes schema to a callback
	 * @param {Function} callback
	 */
	this.getSchema = function(callback) {
		callback(Zotero.Connector_Types.schema);
	};
}
/******** END cachedTypes.js ********/
/******** BEGIN date.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

Zotero.Date = new function(){
	this.sqlToDate = sqlToDate;
	this.dateToSQL = dateToSQL;
	this.strToDate = strToDate;
	this.formatDate = formatDate;
	this.strToISO = strToISO;
	this.strToMultipart = strToMultipart;
	this.isMultipart = isMultipart;
	this.multipartToSQL = multipartToSQL;
	this.multipartToStr = multipartToStr;
	this.isSQLDate = isSQLDate;
	this.isSQLDateTime = isSQLDateTime;
	this.sqlHasYear = sqlHasYear;
	this.sqlHasMonth = sqlHasMonth;
	this.sqlHasDay = sqlHasDay;
	this.getUnixTimestamp = getUnixTimestamp;
	this.toUnixTimestamp = toUnixTimestamp;
	this.getFileDateString = getFileDateString;
	this.getFileTimeString = getFileTimeString;
	this.getLocaleDateOrder = getLocaleDateOrder;

	var _localeDateOrder = null;
	var _months = null;

	/**
	 * Load dateFormat bundle into _dateFormatsBundle
	 */
	this.getMonths = function() {
		if(_months) return _months;

		if(Zotero.isFx && !Zotero.isBookmarklet) {
			var src = 'chrome://global/locale/dateFormat.properties';
			var localeService = Components.classes['@mozilla.org/intl/nslocaleservice;1'].
								getService(Components.interfaces.nsILocaleService);
			var appLocale = localeService.getApplicationLocale();

			var bundle =
				Components.classes["@mozilla.org/intl/stringbundle;1"]
				.getService(Components.interfaces.nsIStringBundleService).createBundle(src, appLocale);

			_months = {"short":[], "long":[]};
			for(var i=1; i<=12; i++) {
				_months.short.push(bundle.GetStringFromName("month."+i+".Mmm"));
				_months.long.push(bundle.GetStringFromName("month."+i+".name"));
			}
		} else {
			// TODO localize for Chrome/Safari
			_months = {
				"short":["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
					"Oct", "Nov", "Dec"],
				"long":["January", "February", "March", "April", "May", "June", "July",
					"August", "September", "October", "November", "December"]};
		}

		return _months;
	}

	/**
	* Convert an SQL date in the form '2006-06-13 11:03:05' into a JS Date object
	*
	* Can also accept just the date part (e.g. '2006-06-13')
	**/
	function sqlToDate(sqldate, isUTC){
		try {
			var datetime = sqldate.split(' ');
			var dateparts = datetime[0].split('-');
			if (datetime[1]){
				var timeparts = datetime[1].split(':');
			}
			else {
				timeparts = [false, false, false];
			}

			// Invalid date part
			if (dateparts.length==1){
				return false;
			}

			if (isUTC){
				return new Date(Date.UTC(dateparts[0], dateparts[1]-1, dateparts[2],
					timeparts[0], timeparts[1], timeparts[2]));
			}

			return new Date(dateparts[0], dateparts[1]-1, dateparts[2],
				timeparts[0], timeparts[1], timeparts[2]);
		}
		catch (e){
			Zotero.debug(sqldate + ' is not a valid SQL date', 2)
			return false;
		}
	}


	/**
	* Convert a JS Date object to an SQL date in the form '2006-06-13 11:03:05'
	*
	* If _toUTC_ is true, creates a UTC date
	**/
	function dateToSQL(date, toUTC)
	{
		try {
			if (toUTC){
				var year = date.getUTCFullYear();
				var month = date.getUTCMonth();
				var day = date.getUTCDate();
				var hours = date.getUTCHours();
				var minutes = date.getUTCMinutes();
				var seconds = date.getUTCSeconds();
			}
			else {
				return date.toLocaleFormat('%Y-%m-%d %H:%M:%S');
			}

			year = Zotero.Utilities.lpad(year, '0', 4);
			month = Zotero.Utilities.lpad(month + 1, '0', 2);
			day = Zotero.Utilities.lpad(day, '0', 2);
			hours = Zotero.Utilities.lpad(hours, '0', 2);
			minutes = Zotero.Utilities.lpad(minutes, '0', 2);
			seconds = Zotero.Utilities.lpad(seconds, '0', 2);

			return year + '-' + month + '-' + day + ' '
				+ hours + ':' + minutes + ':' + seconds;
		}
		catch (e){
			Zotero.debug(date + ' is not a valid JS date', 2);
			return '';
		}
	}


	/**
	 * Convert a JS Date object to an ISO 8601 UTC date/time
	 *
	 * @param	{Date}		date		JS Date object
	 * @return	{String}				ISO 8601 UTC date/time
	 *									e.g. 2008-08-15T20:00:00Z
	 */
	this.dateToISO = function (date) {
		var year = date.getUTCFullYear();
		var month = date.getUTCMonth();
		var day = date.getUTCDate();
		var hours = date.getUTCHours();
		var minutes = date.getUTCMinutes();
		var seconds = date.getUTCSeconds();

		year = Zotero.Utilities.lpad(year, '0', 4);
		month = Zotero.Utilities.lpad(month + 1, '0', 2);
		day = Zotero.Utilities.lpad(day, '0', 2);
		hours = Zotero.Utilities.lpad(hours, '0', 2);
		minutes = Zotero.Utilities.lpad(minutes, '0', 2);
		seconds = Zotero.Utilities.lpad(seconds, '0', 2);

		return year + '-' + month + '-' + day + 'T'
			+ hours + ':' + minutes + ':' + seconds + 'Z';
	}


	/**
	 * Convert an ISO 8601–formatted UTC date/time to a JS Date
	 *
	 * Adapted from http://delete.me.uk/2005/03/iso8601.html (AFL-licensed)
	 *
	 * @param	{String}		isoDate		ISO 8601 date
	 * @return	{Date}					JS Date
	 */
	this.isoToDate = function (isoDate) {
		var re8601 = /([0-9]{4})(-([0-9]{2})(-([0-9]{2})(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(\.([0-9]+))?)?(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?/;
		var d = isoDate.match(re8601);

		var offset = 0;
		var date = new Date(d[1], 0, 1);

		if (d[3]) { date.setMonth(d[3] - 1); }
		if (d[5]) { date.setDate(d[5]); }
		if (d[7]) { date.setHours(d[7]); }
		if (d[8]) { date.setMinutes(d[8]); }
		if (d[10]) { date.setSeconds(d[10]); }
		if (d[12]) { date.setMilliseconds(Number("0." + d[12]) * 1000); }
		if (d[14]) {
			offset = (Number(d[16]) * 60) + Number(d[17]);
			offset *= ((d[15] == '-') ? 1 : -1);
		}

		offset -= date.getTimezoneOffset();
		var time = (Number(date) + (offset * 60 * 1000));
		return new Date(time);
	}


	/*
	 * converts a string to an object containing:
	 *    day: integer form of the day
	 *    month: integer form of the month (indexed from 0, not 1)
	 *    year: 4 digit year (or, year + BC/AD/etc.)
	 *    part: anything that does not fall under any of the above categories
	 *          (e.g., "Summer," etc.)
	 *
	 * Note: the returned object is *not* a JS Date object
	 */
	var _slashRe = /^(.*?)\b([0-9]{1,4})(?:([\-\/\.\u5e74])([0-9]{1,2}))?(?:([\-\/\.\u6708])([0-9]{1,4}))?((?:\b|[^0-9]).*?)$/
	var _yearRe = /^(.*?)\b((?:circa |around |about |c\.? ?)?[0-9]{1,4}(?: ?B\.? ?C\.?(?: ?E\.?)?| ?C\.? ?E\.?| ?A\.? ?D\.?)|[0-9]{3,4})\b(.*?)$/i;
	var _monthRe = null;
	var _dayRe = null;

	function strToDate(string) {
		var date = {
			order: ''
		};

		// skip empty things
		if(!string) {
			return date;
		}

		var parts = [];

		// Parse 'yesterday'/'today'/'tomorrow'
		var lc = (string + '').toLowerCase();
		if (lc == 'yesterday' || (Zotero.getString && lc === Zotero.getString('date.yesterday'))) {
			string = Zotero.Date.dateToSQL(new Date(Date.now() - 1000*60*60*24)).substr(0, 10);
		}
		else if (lc == 'today' || (Zotero.getString && lc == Zotero.getString('date.today'))) {
			string = Zotero.Date.dateToSQL(new Date()).substr(0, 10);
		}
		else if (lc == 'tomorrow' || (Zotero.getString && lc == Zotero.getString('date.tomorrow'))) {
			string = Zotero.Date.dateToSQL(new Date(Date.now() + 1000*60*60*24)).substr(0, 10);
		}
		else {
			string = string.toString().replace(/^\s+|\s+$/g, "").replace(/\s+/, " ");
		}

		// first, directly inspect the string
		var m = _slashRe.exec(string);
		if(m &&
		  ((!m[5] || !m[3]) || m[3] == m[5] || (m[3] == "\u5e74" && m[5] == "\u6708")) &&	// require sane separators
		  ((m[2] && m[4] && m[6]) || (!m[1] && !m[7]))) {						// require that either all parts are found,
		  																		// or else this is the entire date field
			// figure out date based on parts
			if(m[2].length == 3 || m[2].length == 4 || m[3] == "\u5e74") {
				// ISO 8601 style date (big endian)
				date.year = m[2];
				date.month = m[4];
				date.day = m[6];
				date.order += m[2] ? 'y' : '';
				date.order += m[4] ? 'm' : '';
				date.order += m[6] ? 'd' : '';
			} else if(m[2] && !m[4] && m[6]) {
				date.month = m[2];
				date.year = m[6];
				date.order += m[2] ? 'm' : '';
				date.order += m[6] ? 'y' : '';
			} else {
				// local style date (middle or little endian)
				var country = Zotero.locale ? Zotero.locale.substr(3) : "US";
				if(country == "US" ||	// The United States
				   country == "FM" ||	// The Federated States of Micronesia
				   country == "PW" ||	// Palau
				   country == "PH") {	// The Philippines
					date.month = m[2];
					date.day = m[4];
					date.order += m[2] ? 'm' : '';
					date.order += m[4] ? 'd' : '';
				} else {
					date.month = m[4];
					date.day = m[2];
					date.order += m[2] ? 'd' : '';
					date.order += m[4] ? 'm' : '';
				}
				date.year = m[6];
				date.order += 'y';
			}

			if(date.year) date.year = parseInt(date.year, 10);
			if(date.day) date.day = parseInt(date.day, 10);
			if(date.month) {
				date.month = parseInt(date.month, 10);

				if(date.month > 12) {
					// swap day and month
					var tmp = date.day;
					date.day = date.month
					date.month = tmp;
					date.order = date.order.replace('m', 'D')
						.replace('d', 'M')
						.replace('D', 'd')
						.replace('M', 'm');
				}
			}

			if((!date.month || date.month <= 12) && (!date.day || date.day <= 31)) {
				if(date.year && date.year < 100) {	// for two digit years, determine proper
													// four digit year
					var today = new Date();
					var year = today.getFullYear();
					var twoDigitYear = year % 100;
					var century = year - twoDigitYear;

					if(date.year <= twoDigitYear) {
						// assume this date is from our century
						date.year = century + date.year;
					} else {
						// assume this date is from the previous century
						date.year = century - 100 + date.year;
					}
				}

				if(date.month) date.month--;		// subtract one for JS style
				else delete date.month;

				Zotero.debug("DATE: retrieved with algorithms: "+JSON.stringify(date));

				parts.push(
					{ part: m[1], before: true },
					{ part: m[7] }
				);
			} else {
				// give up; we failed the sanity check
				Zotero.debug("DATE: algorithms failed sanity check");
				var date = {
					order: ''
				};
				parts.push({ part: string });
			}
		} else {
			Zotero.debug("DATE: could not apply algorithms");
			parts.push({ part: string });
		}

		// couldn't find something with the algorithms; use regexp
		// YEAR
		if(!date.year) {
			for (var i in parts) {
				var m = _yearRe.exec(parts[i].part);
				if (m) {
					date.year = m[2];
					date.order = _insertDateOrderPart(date.order, 'y', parts[i]);
					parts.splice(
						i, 1,
						{ part: m[1], before: true },
						{ part: m[3] }
					);
					Zotero.debug("DATE: got year (" + date.year + ", " + JSON.stringify(parts) + ")");
					break;
				}
			}
		}

		// MONTH
		if(date.month === undefined) {
			// compile month regular expression
			var months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul',
				'aug', 'sep', 'oct', 'nov', 'dec'];
			// If using a non-English bibliography locale, try those too
			if (Zotero.locale != 'en-US') {
				Zotero.Date.getMonths();
				months = months.concat(_months['short']).concat(_months['long']);
				for(var i=0, n=months.length; i<n; i++) months[i] = months[i].toLowerCase();
			}

			if(!_monthRe) {
				_monthRe = new RegExp("^(.*)\\b("+months.join("|")+")[^ ]*(?: (.*)$|$)", "i");
			}

			for (var i in parts) {
				var m = _monthRe.exec(parts[i].part);
				if (m) {
					// Modulo 12 in case we have multiple languages
					date.month = months.indexOf(m[2].toLowerCase()) % 12;
					date.order = _insertDateOrderPart(date.order, 'm', parts[i]);
					parts.splice(
						i, 1,
						{ part: m[1], before: "m" },
						{ part: m[3], after: "m" }
					);
					Zotero.debug("DATE: got month (" + date.month + ", " + JSON.stringify(parts) + ")");
					break;
				}
			}
		}

		// DAY
		if(!date.day) {
			// compile day regular expression
			if(!_dayRe) {
				var daySuffixes = Zotero.getString ? Zotero.getString("date.daySuffixes").replace(/, ?/g, "|") : "";
				_dayRe = new RegExp("\\b([0-9]{1,2})(?:"+daySuffixes+")?\\b(.*)", "i");
			}

			for (var i in parts) {
				var m = _dayRe.exec(parts[i].part);
				if (m) {
					var day = parseInt(m[1], 10);
					// Sanity check
					if (day <= 31) {
						date.day = day;
						date.order = _insertDateOrderPart(date.order, 'd', parts[i]);
						if(m.index > 0) {
							var part = parts[i].part.substr(0, m.index);
							if(m[2]) {
								part += " " + m[2];;
							}
						} else {
							var part = m[2];
						}
						parts.splice(
							i, 1,
							{ part: part }
						);
						Zotero.debug("DATE: got day (" + date.day + ", " + JSON.stringify(parts) + ")");
						break;
					}
				}
			}
		}

		// Concatenate date parts
		date.part = '';
		for (var i in parts) {
			date.part += parts[i].part + ' ';
		}

		// clean up date part
		if(date.part) {
			date.part = date.part.replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g, "");
		}

		if(date.part === "" || date.part == undefined) {
			delete date.part;
		}

		//make sure year is always a string
		if(date.year || date.year === 0) date.year += '';

		return date;
	}


	function _insertDateOrderPart(dateOrder, part, partOrder) {
		if (!dateOrder) {
			return part;
		}
		if (partOrder.before === true) {
			return part + dateOrder;
		}
		if (partOrder.after === true) {
			return dateOrder + part;
		}
		if (partOrder.before) {
			var pos = dateOrder.indexOf(partOrder.before);
			if (pos == -1) {
				return dateOrder;
			}
			return dateOrder.replace(new RegExp("(" + partOrder.before + ")"), part + '$1');
		}
		if (partOrder.after) {
			var pos = dateOrder.indexOf(partOrder.after);
			if (pos == -1) {
				return dateOrder + part;
			}
			return dateOrder.replace(new RegExp("(" + partOrder.after + ")"), '$1' + part);
		}
		return dateOrder + part;
	}



	/**
	 * does pretty formatting of a date object returned by strToDate()
	 *
	 * @param {Object} date A date object, as returned from strToDate()
	 * @param {Boolean} shortFormat Whether to return a short (12/1/95) date
	 * @return A formatted date string
	 * @type String
	 **/
	function formatDate(date, shortFormat) {
		if(shortFormat) {
			var localeDateOrder = getLocaleDateOrder();
			var string = localeDateOrder[0]+"/"+localeDateOrder[1]+"/"+localeDateOrder[2];
			return string.replace("y", (date.year !== undefined ? date.year : "00"))
			             .replace("m", (date.month !== undefined ? 1+date.month : "0"))
			             .replace("d", (date.day !== undefined ? date.day : "0"));
		} else {
			var string = "";

			if(date.part) {
				string += date.part+" ";
			}

			var months = Zotero.Date.getMonths().long;
			if(date.month != undefined && months[date.month]) {
				// get short month strings from CSL interpreter
				string += months[date.month];
				if(date.day) {
					string += " "+date.day+", ";
				} else {
					string += " ";
				}
			}

			if(date.year) {
				string += date.year;
			}
		}

		return string;
	}

	function strToISO(str) {
		var date = Zotero.Date.strToDate(str);

		if(date.year) {
			var dateString = Zotero.Utilities.lpad(date.year, "0", 4);
			if (parseInt(date.month) == date.month) {
				dateString += "-"+Zotero.Utilities.lpad(date.month+1, "0", 2);
				if(date.day) {
					dateString += "-"+Zotero.Utilities.lpad(date.day, "0", 2);
				}
			}
			return dateString;
		}
		return false;
	}


	this.sqlToISO8601 = function (sqlDate) {
		var date = sqlDate.substr(0, 10);
		var matches = date.match(/^([0-9]{4})\-([0-9]{2})\-([0-9]{2})/);
		if (!matches) {
			return false;
		}
		date = matches[1];
		// Drop parts for reduced precision
		if (matches[2] !== "00") {
			date += "-" + matches[2];
			if (matches[3] !== "00") {
				date += "-" + matches[3];
			}
		}
		var time = sqlDate.substr(11);
		// TODO: validate times
		if (time) {
			date += "T" + time + "Z";
		}
		return date;
	}

	function strToMultipart(str){
		if (!str){
			return '';
		}

		var parts = strToDate(str);

		// FIXME: Until we have a better BCE date solution,
		// remove year value if not between 1 and 9999
		if (parts.year) {
			var year = parts.year + '';
			if (!year.match(/^[0-9]{1,4}$/)) {
				delete parts.year;
			}
		}

		parts.month = typeof parts.month != "undefined" ? parts.month + 1 : '';

		var multi = (parts.year ? Zotero.Utilities.lpad(parts.year, '0', 4) : '0000') + '-'
			+ Zotero.Utilities.lpad(parts.month, '0', 2) + '-'
			+ (parts.day ? Zotero.Utilities.lpad(parts.day, '0', 2) : '00')
			+ ' '
			+ str;
		return multi;
	}

	// Regexes for multipart and SQL dates
	// Allow zeroes in multipart dates
	// TODO: Allow negative multipart in DB and here with \-?
	var _multipartRE = /^[0-9]{4}\-(0[0-9]|10|11|12)\-(0[0-9]|[1-2][0-9]|30|31) /;
	var _sqldateRE = /^\-?[0-9]{4}\-(0[1-9]|10|11|12)\-(0[1-9]|[1-2][0-9]|30|31)$/;
	var _sqldateWithZeroesRE = /^\-?[0-9]{4}\-(0[0-9]|10|11|12)\-(0[0-9]|[1-2][0-9]|30|31)$/;
	var _sqldatetimeRE = /^\-?[0-9]{4}\-(0[1-9]|10|11|12)\-(0[1-9]|[1-2][0-9]|30|31) ([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$/;

	/**
	 * Tests if a string is a multipart date string
	 * e.g. '2006-11-03 November 3rd, 2006'
	 */
	function isMultipart(str){
		if (isSQLDateTime(str)) {
			return false;
		}
		return _multipartRE.test(str);
	}


	/**
	 * Returns the SQL part of a multipart date string
	 * (e.g. '2006-11-03 November 3rd, 2006' returns '2006-11-03')
	 */
	function multipartToSQL(multi){
		if (!multi){
			return '';
		}

		if (!isMultipart(multi)){
			return '0000-00-00';
		}

		return multi.substr(0, 10);
	}


	/**
	 * Returns the user part of a multipart date string
	 * (e.g. '2006-11-03 November 3rd, 2006' returns 'November 3rd, 2006')
	 */
	function multipartToStr(multi){
		if (!multi){
			return '';
		}

		if (!isMultipart(multi)){
			return multi;
		}

		return multi.substr(11);
	}


	function isSQLDate(str, allowZeroes) {
		if (allowZeroes) {
			return _sqldateWithZeroesRE.test(str);
		}
		return _sqldateRE.test(str);
	}


	function isSQLDateTime(str){
		return _sqldatetimeRE.test(str);
	}


	function sqlHasYear(sqldate){
		return isSQLDate(sqldate, true) && sqldate.substr(0,4)!='0000';
	}


	function sqlHasMonth(sqldate){
		return isSQLDate(sqldate, true) && sqldate.substr(5,2)!='00';
	}


	function sqlHasDay(sqldate){
		return isSQLDate(sqldate, true) && sqldate.substr(8,2)!='00';
	}


	function getUnixTimestamp() {
		return Math.round(Date.now() / 1000);
	}


	function toUnixTimestamp(date) {
		if (date === null || typeof date != 'object' ||
				date.constructor.name != 'Date') {
			throw ('Not a valid date in Zotero.Date.toUnixTimestamp()');
		}
		return Math.round(date.getTime() / 1000);
	}


	/**
	 * Convert a JS Date to a relative date (e.g., "5 minutes ago")
	 *
	 * Adapted from http://snipplr.com/view/10290/javascript-parse-relative-date/
	 *
	 * @param	{Date}	date
	 * @return	{String}
	 */
	this.toRelativeDate = function (date) {
		var str;
		var now = new Date();
		var timeSince = now.getTime() - date;
		var inSeconds = timeSince / 1000;
		var inMinutes = timeSince / 1000 / 60;
		var inHours = timeSince / 1000 / 60 / 60;
		var inDays = timeSince / 1000 / 60 / 60 / 24;
		var inYears = timeSince / 1000 / 60 / 60 / 24 / 365;

		var n;

		// in seconds
		if (Math.round(inSeconds) == 1) {
			var key = "secondsAgo";
		}
		else if (inMinutes < 1.01) {
			var key = "secondsAgo";
			n = Math.round(inSeconds);
		}

		// in minutes
		else if (Math.round(inMinutes) == 1) {
			var key = "minutesAgo";
		}
		else if (inHours < 1.01) {
			var key = "minutesAgo";
			n = Math.round(inMinutes);
		}

		// in hours
		else if (Math.round(inHours) == 1) {
			var key = "hoursAgo";
		}
		else if (inDays < 1.01) {
			var key = "hoursAgo";
			n = Math.round(inHours);
		}

		// in days
		else if (Math.round(inDays) == 1) {
			var key = "daysAgo";
		}
		else if (inYears < 1.01) {
			var key = "daysAgo";
			n = Math.round(inDays);
		}

		// in years
		else if (Math.round(inYears) == 1) {
			var key = "yearsAgo";
		}
		else {
			var key = "yearsAgo";
			var n = Math.round(inYears);
		}

		return Zotero.getString("date.relative." + key + "." + (n ? "multiple" : "one"), n);
	}


	function getFileDateString(file){
		var date = new Date();
		date.setTime(file.lastModifiedTime);
		return date.toLocaleDateString();
	}


	function getFileTimeString(file){
		var date = new Date();
		date.setTime(file.lastModifiedTime);
		return date.toLocaleTimeString();
	}

	/**
	 * Get the order of the date components based on the current locale
	 *
	 * Returns a string with y, m, and d (e.g. 'ymd', 'mdy')
	 */
	function getLocaleDateOrder(){
		if (!_localeDateOrder) {
			switch (Zotero.locale ? Zotero.locale.substr(3) : "US") {
				// middle-endian
				case 'US': // The United States
				case 'BZ': // Belize
				case 'FM': // The Federated States of Micronesia
				case 'PA': // Panama
				case 'PH':	// The Philippines
				case 'PW':	// Palau
				case 'ZW': // Zimbabwe
					_localeDateOrder = 'mdy';
					break;

				// big-endian
				case 'fa': // Persian
				case 'AL': // Albania
				case 'CA': // Canada
				case 'CN': // China
				case 'HU': // Hungary
				case 'JP': // Japan
				case 'KE': // Kenya
				case 'KR': // Korea
				case 'LT': // Lithuania
				case 'LV': // Latvia
				case 'MN': // Mongolia
				case 'SE': // Sweden
				case 'TW': // Taiwan
				case 'ZA': // South Africa
					_localeDateOrder = 'ymd';
					break;

				// little-endian
				default:
					_localeDateOrder = 'dmy';
			}
		}
		return _localeDateOrder;
	}
}

/******** END date.js ********/
/******** BEGIN http.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2011 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

/**
 * Functions for performing HTTP requests, both via XMLHTTPRequest and using a hidden browser
 * @namespace
 */
if(!Zotero.HTTP) Zotero.HTTP = {};

/**
 * Determines whether the page to be loaded has the same origin as the current page
 */
Zotero.HTTP.isSameOrigin = function(url) {
	const hostPortRe = /^([^:\/]+:)\/\/([^\/]+)/i;
	var m = hostPortRe.exec(url);
	if(!m) {
		return true;
	} else {
		var location = Zotero.isBookmarklet ? window.parent.location : window.location;
		return m[1].toLowerCase() === location.protocol.toLowerCase() &&
			m[2].toLowerCase() === location.host.toLowerCase();
	}
}

/**
 * Determing if trying to load non-HTTPs URLs from HTTPS pages
 */
Zotero.HTTP.isLessSecure = function(url) {
	if (url.substr(0,8).toLowerCase() == 'https://') return false;

	var location = Zotero.isBookmarklet ? window.parent.location : window.location;
	return location.protocol.toLowerCase() == 'https:';
}

/**
 * Load one or more documents in a hidden iframe
 *
 * @param {String|String[]} urls URL(s) of documents to load
 * @param {Function} processor Callback to be executed for each document loaded
 * @param {Function} done Callback to be executed after all documents have been loaded
 * @param {Function} exception Callback to be executed if an exception occurs
 */
Zotero.HTTP.processDocuments = function(urls, processor, done, exception, dontDelete) {
	var loadingURL;

	/**
	 * Removes event listener for the load event and deletes the hidden browser
	 */
	var removeListeners = function() {
		if("removeEventListener" in hiddenBrowser) {
			hiddenBrowser.removeEventListener("load", onFrameLoad, false);
		}
		if(!dontDelete) Zotero.Browser.removeHiddenBrowser(hiddenBrowser);
	}

	/**
	 * Loads the next page
	 * @inner
	 */
	var doLoad = function() {
		if(urls.length) {
			loadingURL = urls.shift();
			try {
				Zotero.debug("HTTP.processDocuments: Loading "+loadingURL);
				if(Zotero.HTTP.isSameOrigin(loadingURL)) {
					hiddenBrowser.src = loadingURL;
					if(Zotero.isBookmarklet) {
						// Hack to disable window.alert() on iframe loads
						var id = window.setInterval(function() {
							var win;
							if(hiddenBrowser.contentWindow) {
								win = hiddenBrowser.contentWindow;
							} else if(hiddenBrowser.contentDocument) {
								win = hiddenBrowser.contentDocument.window;
							}

							if(win) {
								if(hiddenBrowser.contentWindow.location == "about:blank") return;
								hiddenBrowser.contentWindow.alert = function() {};
							}
							window.clearInterval(id);
						}, 0);
					}
				} else if(Zotero.isBookmarklet) {
					throw "HTTP.processDocuments: Cannot perform cross-site request from "+window.parent.location+" to "+loadingURL;
				} else {
					Zotero.HTTP.doGet(loadingURL, onCrossSiteLoad);
				}
			} catch(e) {
				if(exception) {
					try {
						exception(e);
					} catch(e) {
						Zotero.logError(e);
					}
					return;
				} else {
					Zotero.logError(e);
				}

				removeListeners();
			}
		} else {
			if(done) {
				try {
					done();
				} catch(e) {
          console.log(e)
					Zotero.logError(done);
				}
			}

			removeListeners();
		}
	};

	/**
	 * Process a loaded document
	 * @inner
	 */
	var process = function(newLoc, newDoc, newWin) {
		try {
			if(newLoc === "about:blank") return;
			Zotero.debug("HTTP.processDocuments: "+newLoc+" has been loaded");
			if(newLoc !== prevUrl) {	// Just in case it fires too many times
				prevUrl = newLoc;

				// ugh ugh ugh ugh
				if(Zotero.isIE) installXPathIfNecessary(newWin);

				try {
					processor(newDoc, newLoc);
				} catch(e) {
					Zotero.logError(e);
				}

				doLoad();
			}
		} catch(e) {
			if(exception) {
				try {
					exception(e);
				} catch(e) {
					Zotero.logError(e);
				}
			} else {
				Zotero.logError(e);
			}

			removeListeners();
			return;
		}
	}

	/**
	 * Callback to be executed when a page is retrieved via cross-site XHR
	 * @inner
	 */
	var onCrossSiteLoad = function(xmlhttp) {
		// add iframe
		var iframe = document.createElement("iframe");
		iframe.style.display = "none";
		// ban script execution
		iframe.setAttribute("sandbox", "allow-same-origin allow-forms");
		document.body.appendChild(iframe);

		// load cross-site data into iframe
		doc = iframe.contentDocument;
		doc.open();
		doc.write(xmlhttp.responseText);
		doc.close();
		process(loadingURL, doc, iframe.contentWindow || iframe.contentDocument.defaultView);
	}

	/**
	 * Callback to be executed when a page load completes
	 * @inner
	 */
	var onFrameLoad = function() {
		var newWin = hiddenBrowser.contentWindow, newDoc, newLoc;
		try {
			if(newWin) {
				newDoc = newWin.document;
			} else {
				newDoc = hiddenBrowser.contentDocument;
				newWin = newDoc.defaultView;
			}
			newLoc = newDoc.documentURI || newWin.location.toString();
		} catch(e) {
			e = "Same origin HTTP request redirected to a different origin not handled";

			if(exception) {
				try {
					exception(e);
				} catch(e) {
					Zotero.logError(e);
				}
			} else {
				Zotero.logError(e);
			}

			removeListeners();
			return;
		}
		process(newLoc, newDoc, newWin);
	};

	if(typeof(urls) == "string") urls = [urls];

	var prevUrl;

	var hiddenBrowser = Zotero.Browser.createHiddenBrowser();
	if(hiddenBrowser.addEventListener) {
		hiddenBrowser.addEventListener("load", onFrameLoad, false);
	} else {
		hiddenBrowser.attachEvent("onload", onFrameLoad);
	}

	doLoad();
	return hiddenBrowser;
}

Zotero.Browser = {
	"createHiddenBrowser":function() {
		var hiddenBrowser = document.createElement("iframe");
		//if(!Zotero.isBookmarklet) {
			hiddenBrowser.style.display = "none";
		//}
		if(document.domain == document.location.hostname) {
			// Since sandboxed iframes cannot set document.domain, if
			// document.domain is set on this page, then SOP will
			// definitely prevent us from accessing the document
			// in a sandboxed iframe. On the other hand, if we don't
			// sandbox the iframe, it is possible it will navigate the
			// top-level page. So we set the sandbox attribute only if
			// we are not certain that document.domain has been set.
			// This is not perfect, since if a page sets
			// document.domain = document.domain, it is still a
			// different origin and we will not be able to access pages
			// loaded in the iframe. Additionally, if a page sets
			// document.domain to a different hostname, since we don't
			// sandbox, it is possible that it will navigate the
			// top-level page.
			// TODO: consider HTML XHR
			hiddenBrowser.sandbox = "allow-same-origin allow-forms allow-scripts";
		}
		document.body.appendChild(hiddenBrowser);
		return hiddenBrowser;
	},
	"deleteHiddenBrowser":function(hiddenBrowser) {
		document.body.removeChild(hiddenBrowser);
	}
}
/******** END http.js ********/
/******** BEGIN openurl.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

Zotero.OpenURL = new function() {
	this.resolve = resolve;
	this.discoverResolvers = discoverResolvers;
	this.createContextObject = createContextObject;
	this.parseContextObject = parseContextObject;

	/*
	 * Returns a URL to look up an item in the OpenURL resolver
	 */
	function resolve(itemObject) {
		var co = createContextObject(itemObject, Zotero.Prefs.get("openURL.version"));
		if(co) {
			var base = Zotero.Prefs.get("openURL.resolver");
			// Add & if there's already a ?
			var splice = base.indexOf("?") == -1 ? "?" : "&";
			return base + splice + co;
		}
		return false;
	}

	/*
	 * Queries OCLC's OpenURL resolver registry and returns an address and version
	 */
	function discoverResolvers() {
		var req = Components.classes["@mozilla.org/xmlextras/xmlhttprequest;1"].createInstance();
		req.open("GET", "http://worldcatlibraries.org/registry/lookup?IP=requestor", false);
		req.send(null);

		if(!req.responseXML) {
			throw "Could not access resolver registry";
		}

		var resolverArray = new Array();
		var resolvers = req.responseXML.getElementsByTagName("resolver");
		for(var i=0; i<resolvers.length; i++) {
			var resolver = resolvers[i];

			var name = resolver.parentNode.getElementsByTagName("institutionName");
			if(!name.length) {
				continue;
			}
			name = name[0].textContent;

			var url = resolver.getElementsByTagName("baseURL");
			if(!url.length) {
				continue;
			}
			url = url[0].textContent;

			if(resolver.getElementsByTagName("Z39.88-2004").length > 0) {
				var version = "1.0";
			} else if(resolver.getElementsByTagName("OpenURL_0.1").length > 0) {
				var version = "0.1";
			} else {
				continue;
			}

			resolverArray.push({name:name, url:url, version:version});
		}

		return resolverArray;
	}

	/*
	 * Generates an OpenURL ContextObject from an item
	 */
	function createContextObject(item, version, asObj) {
		var entries = (asObj ? {} : []);

		function _mapTag(data, tag, dontAddPrefix) {
			if(!data) return;

			if(version === "1.0" && !dontAddPrefix) tag = "rft."+tag;

			if(asObj) {
				if(!entries[tag]) entries[tag] = [];
				entries[tag].push(data);
			} else {
				entries.push(tag+"="+encodeURIComponent(data));
			}
		}

		if(item.toArray) {
			item = item.toArray();
		}

		// find pmid
		const pmidRe = /(?:\n|^)PMID:\s*(\d+)/g;
		var pmid = pmidRe.exec(item.extra);
		if(pmid) pmid = pmid[1];

		// encode ctx_ver (if available) and encode identifiers
		if(version == "0.1") {
			_mapTag("Zotero:2", "sid", true);
			if(item.DOI) _mapTag("doi:"+item.DOI, "id", true);
			if(item.ISBN) _mapTag(item.ISBN, "isbn", true);
			if(pmid) _mapTag("pmid:"+pmid, "id", true);
		} else {
			_mapTag("Z39.88-2004", "url_ver", true);
			_mapTag("Z39.88-2004", "ctx_ver", true);
			_mapTag("info:sid/zotero.org:2", "rfr_id", true);
			if(item.DOI) _mapTag("info:doi/"+item.DOI, "rft_id", true);
			if(item.ISBN) _mapTag("urn:isbn:"+item.ISBN, "rft_id", true);
			if(pmid) _mapTag("info:pmid/"+pmid, "rft_id", true);
		}

		// encode genre and item-specific data
		if(item.itemType == "journalArticle") {
			if(version === "1.0") {
				_mapTag("info:ofi/fmt:kev:mtx:journal", "rft_val_fmt", true);
			}
			_mapTag("article", "genre");

			_mapTag(item.title, "atitle");
			_mapTag(item.publicationTitle, (version == "0.1" ? "title" : "jtitle"));
			_mapTag(item.journalAbbreviation, "stitle");
			_mapTag(item.volume, "volume");
			_mapTag(item.issue, "issue");
		} else if(item.itemType == "book" || item.itemType == "bookSection" || item.itemType == "conferencePaper" || item.itemType == "report") {
			if(version === "1.0") {
				_mapTag("info:ofi/fmt:kev:mtx:book", "rft_val_fmt", true);
			}

			if(item.itemType == "book") {
				_mapTag("book", "genre");
				_mapTag(item.title, (version == "0.1" ? "title" : "btitle"));
			} else if (item.itemType == "conferencePaper") {
				_mapTag("proceeding", "genre");
				_mapTag(item.title, "atitle");
				_mapTag(item.proceedingsTitle, (version == "0.1" ? "title" : "btitle"));
			} else if (item.itemType == "report") {
				_mapTag("report", "genre");
				_mapTag(item.seriesTitle, "series");
				_mapTag(item.title, (version == "0.1" ? "title" : "btitle"));
			} else {
				_mapTag("bookitem", "genre");
				_mapTag(item.title, "atitle");
				_mapTag(item.publicationTitle, (version == "0.1" ? "title" : "btitle"));
			}

			_mapTag(item.place, "place");
			_mapTag(item.publisher, "publisher");
			_mapTag(item.edition, "edition");
			_mapTag(item.series, "series");
		} else if(item.itemType == "thesis" && version == "1.0") {
			_mapTag("info:ofi/fmt:kev:mtx:dissertation", "rft_val_fmt", true);

			_mapTag(item.title, "title");
			_mapTag(item.publisher, "inst");
			_mapTag(item.type, "degree");
		} else if(item.itemType == "patent" && version == "1.0") {
			_mapTag("info:ofi/fmt:kev:mtx:patent", "rft_val_fmt", true);

			_mapTag(item.title, "title");
			_mapTag(item.assignee, "assignee");
			_mapTag(item.patentNumber, "number");

			if(item.issueDate) {
				_mapTag(Zotero.Date.strToISO(item.issueDate), "date");
			}
		} else {
			//we map as much as possible to DC for all other types. This will export some info
			//and work very nicely on roundtrip. All of these fields legal for mtx:dc according to
			//http://alcme.oclc.org/openurl/servlet/OAIHandler/extension?verb=GetMetadata&metadataPrefix=mtx&identifier=info:ofi/fmt:kev:mtx:dc
			_mapTag("info:ofi/fmt:kev:mtx:dc", "rft_val_fmt", true);
			//lacking something better we use Zotero item types here; no clear alternative and this works for roundtrip
			_mapTag(item.itemType, "type");
			_mapTag(item.title, "title");
			_mapTag(item.publicationTitle, "source");
			_mapTag(item.rights, "rights");
			_mapTag(item.publisher, "publisher");
			_mapTag(item.abstractNote, "description");
			if(item.DOI){
				 _mapTag("urn:doi:" + item.DOI, "identifier");
			}
			else if(item.url){
				 _mapTag(item.url, "identifier");
			}
		}

		if(item.creators && item.creators.length) {
			// encode first author as first and last
			var firstCreator = item.creators[0];
			if(item.itemType == "patent") {
				_mapTag(firstCreator.firstName, "invfirst");
				_mapTag(firstCreator.lastName, "invlast");
			} else {
				if(firstCreator.isInstitution) {
					_mapTag(firstCreator.lastName, "aucorp");
				} else {
					_mapTag(firstCreator.firstName, "aufirst");
					_mapTag(firstCreator.lastName, "aulast");
				}
			}

			// encode subsequent creators as au
			for(var i=0; i<item.creators.length; i++) {
				_mapTag((item.creators[i].firstName ? item.creators[i].firstName+" " : "")+
					item.creators[i].lastName, (item.itemType == "patent" ? "inventor" : "au"));
			}
		}

		if(item.date) {
			_mapTag(Zotero.Date.strToISO(item.date), (item.itemType == "patent" ? "appldate" : "date"));
		}
		if(item.pages) {
			_mapTag(item.pages, "pages");
			var pages = item.pages.split(/[-–]/);
			if(pages.length > 1) {
				_mapTag(pages[0], "spage");
				if(pages.length >= 2) _mapTag(pages[1], "epage");
			}
		}
		_mapTag(item.numPages, "tpages");
		_mapTag(item.ISBN, "isbn");
		_mapTag(item.ISSN, "issn");
		_mapTag(item.language, "language");
		if(asObj) return entries;
		return entries.join("&");
	}

	function _cloneIfNecessary(obj1, obj2) {
		if(Zotero.isFx && !Zotero.isBookmarklet && Zotero.platformMajorVersion >= 32) {
			return Components.utils.cloneInto(obj1, obj2);
		}
		return obj1;
	}

	/*
	 * Generates an item in the format returned by item.fromArray() given an
	 * OpenURL version 1.0 contextObject
	 *
	 * accepts an item array to fill, or creates and returns a new item array
	 */
	function parseContextObject(co, item) {
		if(!item) {
			var item = new Array();
			item.creators = new Array();
		}

		var coParts = co.split("&");

		// get type
		for(var i=0; i<coParts.length; i++) {
			if(coParts[i].substr(0, 12) == "rft_val_fmt=") {
				var format = decodeURIComponent(coParts[i].substr(12));
				if(format == "info:ofi/fmt:kev:mtx:journal") {
					item.itemType = "journalArticle";
					break;
				} else if(format == "info:ofi/fmt:kev:mtx:book") {
					if(coParts.indexOf("rft.genre=bookitem") !== -1) {
						item.itemType = "bookSection";
					} else if(coParts.indexOf("rft.genre=conference") !== -1 || coParts.indexOf("rft.genre=proceeding") !== -1) {
						item.itemType = "conferencePaper";
					} else if(coParts.indexOf("rft.genre=report") !== -1) {
						item.itemType = "report";
					} else if(coParts.indexOf("rft.genre=document") !== -1) {
						item.itemType = "document";
					} else {
						item.itemType = "book";
					}
					break;
				} else if(format == "info:ofi/fmt:kev:mtx:dissertation") {
					item.itemType = "thesis";
					break;
				} else if(format == "info:ofi/fmt:kev:mtx:patent") {
					item.itemType = "patent";
					break;
				} else if(format == "info:ofi/fmt:kev:mtx:dc") {
					item.itemType = "webpage";
					break;
				}
			}
		}
		if(!item.itemType) {
			return false;
		}

		var pagesKey = "";

		// keep track of "aucorp," "aufirst," "aulast"
		var complexAu = new Array();

		for(var i=0; i<coParts.length; i++) {
			var keyVal = coParts[i].split("=");
			var key = keyVal[0];
			var value = decodeURIComponent(keyVal[1].replace(/\+|%2[bB]/g, " "));
			if(!value) {
				continue;
			}

			if(key == "rft_id") {
				var firstEight = value.substr(0, 8).toLowerCase();
				if(firstEight == "info:doi") {
					item.DOI = value.substr(9);
				} else if(firstEight == "urn:isbn") {
					item.ISBN = value.substr(9);
				} else if(value.match(/^https?:\/\//)) {
					item.url = value;
					item.accessDate = "";
				}
			} else if(key == "rft.btitle") {
				if(item.itemType == "book" || item.itemType == "report") {
					item.title = value;
				} else if(item.itemType == "bookSection" || item.itemType == "conferencePaper") {
					item.publicationTitle = value;
				}
			} else if(key == "rft.atitle"
					&& ["journalArticle", "bookSection", "conferencePaper"].indexOf(item.itemType) !== -1) {
				item.title = value;
			} else if(key == "rft.jtitle" && item.itemType == "journalArticle") {
				item.publicationTitle = value;
			} else if(key == "rft.stitle" && item.itemType == "journalArticle") {
				item.journalAbbreviation = value;
			} else if(key == "rft.title") {
				if(["journalArticle", "bookSection", "conferencePaper"].indexOf(item.itemType) !== -1) {
					item.publicationTitle = value;
				} else {
					item.title = value;
				}
			} else if(key == "rft.date") {
				if(item.itemType == "patent") {
					item.issueDate = value;
				} else {
					item.date = value;
				}
			} else if(key == "rft.volume") {
				item.volume = value;
			} else if(key == "rft.issue") {
				item.issue = value;
			} else if(key == "rft.pages") {
				pagesKey = key;
				item.pages = value;
			} else if(key == "rft.spage") {
				if(pagesKey != "rft.pages") {
					// make pages look like start-end
					if(pagesKey == "rft.epage") {
						if(value != item.pages) {
							item.pages = value+"-"+item.pages;
						}
					} else {
						item.pages = value;
					}
					pagesKey = key;
				}
			} else if(key == "rft.epage") {
				if(pagesKey != "rft.pages") {
					// make pages look like start-end
					if(pagesKey == "rft.spage") {
						if(value != item.pages) {
							item.pages = item.pages+"-"+value;
						}
					} else {
						item.pages = value;
					}
					pagesKey = key;
				}
			} else if(key == "rft.issn" || (key == "rft.eissn" && !item.ISSN)) {
				item.ISSN = value;
			} else if(key == "rft.aulast" || key == "rft.invlast") {
				var lastCreator = complexAu[complexAu.length-1];
				if(complexAu.length && !lastCreator.lastName && !lastCreator.institutional) {
					lastCreator.lastName = value;
				} else {
					complexAu.push(_cloneIfNecessary({lastName:value, creatorType:(key == "rft.aulast" ? "author" : "inventor"), offset:item.creators.length}, item));
				}
			} else if(key == "rft.aufirst" || key == "rft.invfirst") {
				var lastCreator = complexAu[complexAu.length-1];
				if(complexAu.length && !lastCreator.firstName && !lastCreator.institutional) {
					lastCreator.firstName = value;
				} else {
					complexAu.push(_cloneIfNecessary({firstName:value, creatorType:(key == "rft.aufirst" ? "author" : "inventor"), offset:item.creators.length}, item));
				}
			} else if(key == "rft.au" || key == "rft.creator" || key == "rft.contributor" || key == "rft.inventor") {
				if(key == "rft.contributor") {
					var type = "contributor";
				} else if(key == "rft.inventor") {
					var type = "inventor";
				} else {
					var type = "author";
				}

				item.creators.push(_cloneIfNecessary(Zotero.Utilities.cleanAuthor(value, type, value.indexOf(",") !== -1), item));
			} else if(key == "rft.aucorp") {
				complexAu.push(_cloneIfNecessary({lastName:value, isInstitution:true}, item));
			} else if(key == "rft.isbn" && !item.ISBN) {
				item.ISBN = value;
			} else if(key == "rft.pub" || key == "rft.publisher") {
				item.publisher = value;
			} else if(key == "rft.place") {
				item.place = value;
			} else if(key == "rft.tpages") {
				item.numPages = value;
			} else if(key == "rft.edition") {
				item.edition = value;
			} else if(key == "rft.series") {
				if(item.itemType == "report") {
					item.seriesTitle = value;
				} else {
					item.series = value;
				}
			} else if(item.itemType == "thesis") {
				if(key == "rft.inst") {
					item.publisher = value;
				} else if(key == "rft.degree") {
					item.type = value;
				}
			} else if(item.itemType == "patent") {
				if(key == "rft.assignee") {
					item.assignee = value;
				} else if(key == "rft.number") {
					item.patentNumber = value;
				} else if(key == "rft.appldate") {
					item.date = value;
				}
			} else if(format == "info:ofi/fmt:kev:mtx:dc") {
				if(key == "rft.identifier") {
					if(value.length > 8) {	// we could check length separately for
											// each type, but all of these identifiers
											// must be > 8 characters
						if(value.substr(0, 5) == "ISBN ") {
							item.ISBN = value.substr(5);
						} else if(value.substr(0, 5) == "ISSN ") {
							item.ISSN = value.substr(5);
						} else if(value.substr(0, 8) == "urn:doi:") {
							item.DOI = value.substr(4);
						} else if(value.substr(0, 7) == "http://" || value.substr(0, 8) == "https://") {
							item.url = value;
						}
					}
				} else if(key == "rft.description") {
					item.abstractNote = value;
				} else if(key == "rft.rights") {
					item.rights = value;
				} else if(key == "rft.language") {
				  	item.language = value;
				}  else if(key == "rft.subject") {
					item.tags.push(value);
				} else if(key == "rft.type") {
					if(Zotero.Utilities.itemTypeExists(value)) item.itemType = value;
				} else if(key == "rft.source") {
					item.publicationTitle = value;
				}
			}
		}

		// To maintain author ordering when complex and simple authors are combined,
		// we remember where they were and the correct offsets
		var inserted = 0;

		// combine two lists of authors, eliminating duplicates
		for(var i=0; i<complexAu.length; i++) {
			var pushMe = true;
			var offset = complexAu[i].offset;
			delete complexAu[i].offset;
			for (var j = 0; j < item.creators.length; j++) {
			    // if there's a plain author that is close to this author (the
			    // same last name, and the same first name up to a point), keep
			    // the plain author, since it might have a middle initial
			    if (item.creators[j].lastName == complexAu[i].lastName &&
			        item.creators[j].firstName &&
			        ((item.creators[j].firstName == "" && complexAu[i].firstName == "") ||
			            (item.creators[j].firstName.length >= complexAu[i].firstName.length &&
			                item.creators[j].firstName.substr(0, complexAu[i].firstName.length) == complexAu[i].firstName))) {
			        pushMe = false;
			        break;
			    }
			}
			// Splice in the complex creator at the correct location,
			// accounting for previous insertions
			if(pushMe) {
				item.creators.splice(offset + inserted, 0, complexAu[i]);
				inserted++;
			}
		}

		return item;
	}
}

/******** END openurl.js ********/
/******** BEGIN progressWindow.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2011 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

const cssDivClearString = 'background-attachment: scroll; background-color: transparent; background-image: none; background-position: 0% 0%; background-repeat: repeat; border-bottom-color: rgb(0, 0, 0); border-bottom-style: none; border-bottom-width: 0px; border-collapse: separate; border-left-color: rgb(0, 0, 0); border-left-style: none; border-left-width: 0px; border-right-color: rgb(0, 0, 0); border-right-style: none; border-right-width: 0px; border-spacing: 0px 0px; border-top-color: rgb(0, 0, 0); border-top-style: none; border-top-width: 0px; bottom: auto; caption-side: top; clear: none; clip: auto; color: rgb(255, 255, 255); content: none; counter-increment: none; counter-reset: none; cursor: auto; direction: ltr; display: block; empty-cells: show; float: none; font-family: serif; font-size: 16px; font-size-adjust: none; font-stretch: normal; font-style: normal; font-variant: normal; font-weight: 400; left: auto; letter-spacing: normal; line-height: normal; list-style-image: none; list-style-position: outside; list-style-type: disc; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; marker-offset: auto; max-height: none; max-width: none; min-height: 0px; min-width: 0px; ime-mode: auto; opacity: 1; outline-color: rgb(0, 0, 0); outline-style: none; outline-width: 0px; outline-offset: 0px; overflow: visible; overflow-x: visible; overflow-y: visible; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; page-break-after: auto; page-break-before: auto; pointer-events: auto; position: static; quotes: "“" "”" "‘" "’"; right: auto; table-layout: auto; text-align: left; text-decoration: none; text-indent: 0px; text-shadow: none; text-transform: none; top: auto; unicode-bidi: embed; vertical-align: baseline; visibility: visible; white-space: normal; word-spacing: 0px; z-index: auto; background-clip: border-box; background-origin: padding-box; background-size: auto auto; border-bottom-left-radius: 0px; border-bottom-right-radius: 0px; border-top-left-radius: 0px; border-top-right-radius: 0px; box-shadow: none; resize: none; word-wrap: normal; clip-path: none; clip-rule: nonzero; color-interpolation: srgb; color-interpolation-filters: linearrgb; dominant-baseline: auto; fill: rgb(0, 0, 0); fill-opacity: 1; fill-rule: nonzero; filter: none; flood-color: rgb(0, 0, 0); flood-opacity: 1; lighting-color: rgb(255, 255, 255); image-rendering: auto; mask: none; marker-end: none; marker-mid: none; marker-start: none; shape-rendering: auto; stop-color: rgb(0, 0, 0); stop-opacity: 1; stroke: none; stroke-dasharray: none; stroke-dashoffset: 0px; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-opacity: 1; stroke-width: 1px; text-anchor: start; text-rendering: auto;';
const cssAClearString = 'background-attachment: scroll; background-color: transparent; background-image: none; background-position: 0% 0%; background-repeat: repeat; border-bottom-color: rgb(0, 0, 238); border-bottom-style: none; border-bottom-width: 0px; border-collapse: separate; border-left-color: rgb(0, 0, 238); border-left-style: none; border-left-width: 0px; border-right-color: rgb(0, 0, 238); border-right-style: none; border-right-width: 0px; border-spacing: 0px 0px; border-top-color: rgb(0, 0, 238); border-top-style: none; border-top-width: 0px; bottom: auto; caption-side: top; clear: none; clip: auto; color: rgb(0, 0, 238); content: none; counter-increment: none; counter-reset: none; cursor: pointer; direction: ltr; display: inline; empty-cells: show; float: none; font-family: serif; font-size: 16px; font-size-adjust: none; font-stretch: normal; font-style: normal; font-variant: normal; font-weight: 400; height: auto; left: auto; letter-spacing: normal; line-height: normal; list-style-image: none; list-style-position: outside; list-style-type: disc; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; marker-offset: auto; max-height: none; max-width: none; min-height: 0px; min-width: 0px; ime-mode: auto; opacity: 1; outline-color: rgb(0, 0, 0); outline-style: none; outline-width: 0px; outline-offset: 0px; overflow: visible; overflow-x: visible; overflow-y: visible; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; page-break-after: auto; page-break-before: auto; pointer-events: auto; position: static; quotes: "“" "”" "‘" "’"; right: auto; table-layout: auto; text-align: left; text-decoration: underline; text-indent: 0px; text-shadow: none; text-transform: none; top: auto; unicode-bidi: normal; vertical-align: baseline; visibility: visible; white-space: normal; width: auto; word-spacing: 0px; z-index: auto; background-clip: border-box; background-origin: padding-box; background-size: auto auto; border-bottom-left-radius: 0px; border-bottom-right-radius: 0px; border-top-left-radius: 0px; border-top-right-radius: 0px; box-shadow: none; resize: none; word-wrap: normal; clip-path: none; clip-rule: nonzero; color-interpolation: srgb; color-interpolation-filters: linearrgb; dominant-baseline: auto; fill: rgb(0, 0, 0); fill-opacity: 1; fill-rule: nonzero; filter: none; flood-color: rgb(0, 0, 0); flood-opacity: 1; lighting-color: rgb(255, 255, 255); image-rendering: auto; mask: none; marker-end: none; marker-mid: none; marker-start: none; shape-rendering: auto; stop-color: rgb(0, 0, 0); stop-opacity: 1; stroke: none; stroke-dasharray: none; stroke-dashoffset: 0px; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 4; stroke-opacity: 1; stroke-width: 1px; text-anchor: start; text-rendering: auto;'

Zotero.ProgressWindow = new function() {
	const cssBox = {"position":(Zotero.isIE && document.compatMode === "BackCompat" ? "absolute" : "fixed"),
		"right":"0", "top":"0", "width":"385px", "min-height":"60px", "color":"rgb(255,255,255) !important",
		"backgroundColor":"#0e7bba",
		"zIndex":"1000000091", "padding":"8px", "minHeight":"40px"};
	const cssHeadline = {"fontFamily":"'Roboto', Helvetica, Arial, sans-serif", "fontSize":"15px",
		"overflow":"hidden",
		"whiteSpace":"nowrap", "textOverflow":"ellipsis"};
	const cssHeadlineIcon = {"display":"none", "width":"16px", "height":"16px",
		"backgroundPosition":"center", "backgroundRepeat":"no-repeat",
		"verticalAlign":"-3px"};
	const cssItem = {"fontSize":"15px", "margin":"4px 0 4px 0"};
	const cssIcon = {"position":"absolute", "fontSize":"15px", "width":"16px", "height":"16px",
		"backgroundPosition":"0", "backgroundRepeat":"no-repeat"};
	const cssItemText = {"fontFamily":"'Roboto', Helvetica, Arial, sans-serif",
		"fontSize":"13px", "verticalAlign":"middle", "overflow":"hidden",
		"whiteSpace":"nowrap", "lineHeight":"11px", "margin":"0"};
	const cssDescription = {"fontFamily":"'Roboto', Helvetica, Arial, sans-serif", "fontSize":"13px",
		"lineHeight":"1.4em", "marginBottom":"4px"};

	if(Zotero.isBookmarklet) {
		var imageBase = ZOTERO_CONFIG.BOOKMARKLET_URL+"images/";
	} else if(Zotero.isChrome) {
		var imageBase =  chrome.extension.getURL("images/");
	} else if(Zotero.isSafari) {
		var imageBase = safari.extension.baseURI+"images/";
	}
	const nArcs = 20;

	var win = Zotero.isBookmarklet ? window.parent : window,
		doc = Zotero.isBookmarklet ? window.parent.document : window.document,
		container, timeoutID,
		headlineDiv, headlinePreImageTextNode, headlinePostImageTextNode, headlineImage;

	/**
	 * Creates a new object representing a line in the progressWindow.
	 */
	this.ItemProgress = function(iconSrc, title, parentItemProgress) {
		Zotero.ProgressWindow.show();

		this._div = doc.createElement('div');
		this._div.className = "zotero-item-progress";
		this._div.style.cssText = cssDivClearString;
		for(var j in cssItem) this._div.style[j] = cssItem[j];
		//this._div.style.opacity = "0.5";
		//this._div.style.filter = "alpha(opacity = 50)";
		this._div.style.zoom = "1";
		if(parentItemProgress) this._div.style.marginLeft = "12px";

		this._image = doc.createElement('div');
		this._image.style.cssText = cssDivClearString;
		for(var j in cssIcon) this._image.style[j] = cssIcon[j];
		if(parentItemProgress) {
			this._div.zoteroIsChildItem = true;
			this._image.style.left = "18px";
		} else {
			this._image.style.left = "6px";
		}
		this.setIcon(iconSrc);
		this._div.appendChild(this._image);

		this._itemText = doc.createElement('div');
		this._itemText.style.cssText = cssDivClearString;
		for(var j in cssItemText) this._itemText.style[j] = cssItemText[j];
		if(Zotero.isIE) {
			this._itemText.appendChild(doc.createTextNode(title.substr(0, (parentItemProgress ? 30 : 35))+"\u2026"));
		} else {
			this._itemText.style.textOverflow = "ellipsis";
			this._itemText.appendChild(doc.createTextNode(title));
		}
		this._div.appendChild(this._itemText);

		if(parentItemProgress) {
			var nextItem = parentItemProgress._div.nextSibling;
			while(nextItem && nextItem.zoteroIsChildItem) {
				nextItem = nextItem.nextSibling;
			}
			container.insertBefore(this._div, nextItem);
		} else {
			container.appendChild(this._div);
		}
	};

	/**
	 * Sets the current save progress for this item.
	 * @param {Integer} percent A percentage from 0 to 100.
	 */
	this.ItemProgress.prototype.setProgress = function(percent) {
		if(percent != 0 && percent != 100) {
			// Indication of partial progress, so we will use the circular indicator
			this._image.style.backgroundImage = "url('"+imageBase+"progress_arcs.png')";
			this._image.style.backgroundPosition = "-"+(Math.round(percent/100*nArcs)*16)+"px 0";
			this._div.style.opacity = percent/200+.5;
			this._div.style.filter = "alpha(opacity = "+(percent/2+50)+")";
		} else if(percent == 100) {
			this._image.style.backgroundImage = "url('"+this._iconSrc+"')";
			this._image.style.backgroundPosition = "";
			this._div.style.opacity = "1";
			this._div.style.filter = "";
		}
	};

	/**
	 * Sets the icon for this item.
	 * @param {Integer} percent A percentage from 0 to 100.
	 */
	this.ItemProgress.prototype.setIcon = function(iconSrc) {
		this._image.style.backgroundImage = "url('"+iconSrc+"')";
		this._image.style.backgroundPosition = "";
		this._iconSrc = iconSrc;
	};

	/**
	 * Indicates that an error occurred saving this item.
	 */
	this.ItemProgress.prototype.setError = function() {
		this._image.style.backgroundImage = "url('"+imageBase+"cross.png')";
		this._image.style.backgroundPosition = "";
		this._itemText.style.color = "red";
		this._div.style.opacity = "1";
		this._div.style.filter = "";
	};

	this.ErrorMessage = function(err) {
		Zotero.ProgressWindow.show();

		this._div = doc.createElement('div');
		this._div.style.cssText = cssDivClearString;
		for(var j in cssDescription) this._div.style[j] = cssDescription[j];

		if(err === "translationError") {
			// TODO localize
			this._div.appendChild(doc.createTextNode("An error occurred while saving this item. Check "));

			var link = doc.createElement('a');
			link.style.cssText = cssAClearString;
			for(var j in cssDescription) link.style[j] = cssDescription[j];

			link.title = link.href = "http://www.zotero.org/documentation/known_translator_issues";
			// TODO localize
			link.appendChild(doc.createTextNode("Known Translator Issues"));

			this._div.appendChild(link);
			// TODO localize
			this._div.appendChild(doc.createTextNode(" for more information."));
		} else if(err === "noTranslator") {
			var textNode = doc.createTextNode("No items could be saved because this website "+
					"is not supported by any Zotero translator. If Zotero Standalone is not open, try "+
					"opening it to increase the number of supported sites.");
			this._div.appendChild(textNode);
		} else if(err === "standaloneRequired") {
			this._div.appendChild(doc.createTextNode("This item could not be saved because Zotero "+
				"Standalone is not open or unreachable. Please open Zotero Standalone and try again."));
		}

		container.appendChild(this._div);
	};

	/**
	 * Initializes and shows the progress div
	 */
	this.show = function() {
		if(container) return;
		container = doc.createElement('div');
		container.style.cssText = cssDivClearString;
		for(var i in cssBox) container.style[i] = cssBox[i];

		headlineDiv = doc.createElement('div');
		headlineDiv.style.cssText = cssDivClearString;
		for(var i in cssHeadline) headlineDiv.style[i] = cssHeadline[i];

		headlinePreImageTextNode = doc.createTextNode("Initializing...");
		headlineDiv.appendChild(headlinePreImageTextNode);

		headlineImage = doc.createElement("div");
		headlineImage.style.cssText = cssDivClearString;
		for(var j in cssHeadlineIcon) headlineImage.style[j] = cssHeadlineIcon[j];
		headlineDiv.appendChild(headlineImage);

		headlinePostImageTextNode = doc.createTextNode("\u2026");
		headlineDiv.appendChild(headlinePostImageTextNode);

		container.appendChild(headlineDiv);
		doc.body.appendChild(container);
	}

	/**
	 * Changes the headline of the save window
	 */
	this.changeHeadline = function(text, icon, postText) {
		headlinePreImageTextNode.nodeValue = text;
		if(icon) {
			headlineImage.style.display = "inline-block";
			headlineImage.style.backgroundImage = "url('"+imageBase+icon+"')";
		} else {
			headlineImage.style.display = "none";
		}
		if(postText !== undefined) {
			headlinePostImageTextNode.nodeValue = " "+postText;
		}
	}

	/**
	 * Starts the timer to close the progress div
	 */
	this.startCloseTimer = function(delay) {
		if(!container) return;
		if(!delay) delay = 2500;
		if(timeoutID) win.clearTimeout(timeoutID);
		timeoutID = win.setTimeout(Zotero.ProgressWindow.close, delay);
	}

	/**
	 * Closes the progress div
	 */
	this.close = function() {
		if(!container) return;
		doc.body.removeChild(container);
		container = void(0);
		if(timeoutID) win.clearTimeout(timeoutID);
		timeoutID = void(0);
	}
}
/******** END progressWindow.js ********/
/******** BEGIN init.js ********/
/* Set up the environment before loading the rest of the files into Zotero */
var $rdf = {
	Util: {
		ArrayIndexOf: function (arr, item, i) {
			//supported in all browsers except IE<9
			return arr.indexOf(item, i);
		},
		RDFArrayRemove: function (a, x) { //removes all statements equal to x from a
			for (var i = 0; i < a.length; i++) {
				//TODO: This used to be the following, which didnt always work..why
				//if(a[i] == x)
				if (a[i].subject.sameTerm(x.subject) && a[i].predicate.sameTerm(x.predicate) && a[i].object.sameTerm(x.object) && a[i].why.sameTerm(x.why)) {
					a.splice(i, 1);
					return;
				}
			}
			throw "RDFArrayRemove: Array did not contain " + x;
		}
	},
	log: {
		debug: Zotero.debug,
		warn: Zotero.debug,
		error: Zotero.debug
	}
};

if(Zotero.RDF) {
	Zotero.RDF.AJAW = $rdf;
} else {
	Zotero.RDF = {AJAW:$rdf};
}

var tabulator = {log: $rdf.log};
var alert = $rdf.log.warn;

/******** END init.js ********/
/******** BEGIN uri.js ********/
//  Implementing URI-specific functions
//
//	See RFC 2386
//
// This is or was   http://www.w3.org/2005/10/ajaw/uri.js
// 2005 W3C open source licence
//
//
//  Take a URI given in relative or absolute form and a base
//  URI, and return an absolute URI
//
//  See also http://www.w3.org/2000/10/swap/uripath.py
//
if(typeof $rdf.Util.uri == "undefined") {
  $rdf.Util.uri = {};
};

$rdf.Util.uri.join = function (given, base) {
  // if (typeof $rdf.log.debug != 'undefined') $rdf.log.debug("   URI given="+given+" base="+base)
  var baseHash = base.indexOf('#')
  if(baseHash > 0) base = base.slice(0, baseHash)
  if(given.length == 0) return base // before chopping its filename off
  if(given.indexOf('#') == 0) return base + given
  var colon = given.indexOf(':')
  if(colon >= 0) return given // Absolute URI form overrides base URI
  var baseColon = base.indexOf(':')
  if(base == "") return given;
  if(baseColon < 0) {
    alert("Invalid base: " + base + ' in join with ' + given);
    return given
  }
  var baseScheme = base.slice(0, baseColon + 1) // eg http:
  if(given.indexOf("//") == 0) // Starts with //
  return baseScheme + given;
  if(base.indexOf('//', baseColon) == baseColon + 1) { // Any hostpart?
    var baseSingle = base.indexOf("/", baseColon + 3)
    if(baseSingle < 0) {
      if(base.length - baseColon - 3 > 0) {
        return base + "/" + given
      } else {
        return baseScheme + given
      }
    }
  } else {
    var baseSingle = base.indexOf("/", baseColon + 1)
    if(baseSingle < 0) {
      if(base.length - baseColon - 1 > 0) {
        return base + "/" + given
      } else {
        return baseScheme + given
      }
    }
  }

  if(given.indexOf('/') == 0) // starts with / but not //
  return base.slice(0, baseSingle) + given

  var path = base.slice(baseSingle)
  var lastSlash = path.lastIndexOf("/")
  if(lastSlash < 0) return baseScheme + given
  if((lastSlash >= 0)
    && (lastSlash < (path.length - 1)))
    path = path.slice(0, lastSlash + 1) // Chop trailing filename from base
  path = path + given
  while(path.match(/[^\/]*\/\.\.\//)) // must apply to result of prev
  path = path.replace(/[^\/]*\/\.\.\//, '') // ECMAscript spec 7.8.5
  path = path.replace(/\.\//g, '') // spec vague on escaping
  path = path.replace(/\/\.$/, '/')
  return base.slice(0, baseSingle) + path
}

if(typeof tabulator != 'undefined' && tabulator.isExtension) {
  $rdf.Util.uri.join2 = function (given, base) {
    var tIOService = Components.classes['@mozilla.org/network/io-service;1']
      .getService(Components.interfaces.nsIIOService);

    var baseURI = tIOService.newURI(base, null, null);
    return tIOService.newURI(baseURI.resolve(given), null, null).spec;
  }
} else
  $rdf.Util.uri.join2 = $rdf.Util.uri.join;

//  refTo:    Make a URI relative to a given base
//
// based on code in http://www.w3.org/2000/10/swap/uripath.py
//
$rdf.Util.uri.commonHost = new RegExp("^[-_a-zA-Z0-9.]+:(//[^/]*)?/[^/]*$");

$rdf.Util.uri.hostpart = function (u) {
  var m = /[^\/]*\/\/([^\/]*)\//.exec(u);
  return m ? m[1] : ''
};

$rdf.Util.uri.refTo = function (base, uri) {
  if(!base) return uri;
  if(base == uri) return "";
  var i = 0; // How much are they identical?
  while(i < uri.length && i < base.length)
  if(uri[i] == base[i]) i++;
  else break;
  if(base.slice(0, i).match($rdf.Util.uri.commonHost)) {
    var k = uri.indexOf('//');
    if(k < 0) k = -2; // no host
    var l = uri.indexOf('/', k + 2); // First *single* slash
    if(uri.slice(l + 1, l + 2) != '/'
      && base.slice(l + 1, l + 2) != '/'
      && uri.slice(0, l) == base.slice(0, l))
      // common path to single slash
      return uri.slice(l); // but no other common path segments
  }
  // fragment of base?
  if(uri.slice(i, i + 1) == '#' && base.length == i) return uri.slice(i);
  while(i > 0 && uri[i - 1] != '/') i--;

  if(i < 3) return uri; // No way
  if((base.indexOf('//', i - 2) > 0)
    || uri.indexOf('//', i - 2) > 0)
    return uri; // an unshared '//'
  if(base.indexOf(':', i) > 0) return uri; // unshared ':'
  var n = 0;
  for(var j = i; j < base.length; j++) if(base[j] == '/') n++;
  if(n == 0 && i < uri.length && uri[i] == '#') return './' + uri.slice(i);
  if(n == 0 && i == uri.length) return './';
  var str = '';
  for(var j = 0; j < n; j++) str += '../';
  return str + uri.slice(i);
}


/** returns URI without the frag **/
$rdf.Util.uri.docpart = function (uri) {
  var i = uri.indexOf("#")
  if(i < 0) return uri
  return uri.slice(0, i)
}

/** The document in which something a thing defined  **/
$rdf.Util.uri.document = function (x) {
  return $rdf.sym($rdf.Util.uri.docpart(x.uri));
}

/** return the protocol of a uri **/
/** return null if there isn't one **/
$rdf.Util.uri.protocol = function (uri) {
  var index = uri.indexOf(':');
  if(index >= 0) return uri.slice(0, index);
  else return null;
} //protocol
//ends
/******** END uri.js ********/
/******** BEGIN term.js ********/
// These are the classes corresponding to the RDF and N3 data models
//
// Designed to look like rdflib and cwm designs.
//
// Issues: Should the names start with RDF to make them
//      unique as program-wide symbols?
//
// W3C open source licence 2005.
//
//	Symbol
$rdf.Empty = function () {
  return this;
};

$rdf.Empty.prototype.termType = 'empty';
$rdf.Empty.prototype.toString = function () {
  return "()"
};
$rdf.Empty.prototype.toNT = $rdf.Empty.prototype.toString;

$rdf.Symbol = function (uri) {
  this.uri = uri;
  this.value = uri; // -- why? -tim
  return this;
}

$rdf.Symbol.prototype.termType = 'symbol';
$rdf.Symbol.prototype.toString = function () {
  return("<" + this.uri + ">");
};
$rdf.Symbol.prototype.toNT = $rdf.Symbol.prototype.toString;

//  Some precalculated symbols
$rdf.Symbol.prototype.XSDboolean = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#boolean');
$rdf.Symbol.prototype.XSDdecimal = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#decimal');
$rdf.Symbol.prototype.XSDfloat = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#float');
$rdf.Symbol.prototype.XSDinteger = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#integer');
$rdf.Symbol.prototype.XSDdateTime = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#dateTime');
$rdf.Symbol.prototype.integer = new $rdf.Symbol('http://www.w3.org/2001/XMLSchema#integer'); // Used?
//	Blank Node
if(typeof $rdf.NextId != 'undefined') {
  $rdf.log.error('Attempt to re-zero existing blank node id counter at ' + $rdf.NextId);
} else {
  $rdf.NextId = 0; // Global genid
}
$rdf.NTAnonymousNodePrefix = "_:n";

$rdf.BlankNode = function (id) {
  /*if (id)
    	this.id = id;
    else*/
  this.id = $rdf.NextId++;
  this.value = id ? id : this.id.toString();
  return this
};

$rdf.BlankNode.prototype.termType = 'bnode';
$rdf.BlankNode.prototype.toNT = function () {
  return $rdf.NTAnonymousNodePrefix + this.id
};
$rdf.BlankNode.prototype.toString = $rdf.BlankNode.prototype.toNT;

//	Literal
$rdf.Literal = function (value, lang, datatype) {
  this.value = value
  if(lang == "" || lang == null) this.lang = undefined;
  else this.lang = lang; // string
  if(datatype == null) this.datatype = undefined;
  else this.datatype = datatype; // term
  return this;
}

$rdf.Literal.prototype.termType = 'literal'
$rdf.Literal.prototype.toString = function () {
  return '' + this.value;
};
$rdf.Literal.prototype.toNT = function () {
  var str = this.value
  if(typeof str != 'string') {
    if(typeof str == 'number') return '' + str;
    throw Error("Value of RDF literal is not string: " + str)
  }
  str = str.replace(/\\/g, '\\\\'); // escape backslashes
  str = str.replace(/\"/g, '\\"'); // escape quotes
  str = str.replace(/\n/g, '\\n'); // escape newlines
  str = '"' + str + '"' //';
  if(this.datatype) {
    str = str + '^^' + this.datatype.toNT()
  }
  if(this.lang) {
    str = str + "@" + this.lang;
  }
  return str;
};

$rdf.Collection = function () {
  this.id = $rdf.NextId++; // Why need an id? For hashstring.
  this.elements = [];
  this.closed = false;
};

$rdf.Collection.prototype.termType = 'collection';

$rdf.Collection.prototype.toNT = function () {
  return $rdf.NTAnonymousNodePrefix + this.id
};

$rdf.Collection.prototype.toString = function () {
  var str = '(';
  for(var i = 0; i < this.elements.length; i++)
  str += this.elements[i] + ' ';
  return str + ')';
};

$rdf.Collection.prototype.append = function (el) {
  this.elements.push(el)
}
$rdf.Collection.prototype.unshift = function (el) {
  this.elements.unshift(el);
}
$rdf.Collection.prototype.shift = function () {
  return this.elements.shift();
}

$rdf.Collection.prototype.close = function () {
  this.closed = true
}


//      Convert Javascript representation to RDF term object
//
$rdf.term = function (val) {
  if(typeof val == 'object')
    if(val instanceof Date) {
      var d2 = function (x) {
          return('' + (100 + x)).slice(1, 3)
        }; // format as just two digits
      return new $rdf.Literal('' + val.getUTCFullYear() + '-' + d2(val.getUTCMonth() + 1)
          + '-' + d2(val.getUTCDate()) + 'T' + d2(val.getUTCHours()) + ':'
          + d2(val.getUTCMinutes()) + ':' + d2(val.getUTCSeconds()) + 'Z',
        undefined,
        $rdf.Symbol.prototype.XSDdateTime);

    } else if(val instanceof Array) {
      var x = new $rdf.Collection();
      for(var i = 0; i < val.length; i++)
        x.append($rdf.term(val[i]));
      return x;
    } else
      return val;
  if(typeof val == 'string')
    return new $rdf.Literal(val);
  if(typeof val == 'number') {
    var dt;
    if(('' + val).indexOf('e') >= 0) dt = $rdf.Symbol.prototype.XSDfloat;
    else if(('' + val).indexOf('.') >= 0) dt = $rdf.Symbol.prototype.XSDdecimal;
    else dt = $rdf.Symbol.prototype.XSDinteger;
    return new $rdf.Literal(val, undefined, dt);
  }
  if(typeof val == 'boolean')
    return new $rdf.Literal(val ? "1" : "0", undefined, $rdf.Symbol.prototype.XSDboolean);
  if(typeof val == 'undefined')
    return undefined;
  throw("Can't make term from " + val + " of type " + typeof val);
}

//	Statement
//
//  This is a triple with an optional reason.
//
//   The reason can point to provenece or inference
//
$rdf.Statement = function (subject, predicate, object, why) {
  this.subject = $rdf.term(subject)
  this.predicate = $rdf.term(predicate)
  this.object = $rdf.term(object)
  if(typeof why != 'undefined') {
    this.why = why;
  }
  return this;
}

$rdf.st = function (subject, predicate, object, why) {
  return new $rdf.Statement(subject, predicate, object, why);
};

$rdf.Statement.prototype.toNT = function () {
  return (this.subject.toNT() + " " + this.predicate.toNT() + " " + this.object.toNT() + " .");
};

$rdf.Statement.prototype.toString = $rdf.Statement.prototype.toNT;

//	Formula
//
//	Set of statements.
$rdf.Formula = function () {
  this.statements = []
  this.constraints = []
  this.initBindings = []
  this.optional = []
  return this;
};


$rdf.Formula.prototype.termType = 'formula';
$rdf.Formula.prototype.toNT = function () {
  return "{" + this.statements.join('\n') + "}"
};
$rdf.Formula.prototype.toString = $rdf.Formula.prototype.toNT;

$rdf.Formula.prototype.add = function (subj, pred, obj, why) {
  this.statements.push(new $rdf.Statement(subj, pred, obj, why))
}

// Convenience methods on a formula allow the creation of new RDF terms:
$rdf.Formula.prototype.sym = function (uri, name) {
  if(name != null) {
    throw "This feature (kb.sym with 2 args) is removed. Do not assume prefix mappings."
    if(!$rdf.ns[uri]) throw 'The prefix "' + uri + '" is not set in the API';
    uri = $rdf.ns[uri] + name
  }
  return new $rdf.Symbol(uri)
}

$rdf.sym = function (uri) {
  return new $rdf.Symbol(uri);
};

$rdf.Formula.prototype.literal = function (val, lang, dt) {
  return new $rdf.Literal(val.toString(), lang, dt)
}
$rdf.lit = $rdf.Formula.prototype.literal;

$rdf.Formula.prototype.bnode = function (id) {
  return new $rdf.BlankNode(id)
}

$rdf.Formula.prototype.formula = function () {
  return new $rdf.Formula()
}

$rdf.Formula.prototype.collection = function () { // obsolete
  return new $rdf.Collection()
}

$rdf.Formula.prototype.list = function (values) {
  var li = new $rdf.Collection();
  if(values) {
    for(var i = 0; i < values.length; i++) {
      li.append(values[i]);
    }
  }
  return li;
}

/*  Variable
 **
 ** Variables are placeholders used in patterns to be matched.
 ** In cwm they are symbols which are the formula's list of quantified variables.
 ** In sparl they are not visibily URIs.  Here we compromise, by having
 ** a common special base URI for variables. Their names are uris,
 ** but the ? nottaion has an implicit base uri of 'varid:'
 */

$rdf.Variable = function (rel) {
  this.base = "varid:"; // We deem variabe x to be the symbol varid:x
  this.uri = $rdf.Util.uri.join(rel, this.base);
  return this;
}

$rdf.Variable.prototype.termType = 'variable';
$rdf.Variable.prototype.toNT = function () {
  if(this.uri.slice(0, this.base.length) == this.base) {
    return '?' + this.uri.slice(this.base.length);
  } // @@ poor man's refTo
  return '?' + this.uri;
};

$rdf.Variable.prototype.toString = $rdf.Variable.prototype.toNT;
$rdf.Variable.prototype.classOrder = 7;

$rdf.variable = $rdf.Formula.prototype.variable = function (name) {
  return new $rdf.Variable(name);
};

$rdf.Variable.prototype.hashString = $rdf.Variable.prototype.toNT;


// The namespace function generator
$rdf.Namespace = function (nsuri) {
  return function (ln) {
    return new $rdf.Symbol(nsuri + (ln === undefined ? '' : ln))
  }
}

$rdf.Formula.prototype.ns = function (nsuri) {
  return function (ln) {
    return new $rdf.Symbol(nsuri + (ln === undefined ? '' : ln))
  }
}


// Parse a single token
//
// The bnode bit should not be used on program-external values; designed
// for internal work such as storing a bnode id in an HTML attribute.
// This will only parse the strings generated by the vaious toNT() methods.
$rdf.Formula.prototype.fromNT = function (str) {
  var len = str.length
  var ch = str.slice(0, 1)
  if(ch == '<') return $rdf.sym(str.slice(1, len - 1))
  if(ch == '"') {
    var lang = undefined;
    var dt = undefined;
    var k = str.lastIndexOf('"');
    if(k < len - 1) {
      if(str[k + 1] == '@') lang = str.slice(k + 2, len);
      else if(str.slice(k + 1, k + 3) == '^^') dt = $rdf.fromNT(str.slice(k + 3, len));
      else throw "Can't convert string from NT: " + str
    }
    var str = (str.slice(1, k));
    str = str.replace(/\\"/g, '"'); // unescape quotes '
    str = str.replace(/\\n/g, '\n'); // unescape newlines
    str = str.replace(/\\\\/g, '\\'); // unescape backslashes
    return $rdf.lit(str, lang, dt);
  }
  if(ch == '_') {
    var x = new $rdf.BlankNode();
    x.id = parseInt(str.slice(3));
    $rdf.NextId--
    return x
  }
  if(ch == '?') {
    var x = new $rdf.Variable(str.slice(1));
    return x;
  }
  throw "Can't convert from NT: " + str;

}
$rdf.fromNT = $rdf.Formula.prototype.fromNT; // Not for inexpert user
// Convenience - and more conventional name:
$rdf.graph = function () {
  return new $rdf.IndexedFormula();
};

// ends
/******** END term.js ********/
/******** BEGIN identity.js ********/
//  Identity management and indexing for RDF
//
// This file provides  IndexedFormula a formula (set of triples) which
// indexed by predicate, subject and object.
//
// It "smushes"  (merges into a single node) things which are identical
// according to owl:sameAs or an owl:InverseFunctionalProperty
// or an owl:FunctionalProperty
//
//
//  2005-10 Written Tim Berners-Lee
//  2007    Changed so as not to munge statements from documents when smushing
//
//
/*jsl:option explicit*/
// Turn on JavaScriptLint variable declaration checking
$rdf.IndexedFormula = function () {

  var owl_ns = "http://www.w3.org/2002/07/owl#";
  // var link_ns = "http://www.w3.org/2007/ont/link#";
  /* hashString functions are used as array indeces. This is done to avoid
   ** conflict with existing properties of arrays such as length and map.
   ** See issue 139.
   */
  $rdf.Literal.prototype.hashString = $rdf.Literal.prototype.toNT;
  $rdf.Symbol.prototype.hashString = $rdf.Symbol.prototype.toNT;
  $rdf.BlankNode.prototype.hashString = $rdf.BlankNode.prototype.toNT;
  $rdf.Collection.prototype.hashString = $rdf.Collection.prototype.toNT;


  //Stores an associative array that maps URIs to functions
  $rdf.IndexedFormula = function (features) {
    this.statements = []; // As in Formula
    this.optional = [];
    this.propertyActions = []; // Array of functions to call when getting statement with {s X o}
    //maps <uri> to [f(F,s,p,o),...]
    this.classActions = []; // Array of functions to call when adding { s type X }
    this.redirections = []; // redirect to lexically smaller equivalent symbol
    this.aliases = []; // reverse mapping to redirection: aliases for this
    this.HTTPRedirects = []; // redirections we got from HTTP
    this.subjectIndex = []; // Array of statements with this X as subject
    this.predicateIndex = []; // Array of statements with this X as subject
    this.objectIndex = []; // Array of statements with this X as object
    this.whyIndex = []; // Array of statements with X as provenance
    this.index = [this.subjectIndex, this.predicateIndex, this.objectIndex, this.whyIndex];
    this.namespaces = {} // Dictionary of namespace prefixes
    if(features === undefined) features = ["sameAs",
                                "InverseFunctionalProperty", "FunctionalProperty"];
    //    this.features = features
    // Callbackify?
    function handleRDFType(formula, subj, pred, obj, why) {
      if(formula.typeCallback != undefined)
        formula.typeCallback(formula, obj, why);

      var x = formula.classActions[obj.hashString()];
      var done = false;
      if(x) {
        for(var i = 0; i < x.length; i++) {
          done = done || x[i](formula, subj, pred, obj, why);
        }
      }
      return done; // statement given is not needed if true
    } //handleRDFType
    //If the predicate is #type, use handleRDFType to create a typeCallback on the object
    this.propertyActions['<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>'] = [handleRDFType];

    // Assumption: these terms are not redirected @@fixme
    if($rdf.Util.ArrayIndexOf(features, "sameAs") >= 0)
      this.propertyActions['<http://www.w3.org/2002/07/owl#sameAs>'] = [
      function (formula, subj, pred, obj, why) {
      // tabulator.log.warn("Equating "+subj.uri+" sameAs "+obj.uri);  //@@
      formula.equate(subj, obj);
      return true; // true if statement given is NOT needed in the store
    }]; //sameAs -> equate & don't add to index
    if($rdf.Util.ArrayIndexOf(features, "InverseFunctionalProperty") >= 0)
      this.classActions["<" + owl_ns + "InverseFunctionalProperty>"] = [
      function (formula, subj, pred, obj, addFn) {
      return formula.newPropertyAction(subj, handle_IFP); // yes subj not pred!
    }]; //IFP -> handle_IFP, do add to index
    if($rdf.Util.ArrayIndexOf(features, "FunctionalProperty") >= 0)
      this.classActions["<" + owl_ns + "FunctionalProperty>"] = [
        function (formula, subj, proj, obj, addFn) {
         return formula.newPropertyAction(subj, handle_FP);
        }
      ]; //FP => handleFP, do add to index
    function handle_IFP(formula, subj, pred, obj) {
      var s1 = formula.any(undefined, pred, obj);
      if(s1 == undefined) return false; // First time with this value
      // tabulator.log.warn("Equating "+s1.uri+" and "+subj.uri + " because IFP "+pred.uri);  //@@
      formula.equate(s1, subj);
      return true;
    } //handle_IFP
    function handle_FP(formula, subj, pred, obj) {
      var o1 = formula.any(subj, pred, undefined);
      if(o1 == undefined) return false; // First time with this value
      // tabulator.log.warn("Equating "+o1.uri+" and "+obj.uri + " because FP "+pred.uri);  //@@
      formula.equate(o1, obj);
      return true;
    } //handle_FP
  } /* end IndexedFormula */

  $rdf.IndexedFormula.prototype = new $rdf.Formula();
  $rdf.IndexedFormula.prototype.constructor = $rdf.IndexedFormula;
  $rdf.IndexedFormula.SuperClass = $rdf.Formula;

  $rdf.IndexedFormula.prototype.newPropertyAction = function newPropertyAction(pred, action) {
    //$rdf.log.debug("newPropertyAction:  "+pred);
    var hash = pred.hashString();
    if(this.propertyActions[hash] == undefined)
      this.propertyActions[hash] = [];
    this.propertyActions[hash].push(action);
    // Now apply the function to to statements already in the store
    var toBeFixed = this.statementsMatching(undefined, pred, undefined);
    var done = false;
    for(var i = 0; i < toBeFixed.length; i++) { // NOT optimized - sort toBeFixed etc
      done = done || action(this, toBeFixed[i].subject, pred, toBeFixed[i].object);
    }
    return done;
  }

  $rdf.IndexedFormula.prototype.setPrefixForURI = function (prefix, nsuri) {
    //TODO:This is a hack for our own issues, which ought to be fixed post-release
    //See http://dig.csail.mit.edu/cgi-bin/roundup.cgi/$rdf/issue227
    if(prefix == "tab" && this.namespaces["tab"]) {
      return;
    }
    this.namespaces[prefix] = nsuri
  }

  // Deprocated ... name too generic
  $rdf.IndexedFormula.prototype.register = function (prefix, nsuri) {
    this.namespaces[prefix] = nsuri
  }


  /** simplify graph in store when we realize two identifiers are equivalent

We replace the bigger with the smaller.

*/
  $rdf.IndexedFormula.prototype.equate = function (u1, u2) {
    // tabulator.log.warn("Equating "+u1+" and "+u2); // @@
    //@@JAMBO Must canonicalize the uris to prevent errors from a=b=c
    //03-21-2010
    u1 = this.canon(u1);
    u2 = this.canon(u2);
    var d = u1.compareTerm(u2);
    if(!d) return true; // No information in {a = a}
    var big, small;
    if(d < 0) { // u1 less than u2
      return this.replaceWith(u2, u1);
    } else {
      return this.replaceWith(u1, u2);
    }
  }

  // Replace big with small, obsoleted with obsoleting.
  //
  $rdf.IndexedFormula.prototype.replaceWith = function (big, small) {
    //$rdf.log.debug("Replacing "+big+" with "+small) // @@
    var oldhash = big.hashString();
    var newhash = small.hashString();

    var moveIndex = function (ix) {
        var oldlist = ix[oldhash];
        if(oldlist == undefined) return; // none to move
        var newlist = ix[newhash];
        if(newlist == undefined) {
          ix[newhash] = oldlist;
        } else {
          ix[newhash] = oldlist.concat(newlist);
        }
        delete ix[oldhash];
      }

      // the canonical one carries all the indexes
    for(var i = 0; i < 4; i++) {
      moveIndex(this.index[i]);
    }

    this.redirections[oldhash] = small;
    if(big.uri) {
      //@@JAMBO: must update redirections,aliases from sub-items, too.
      if(this.aliases[newhash] == undefined)
        this.aliases[newhash] = [];
      this.aliases[newhash].push(big); // Back link
      if(this.aliases[oldhash]) {
        for(var i = 0; i < this.aliases[oldhash].length; i++) {
          this.redirections[this.aliases[oldhash][i].hashString()] = small;
          this.aliases[newhash].push(this.aliases[oldhash][i]);
        }
      }

      //this.add(small, this.sym('http://www.w3.org/2007/ont/link#uri'), big.uri)

      // If two things are equal, and one is requested, we should request the other.
      if(this.sf) {
        this.sf.nowKnownAs(big, small)
      }
    }

    moveIndex(this.classActions);
    moveIndex(this.propertyActions);

    $rdf.log.debug("Equate done. "+big+" now links to "+small)
    return true; // true means the statement does not need to be put in
  };

  // Return the symbol with canonical URI as smushed
  $rdf.IndexedFormula.prototype.canon = function (term) {
    if(term == undefined) return term;
    var y = this.redirections[term.hashString()];
    if(y == undefined) return term;
    return y;
  }

  // Compare by canonical URI as smushed
  $rdf.IndexedFormula.prototype.sameThings = function (x, y) {
    if(x.sameTerm(y)) return true;
    var x1 = this.canon(x);
    //    alert('x1='+x1);
    if(x1 == undefined) return false;
    var y1 = this.canon(y);
    //    alert('y1='+y1); //@@
    if(y1 == undefined) return false;
    return(x1.uri == y1.uri);
  }

  // A list of all the URIs by which this thing is known
  $rdf.IndexedFormula.prototype.uris = function (term) {
    var cterm = this.canon(term)
    var terms = this.aliases[cterm.hashString()];
    if(!cterm.uri) return []
    var res = [cterm.uri]
    if(terms != undefined) {
      for(var i = 0; i < terms.length; i++) {
        res.push(terms[i].uri)
      }
    }
    return res
  }

  // On input parameters, convert constants to terms
  //
  function RDFMakeTerm(formula, val, canonicalize) {
    if(typeof val != 'object') {
      if(typeof val == 'string')
        return new $rdf.Literal(val);
      if(typeof val == 'number')
        return new $rdf.Literal(val); // @@ differet types
      if(typeof val == 'boolean')
        return new $rdf.Literal(val ? "1" : "0", undefined, $rdf.Symbol.prototype.XSDboolean);
      if(typeof val == 'undefined')
        return undefined;
      else // @@ add converting of dates and numbers
      throw "Can't make Term from " + val + " of type " + typeof val;
    }
    return val;
  }

  // Add a triple to the store
  //
  //  Returns the statement added
  // (would it be better to return the original formula for chaining?)
  //
  $rdf.IndexedFormula.prototype.add = function (subj, pred, obj, why) {
    var actions, st;
    if(why == undefined) why = this.fetcher ? this.fetcher.appNode : this.sym("chrome:theSession"); //system generated
    //defined in source.js, is this OK with identity.js only user?
    subj = RDFMakeTerm(this, subj);
    pred = RDFMakeTerm(this, pred);
    obj = RDFMakeTerm(this, obj);
    why = RDFMakeTerm(this, why);

    if(this.predicateCallback != undefined)
      this.predicateCallback(this, pred, why);

    // Action return true if the statement does not need to be added
    var actions = this.propertyActions[this.canon(pred).hashString()];
    var done = false;
    if(actions) {
      // alert('type: '+typeof actions +' @@ actions='+actions);
      for(var i = 0; i < actions.length; i++) {
        done = done || actions[i](this, subj, pred, obj, why);
      }
    }

    //If we are tracking provenanance, every thing should be loaded into the store
    //if (done) return new Statement(subj, pred, obj, why); // Don't put it in the store
    // still return this statement for owl:sameAs input
    var hash = [this.canon(subj).hashString(), this.canon(pred).hashString(),
                   this.canon(obj).hashString(), this.canon(why).hashString()];
    var st = new $rdf.Statement(subj, pred, obj, why);
    for(var i = 0; i < 4; i++) {
      var ix = this.index[i];
      var h = hash[i];
      if(ix[h] == undefined) ix[h] = [];
      ix[h].push(st); // Set of things with this as subject, etc
    }

    //tabulator.log.debug("ADDING    {"+subj+" "+pred+" "+obj+"} "+why);
    this.statements.push(st);
    return st;
  }; //add
  // Find out whether a given URI is used as symbol in the formula
  $rdf.IndexedFormula.prototype.mentionsURI = function (uri) {
    var hash = '<' + uri + '>';
    return (!!this.subjectIndex[hash]
      || !!this.objectIndex[hash]
      || !!this.predicateIndex[hash]);
  }

  // Find an unused id for a file being edited: return a symbol
  // (Note: Slow iff a lot of them -- could be O(log(k)) )
  $rdf.IndexedFormula.prototype.nextSymbol = function (doc) {
    for(var i = 0;; i++) {
      var uri = doc.uri + '#n' + i;
      if(!this.mentionsURI(uri)) return this.sym(uri);
    }
  }


  $rdf.IndexedFormula.prototype.anyStatementMatching = function (subj, pred, obj, why) {
    var x = this.statementsMatching(subj, pred, obj, why, true);
    if(!x || x == []) return undefined;
    return x[0];
  };


  // Return statements matching a pattern
  // ALL CONVENIENCE LOOKUP FUNCTIONS RELY ON THIS!
  $rdf.IndexedFormula.prototype.statementsMatching = function (subj, pred, obj, why, justOne) {
    //$rdf.log.debug("Matching {"+subj+" "+pred+" "+obj+"}");
    var pat = [subj, pred, obj, why];
    var pattern = [];
    var hash = [];
    var wild = []; // wildcards
    var given = []; // Not wild
    for(var p = 0; p < 4; p++) {
      pattern[p] = this.canon(RDFMakeTerm(this, pat[p]));
      if(pattern[p] == undefined) {
        wild.push(p);
      } else {
        given.push(p);
        hash[p] = pattern[p].hashString();
      }
    }
    if(given.length == 0) {
      return this.statements;
    }
    if(given.length == 1) { // Easy too, we have an index for that
      var p = given[0];
      var list = this.index[p][hash[p]];
      if(list && justOne) {
        if(list.length > 1)
          list = list.slice(0, 1);
      }
      return list == undefined ? [] : list;
    }

    // Now given.length is 2, 3 or 4.
    // We hope that the scale-free nature of the data will mean we tend to get
    // a short index in there somewhere!
    var best = 1e10; // really bad
    var best_i;
    for(var i = 0; i < given.length; i++) {
      var p = given[i]; // Which part we are dealing with
      var list = this.index[p][hash[p]];
      if(list == undefined) return []; // No occurrences
      if(list.length < best) {
        best = list.length;
        best_i = i; // (not p!)
      }
    }

    // Ok, we have picked the shortest index but now we have to filter it
    var best_p = given[best_i];
    var possibles = this.index[best_p][hash[best_p]];
    var check = given.slice(0, best_i).concat(given.slice(best_i + 1)) // remove best_i
    var results = [];
    var parts = ['subject', 'predicate', 'object', 'why'];
    for(var j = 0; j < possibles.length; j++) {
      var st = possibles[j];
      for(var i = 0; i < check.length; i++) { // for each position to be checked
        var p = check[i];
        if(!this.canon(st[parts[p]]).sameTerm(pattern[p])) {
          st = null;
          break;
        }
      }
      if(st != null) {
        results.push(st);
        if(justOne)
          break;
      }
    }
    return results;
  }; // statementsMatching
  /** remove a particular statement from the bank **/
  $rdf.IndexedFormula.prototype.remove = function (st) {
    //$rdf.log.debug("entering remove w/ st=" + st);
    var term = [st.subject, st.predicate, st.object, st.why];
    for(var p = 0; p < 4; p++) {
      var c = this.canon(term[p]);
      var h = c.hashString();
      if(this.index[p][h] == undefined) {
        //$rdf.log.warn ("Statement removal: no index '+p+': "+st);
      } else {
        $rdf.Util.RDFArrayRemove(this.index[p][h], st);
      }
    }
    $rdf.Util.RDFArrayRemove(this.statements, st);
  }; //remove
  /** remove all statements matching args (within limit) **/
  $rdf.IndexedFormula.prototype.removeMany = function (subj, pred, obj, why, limit) {
    //$rdf.log.debug("entering removeMany w/ subj,pred,obj,why,limit = " + subj +", "+ pred+", " + obj+", " + why+", " + limit);
    var sts = this.statementsMatching(subj, pred, obj, why, false);
    //This is a subtle bug that occcured in updateCenter.js too.
    //The fact is, this.statementsMatching returns this.whyIndex instead of a copy of it
    //but for perfromance consideration, it's better to just do that
    //so make a copy here.
    var statements = [];
    for(var i = 0; i < sts.length; i++) statements.push(sts[i]);
    if(limit) statements = statements.slice(0, limit);
    for(var i = 0; i < statements.length; i++) this.remove(statements[i]);
  }; //removeMany
  /** Utility**/

  /*  @method: copyTo
    @description: replace @template with @target and add appropriate triples (no triple removed)
                  one-direction replication
*/
  $rdf.IndexedFormula.prototype.copyTo = function (template, target, flags) {
    if(!flags) flags = [];
    var statList = this.statementsMatching(template);
    if($rdf.Util.ArrayIndexOf(flags, 'two-direction') != -1)
      statList.concat(this.statementsMatching(undefined, undefined, template));
    for(var i = 0; i < statList.length; i++) {
      var st = statList[i];
      switch(st.object.termType) {
      case 'symbol':
        this.add(target, st.predicate, st.object);
        break;
      case 'literal':
      case 'bnode':
      case 'collection':
        this.add(target, st.predicate, st.object.copy(this));
      }
      if($rdf.Util.ArrayIndexOf(flags, 'delete') != -1) this.remove(st);
    }
  };
  //for the case when you alter this.value (text modified in userinput.js)
  $rdf.Literal.prototype.copy = function () {
    return new $rdf.Literal(this.value, this.lang, this.datatype);
  };
  $rdf.BlankNode.prototype.copy = function (formula) { //depends on the formula
    var bnodeNew = new $rdf.BlankNode();
    formula.copyTo(this, bnodeNew);
    return bnodeNew;
  }
  /**  Full N3 bits  -- placeholders only to allow parsing, no functionality! **/

  $rdf.IndexedFormula.prototype.newUniversal = function (uri) {
    var x = this.sym(uri);
    if(!this._universalVariables) this._universalVariables = [];
    this._universalVariables.push(x);
    return x;
  }

  $rdf.IndexedFormula.prototype.newExistential = function (uri) {
    if(!uri) return this.bnode();
    var x = this.sym(uri);
    return this.declareExistential(x);
  }

  $rdf.IndexedFormula.prototype.declareExistential = function (x) {
    if(!this._existentialVariables) this._existentialVariables = [];
    this._existentialVariables.push(x);
    return x;
  }

  $rdf.IndexedFormula.prototype.formula = function (features) {
    return new $rdf.IndexedFormula(features);
  }

  $rdf.IndexedFormula.prototype.close = function () {
    return this;
  }

  $rdf.IndexedFormula.prototype.hashString = $rdf.IndexedFormula.prototype.toNT;

  return $rdf.IndexedFormula;

}();
// ends
/******** END identity.js ********/
/******** BEGIN match.js ********/
// Matching a statement against a formula
//
//
// W3C open source licence 2005.
//
// We retpresent a set as an associative array whose value for
// each member is set to true.
$rdf.Symbol.prototype.sameTerm = function (other) {
  if(!other) {
    return false
  }
  return((this.termType == other.termType) && (this.uri == other.uri))
}

$rdf.BlankNode.prototype.sameTerm = function (other) {
  if(!other) {
    return false
  }
  return((this.termType == other.termType) && (this.id == other.id))
}

$rdf.Literal.prototype.sameTerm = function (other) {
  if(!other) {
    return false
  }
  return((this.termType == other.termType)
    && (this.value == other.value)
    && (this.lang == other.lang)
    && ((!this.datatype && !other.datatype)
      || (this.datatype && this.datatype.sameTerm(other.datatype))))
}

$rdf.Variable.prototype.sameTerm = function (other) {
  if(!other) {
    return false
  }
  return((this.termType == other.termType) && (this.uri == other.uri))
}

$rdf.Collection.prototype.sameTerm = $rdf.BlankNode.prototype.sameTerm

$rdf.Formula.prototype.sameTerm = function (other) {
  return this.hashString() == other.hashString();
}
//  Comparison for ordering
//
// These compare with ANY term
//
//
// When we smush nodes we take the lowest value. This is not
// arbitrary: we want the value actually used to be the literal
// (or list or formula).
$rdf.Literal.prototype.classOrder = 1
$rdf.Collection.prototype.classOrder = 3
$rdf.Formula.prototype.classOrder = 4
$rdf.Symbol.prototype.classOrder = 5
$rdf.BlankNode.prototype.classOrder = 6

//  Compaisons return  sign(self - other)
//  Literals must come out before terms for smushing
$rdf.Literal.prototype.compareTerm = function (other) {
  if(this.classOrder < other.classOrder) return -1
  if(this.classOrder > other.classOrder) return +1
  if(this.value < other.value) return -1
  if(this.value > other.value) return +1
  return 0
}

$rdf.Symbol.prototype.compareTerm = function (other) {
  if(this.classOrder < other.classOrder) return -1
  if(this.classOrder > other.classOrder) return +1
  if(this.uri < other.uri) return -1
  if(this.uri > other.uri) return +1
  return 0
}

$rdf.BlankNode.prototype.compareTerm = function (other) {
  if(this.classOrder < other.classOrder) return -1
  if(this.classOrder > other.classOrder) return +1
  if(this.id < other.id) return -1
  if(this.id > other.id) return +1
  return 0
}

$rdf.Collection.prototype.compareTerm = $rdf.BlankNode.prototype.compareTerm

//  Convenience routines
// Only one of s p o can be undefined, and w is optional.
$rdf.Formula.prototype.each = function (s, p, o, w) {
  var results = []
  var st, sts = this.statementsMatching(s, p, o, w, false)
  var i, n = sts.length
  if(typeof s == 'undefined') {
    for(i = 0; i < n; i++) {
      st = sts[i];
      results.push(st.subject)
    }
  } else if(typeof p == 'undefined') {
    for(i = 0; i < n; i++) {
      st = sts[i];
      results.push(st.predicate)
    }
  } else if(typeof o == 'undefined') {
    for(i = 0; i < n; i++) {
      st = sts[i];
      results.push(st.object)
    }
  } else if(typeof w == 'undefined') {
    for(i = 0; i < n; i++) {
      st = sts[i];
      results.push(st.why)
    }
  }
  return results
}

$rdf.Formula.prototype.any = function (s, p, o, w) {
  var st = this.anyStatementMatching(s, p, o, w)
  if(typeof st == 'undefined') return undefined;

  if(typeof s == 'undefined') return st.subject;
  if(typeof p == 'undefined') return st.predicate;
  if(typeof o == 'undefined') return st.object;

  return undefined
}

$rdf.Formula.prototype.holds = function (s, p, o, w) {
  var st = this.anyStatementMatching(s, p, o, w)
  if(typeof st == 'undefined') return false;
  return true;
}

$rdf.Formula.prototype.the = function (s, p, o, w) {
  // the() should contain a check there is only one
  var x = this.any(s, p, o, w)
  if(typeof x == 'undefined')
    $rdf.log.error("No value found for the(){" + s + " " + p + " " + o + "}.")
  return x
}

$rdf.Formula.prototype.whether = function (s, p, o, w) {
  return this.statementsMatching(s, p, o, w, false).length;
}
/******** END match.js ********/
/******** BEGIN rdfparser.js ********/
/**
 * @fileoverview
 * TABULATOR RDF PARSER
 *
 * Version 0.1
 *  Parser believed to be in full positive RDF/XML parsing compliance
 *  with the possible exception of handling deprecated RDF attributes
 *  appropriately. Parser is believed to comply fully with other W3C
 *  and industry standards where appropriate (DOM, ECMAScript, &c.)
 *
 *  Author: David Sheets <dsheets@mit.edu>
 *  SVN ID: $Id$
 *
 * W3C® SOFTWARE NOTICE AND LICENSE
 * http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
 * This work (and included software, documentation such as READMEs, or
 * other related items) is being provided by the copyright holders under
 * the following license. By obtaining, using and/or copying this work,
 * you (the licensee) agree that you have read, understood, and will
 * comply with the following terms and conditions.
 *
 * Permission to copy, modify, and distribute this software and its
 * documentation, with or without modification, for any purpose and
 * without fee or royalty is hereby granted, provided that you include
 * the following on ALL copies of the software and documentation or
 * portions thereof, including modifications:
 *
 * 1. The full text of this NOTICE in a location viewable to users of
 * the redistributed or derivative work.
 * 2. Any pre-existing intellectual property disclaimers, notices, or terms and
 * conditions. If none exist, the W3C Software Short Notice should be
 * included (hypertext is preferred, text is permitted) within the body
 * of any redistributed or derivative code.
 * 3. Notice of any changes or modifications to the files, including the
 * date changes were made. (We recommend you provide URIs to the location
 * from which the code is derived.)
 *
 * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS," AND COPYRIGHT
 * HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS
 * FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR
 * DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
 * TRADEMARKS OR OTHER RIGHTS.
 *
 * COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL
 * OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR
 * DOCUMENTATION.
 *
 * The name and trademarks of copyright holders may NOT be used in
 * advertising or publicity pertaining to the software without specific,
 * written prior permission. Title to copyright in this software and any
 * associated documentation will at all times remain with copyright
 * holders.
 */
/**
 * @class Class defining an RDFParser resource object tied to an RDFStore
 *
 * @author David Sheets <dsheets@mit.edu>
 * @version 0.1
 *
 * @constructor
 * @param {RDFStore} store An RDFStore object
 */
$rdf.RDFParser = function (store) {
  var RDFParser = {};

  /** Standard namespaces that we know how to handle @final
   *  @member RDFParser
   */
  RDFParser['ns'] = {
    'RDF': "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    'RDFS': "http://www.w3.org/2000/01/rdf-schema#"
  }
  /** DOM Level 2 node type magic numbers @final
   *  @member RDFParser
   */
  RDFParser['nodeType'] = {
    'ELEMENT': 1,
    'ATTRIBUTE': 2,
    'TEXT': 3,
    'CDATA_SECTION': 4,
    'ENTITY_REFERENCE': 5,
    'ENTITY': 6,
    'PROCESSING_INSTRUCTION': 7,
    'COMMENT': 8,
    'DOCUMENT': 9,
    'DOCUMENT_TYPE': 10,
    'DOCUMENT_FRAGMENT': 11,
    'NOTATION': 12
  }

  /**
   * Frame class for namespace and base URI lookups
   * Base lookups will always resolve because the parser knows
   * the default base.
   *
   * @private
   */
  this['frameFactory'] = function (parser, parent, element) {
    return {
      'NODE': 1,
      'ARC': 2,
      'parent': parent,
      'parser': parser,
      'store': parser['store'],
      'element': element,
      'lastChild': 0,
      'base': null,
      'lang': null,
      'node': null,
      'nodeType': null,
      'listIndex': 1,
      'rdfid': null,
      'datatype': null,
      'collection': false,

      /** Terminate the frame and notify the store that we're done */
      'terminateFrame': function () {
        if(this['collection']) {
          this['node']['close']()
        }
      },

      /** Add a symbol of a certain type to the this frame */
      'addSymbol': function (type, uri) {
        uri = $rdf.Util.uri.join(uri, this['base'])
        this['node'] = this['store']['sym'](uri)
        this['nodeType'] = type
      },

      /** Load any constructed triples into the store */
      'loadTriple': function () {
        if(this['parent']['parent']['collection']) {
          this['parent']['parent']['node']['append'](this['node'])
        } else {
          this['store']['add'](this['parent']['parent']['node'],
            this['parent']['node'],
            this['node'],
            this['parser']['why'])
        }
        if(this['parent']['rdfid'] != null) { // reify
          var triple = this['store']['sym'](
          $rdf.Util.uri.join("#" + this['parent']['rdfid'], this['base']))
          this['store']['add'](triple,
            this['store']['sym'](RDFParser['ns']['RDF'] + "type"),
            this['store']['sym'](RDFParser['ns']['RDF'] + "Statement"),
            this['parser']['why'])
          this['store']['add'](triple,
            this['store']['sym'](RDFParser['ns']['RDF'] + "subject"),
            this['parent']['parent']['node'],
            this['parser']['why'])
          this['store']['add'](triple,
            this['store']['sym'](RDFParser['ns']['RDF'] + "predicate"),
            this['parent']['node'],
            this['parser']['why'])
          this['store']['add'](triple,
            this['store']['sym'](RDFParser['ns']['RDF'] + "object"),
            this['node'],
            this['parser']['why'])
        }
      },

      /** Check if it's OK to load a triple */
      'isTripleToLoad': function () {
        return (this['parent'] != null
          && this['parent']['parent'] != null
          && this['nodeType'] == this['NODE']
          && this['parent']['nodeType'] == this['ARC']
          && this['parent']['parent']['nodeType'] == this['NODE'])
      },

      /** Add a symbolic node to this frame */
      'addNode': function (uri) {
        this['addSymbol'](this['NODE'], uri)
        if(this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add a collection node to this frame */
      'addCollection': function () {
        this['nodeType'] = this['NODE']
        this['node'] = this['store']['collection']()
        this['collection'] = true
        if(this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add a collection arc to this frame */
      'addCollectionArc': function () {
        this['nodeType'] = this['ARC']
      },

      /** Add a bnode to this frame */
      'addBNode': function (id) {
        if(id != null) {
          if(this['parser']['bnodes'][id] != null) {
            this['node'] = this['parser']['bnodes'][id]
          } else {
            this['node'] = this['parser']['bnodes'][id] = this['store']['bnode']()
          }
        } else {
          this['node'] = this['store']['bnode']()
        }

        this['nodeType'] = this['NODE']
        if(this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add an arc or property to this frame */
      'addArc': function (uri) {
        if(uri == RDFParser['ns']['RDF'] + "li") {
          uri = RDFParser['ns']['RDF'] + "_" + this['parent']['listIndex']++
        }
        this['addSymbol'](this['ARC'], uri)
      },

      /** Add a literal to this frame */
      'addLiteral': function (value) {
        if(this['parent']['datatype']) {
          this['node'] = this['store']['literal'](
          value, "", this['store']['sym'](
          this['parent']['datatype']))
        } else {
          this['node'] = this['store']['literal'](
          value, this['lang'])
        }
        this['nodeType'] = this['NODE']
        if(this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      }
    }
  }

  //from the OpenLayers source .. needed to get around IE problems.
  this['getAttributeNodeNS'] = function (node, uri, name) {
    var attributeNode = null;
    if(node.getAttributeNodeNS) {
      attributeNode = node.getAttributeNodeNS(uri, name);
    } else {
      var attributes = node.attributes;
      var potentialNode, fullName;
      for(var i = 0; i < attributes.length; ++i) {
        potentialNode = attributes[i];
        if(potentialNode.namespaceURI == uri) {
          fullName = (potentialNode.prefix) ? (potentialNode.prefix + ":" + name) : name;
          if(fullName == potentialNode.nodeName) {
            attributeNode = potentialNode;
            break;
          }
        }
      }
    }
    return attributeNode;
  }

  /** Our triple store reference @private */
  this['store'] = store
  /** Our identified blank nodes @private */
  this['bnodes'] = {}
  /** A context for context-aware stores @private */
  this['why'] = null
  /** Reification flag */
  this['reify'] = false

  /**
   * Build our initial scope frame and parse the DOM into triples
   * @param {DOMTree} document The DOM to parse
   * @param {String} base The base URL to use
   * @param {Object} why The context to which this resource belongs
   */
  this['parse'] = function (document, base, why) {
    // alert('parse base:'+base);
    var children = document['childNodes']

    // clean up for the next run
    this['cleanParser']()

    // figure out the root element
    //var root = document.documentElement; //this is faster, I think, cross-browser issue? well, DOM 2
    if(document['nodeType'] == RDFParser['nodeType']['DOCUMENT']) {
      for(var c = 0; c < children['length']; c++) {
        if(children[c]['nodeType'] == RDFParser['nodeType']['ELEMENT']) {
          var root = children[c]
          break
        }
      }
    } else if(document['nodeType'] == RDFParser['nodeType']['ELEMENT']) {
      var root = document
    } else {
      throw new Error("RDFParser: can't find root in " + base + ". Halting. ")
      return false
    }

    this['why'] = why


    // our topmost frame
    var f = this['frameFactory'](this)
    this['base'] = base
    f['base'] = base
    f['lang'] = ''

    this['parseDOM'](this['buildFrame'](f, root))
    return true
  }
  this['parseDOM'] = function (frame) {
    // a DOM utility function used in parsing
    var elementURI = function (el) {
        var result = "";
        if(el['namespaceURI'] == null) {
          throw new Error("RDF/XML syntax error: No namespace for "
            + el['localName'] + " in " + this.base)
        }
        if(el['namespaceURI']) {
          result = result + el['namespaceURI'];
        }
        if(el['localName']) {
          result = result + el['localName'];
        } else if(el['nodeName']) {
          if(el['nodeName'].indexOf(":") >= 0)
            result = result + el['nodeName'].split(":")[1];
          else
            result = result + el['nodeName'];
        }
        return result;
      }
    var dig = true // if we'll dig down in the tree on the next iter
    while(frame['parent']) {
      var dom = frame['element']
      var attrs = dom['attributes']

      if(dom['nodeType'] == RDFParser['nodeType']['TEXT']
        || dom['nodeType'] == RDFParser['nodeType']['CDATA_SECTION']) {
        //we have a literal
        if(frame['parent']['nodeType'] == frame['NODE']) {
          //must have had attributes, store as rdf:value
          frame['addArc'](RDFParser['ns']['RDF'] + 'value');
          frame = this['buildFrame'](frame);
        }
        frame['addLiteral'](dom['nodeValue'])
      } else if(elementURI(dom) != RDFParser['ns']['RDF'] + "RDF") {
        // not root
        if(frame['parent'] && frame['parent']['collection']) {
          // we're a collection element
          frame['addCollectionArc']()
          frame = this['buildFrame'](frame, frame['element'])
          frame['parent']['element'] = null
        }
        if(!frame['parent'] || !frame['parent']['nodeType']
          || frame['parent']['nodeType'] == frame['ARC']) {
          // we need a node
          var about = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "about")
          var rdfid = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "ID")
          if(about && rdfid) {
            throw new Error("RDFParser: " + dom['nodeName']
              + " has both rdf:id and rdf:about." + " Halting. Only one of these"
              + " properties may be specified on a" + " node.");
          }
          if(about == null && rdfid) {
            frame['addNode']("#" + rdfid['nodeValue'])
            dom['removeAttributeNode'](rdfid)
          } else if(about == null && rdfid == null) {
            var bnid = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "nodeID")
            if(bnid) {
              frame['addBNode'](bnid['nodeValue'])
              dom['removeAttributeNode'](bnid)
            } else {
              frame['addBNode']()
            }
          } else {
            frame['addNode'](about['nodeValue'])
            dom['removeAttributeNode'](about)
          }

          // Typed nodes
          var rdftype = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "type")
          if(RDFParser['ns']['RDF'] + "Description" != elementURI(dom)) {
            rdftype = {
              'nodeValue': elementURI(dom)
            }
          }
          if(rdftype != null) {
            this['store']['add'](frame['node'],
              this['store']['sym'](RDFParser['ns']['RDF'] + "type"),
              this['store']['sym'](
                $rdf.Util.uri.join(
                  rdftype['nodeValue'],
                  frame['base'])),
              this['why'])
            if(rdftype['nodeName']) {
              dom['removeAttributeNode'](rdftype)
            }
          }

          // Property Attributes
          for(var x = attrs['length'] - 1; x >= 0; x--) {
            this['store']['add'](frame['node'],
              this['store']['sym'](elementURI(attrs[x])),
              this['store']['literal'](
                attrs[x]['nodeValue'],
                frame['lang']),
              this['why'])
          }
        } else {
          // we should add an arc (or implicit bnode+arc)
          frame['addArc'](elementURI(dom))

          // save the arc's rdf:ID if it has one
          if(this['reify']) {
            var rdfid = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "ID")
            if(rdfid) {
              frame['rdfid'] = rdfid['nodeValue']
              dom['removeAttributeNode'](rdfid)
            }
          }

          var parsetype = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "parseType")
          var datatype = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "datatype")
          if(datatype) {
            frame['datatype'] = datatype['nodeValue']
            dom['removeAttributeNode'](datatype)
          }

          if(parsetype) {
            var nv = parsetype['nodeValue']
            if(nv == "Literal") {
              frame['datatype'] = RDFParser['ns']['RDF'] + "XMLLiteral"
              // (this.buildFrame(frame)).addLiteral(dom)
              // should work but doesn't
              frame = this['buildFrame'](frame)
              frame['addLiteral'](dom)
              dig = false
            } else if(nv == "Resource") {
              frame = this['buildFrame'](frame, frame['element'])
              frame['parent']['element'] = null
              frame['addBNode']()
            } else if(nv == "Collection") {
              frame = this['buildFrame'](frame, frame['element'])
              frame['parent']['element'] = null
              frame['addCollection']()
            }
            dom['removeAttributeNode'](parsetype)
          }

          if(attrs['length'] != 0) {
            var resource = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "resource")
            var bnid = this['getAttributeNodeNS'](dom, RDFParser['ns']['RDF'], "nodeID")

            frame = this['buildFrame'](frame)
            if(resource) {
              frame['addNode'](resource['nodeValue'])
              dom['removeAttributeNode'](resource)
            } else {
              if(bnid) {
                frame['addBNode'](bnid['nodeValue'])
                dom['removeAttributeNode'](bnid)
              } else {
                frame['addBNode']()
              }
            }

            for(var x = attrs['length'] - 1; x >= 0; x--) {
              var f = this['buildFrame'](frame)
              f['addArc'](elementURI(attrs[x]))
              if(elementURI(attrs[x]) == RDFParser['ns']['RDF'] + "type") {
                (this['buildFrame'](f))['addNode'](
                attrs[x]['nodeValue'])
              } else {
                (this['buildFrame'](f))['addLiteral'](
                attrs[x]['nodeValue'])
              }
            }
          } else if(dom['childNodes']['length'] == 0) {
            (this['buildFrame'](frame))['addLiteral']("")
          }
        }
      } // rdf:RDF
      // dig dug
      dom = frame['element']
      while(frame['parent']) {
        var pframe = frame
        while(dom == null) {
          frame = frame['parent']
          dom = frame['element']
        }
        var candidate = dom['childNodes'][frame['lastChild']]
        if(candidate == null || !dig) {
          frame['terminateFrame']()
          if(!(frame = frame['parent'])) {
            break
          } // done
          dom = frame['element']
          dig = true
        } else if((candidate['nodeType'] != RDFParser['nodeType']['ELEMENT']
            && candidate['nodeType'] != RDFParser['nodeType']['TEXT']
            && candidate['nodeType'] != RDFParser['nodeType']['CDATA_SECTION'])
          || ((candidate['nodeType'] == RDFParser['nodeType']['TEXT']
              || candidate['nodeType'] == RDFParser['nodeType']['CDATA_SECTION'])
            && dom['childNodes']['length'] != 1)) {
          frame['lastChild']++
        } else {
          // not a leaf
          frame['lastChild']++;
          frame = this['buildFrame'](pframe, dom['childNodes'][frame['lastChild'] - 1])
          break
        }
      }
    } // while
  }

  /**
   * Cleans out state from a previous parse run
   * @private
   */
  this['cleanParser'] = function () {
    this['bnodes'] = {}
    this['why'] = null
  }

  /**
   * Builds scope frame
   * @private
   */
  this['buildFrame'] = function (parent, element) {
    var frame = this['frameFactory'](this, parent, element)
    if(parent) {
      frame['base'] = parent['base']
      frame['lang'] = parent['lang']
    }
    if(element == null
      || element['nodeType'] == RDFParser['nodeType']['TEXT']
      || element['nodeType'] == RDFParser['nodeType']['CDATA_SECTION']) {
      return frame
    }

    var attrs = element['attributes']

    var base = element['getAttributeNode']("xml:base")
    if(base != null) {
      frame['base'] = base['nodeValue']
      element['removeAttribute']("xml:base")
    }
    var lang = element['getAttributeNode']("xml:lang")
    if(lang != null) {
      frame['lang'] = lang['nodeValue']
      element['removeAttribute']("xml:lang")
    }

    // remove all extraneous xml and xmlns attributes
    for(var x = attrs['length'] - 1; x >= 0; x--) {
      if(attrs[x]['nodeName']['substr'](0, 3) == "xml") {
        if(attrs[x].name.slice(0, 6) == 'xmlns:') {
          var uri = attrs[x].nodeValue;
          // alert('base for namespac attr:'+this.base);
          if(this.base) uri = $rdf.Util.uri.join(uri, this.base);
          this.store.setPrefixForURI(attrs[x].name.slice(6), uri);
        }
        //		alert('rdfparser: xml atribute: '+attrs[x].name) //@@
        element['removeAttributeNode'](attrs[x])
      }
    }
    return frame
  }
}
/******** END rdfparser.js ********/
/******** BEGIN translate.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

/**
 * @class
 * Deprecated class for creating new Zotero.Translate instances<br/>
 * <br/>
 * New code should use Zotero.Translate.Web, Zotero.Translate.Import, Zotero.Translate.Export, or
 * Zotero.Translate.Search
 */
Zotero.Translate = function(type) {
	Zotero.debug("Translate: WARNING: new Zotero.Translate() is deprecated; please don't use this if you don't have to");
	// hack
	var translate = Zotero.Translate.newInstance(type);
	for(var i in translate) {
		this[i] = translate[i];
	}
	this.constructor = translate.constructor;
	this.__proto__ = translate.__proto__;
}

/**
 * Create a new translator by a string type
 */
Zotero.Translate.newInstance = function(type) {
	return new Zotero.Translate[type.substr(0, 1).toUpperCase()+type.substr(1).toLowerCase()];
}

/**
 * Namespace for Zotero sandboxes
 * @namespace
 */
Zotero.Translate.Sandbox = {
	/**
	 * Combines a sandbox with the base sandbox
	 */
	"_inheritFromBase":function(sandboxToMerge) {
		var newSandbox = {};

		for(var method in Zotero.Translate.Sandbox.Base) {
			newSandbox[method] = Zotero.Translate.Sandbox.Base[method];
		}

		for(var method in sandboxToMerge) {
			newSandbox[method] = sandboxToMerge[method];
		}

		return newSandbox;
	},

	/**
	 * Base sandbox. These methods are available to all translators.
	 * @namespace
	 */
	"Base": {
		/**
		 * Called as {@link Zotero.Item#complete} from translators to save items to the database.
		 * @param {Zotero.Translate} translate
		 * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox
		 */
		"_itemDone":function(translate, item) {
			//Zotero.debug("Translate: Saving item");

			// warn if itemDone called after translation completed
			if(translate._complete) {
				Zotero.debug("Translate: WARNING: Zotero.Item#complete() called after Zotero.done(); please fix your code", 2);
			}

			const allowedObjects = ["complete", "attachments", "seeAlso", "creators", "tags", "notes"];

			delete item.complete;
			for(var i in item) {
				var val = item[i];
				if(!val && val !== 0) {
					// remove null, undefined, and false properties, and convert objects to strings
					delete item[i];
					continue;
				}

				var type = typeof val;
				var isObject = type === "object" || type === "xml" || type === "function",
					shouldBeObject = allowedObjects.indexOf(i) !== -1;
				if(isObject && !shouldBeObject) {
					// Convert things that shouldn't be objects to objects
					translate._debug("Translate: WARNING: typeof "+i+" is "+type+"; converting to string");
					item[i] = val.toString();
				} else if(shouldBeObject && !isObject) {
					translate._debug("Translate: WARNING: typeof "+i+" is "+type+"; converting to array");
					item[i] = [val];
				} else if(type === "string") {
					// trim strings
					item[i] = val.trim();
				}
			}

			// if we're not supposed to save the item or we're in a child translator,
			// just return the item array
			if(translate._libraryID === false || translate._parentTranslator) {
				translate.newItems.push(item);
				translate._runHandler("itemDone", item, item);
				return;
			}

			// We use this within the connector to keep track of items as they are saved
			if(!item.id) item.id = Zotero.Utilities.randomString();
			// don't save documents as documents in connector, since we can't pass them around
			if(Zotero.isConnector) {
				var attachments = item.attachments;
				var nAttachments = attachments.length;
				for(var j=0; j<nAttachments; j++) {
					if(attachments[j].document) {
						attachments[j].url = attachments[j].document.documentURI || attachments[j].document.URL;
						attachments[j].mimeType = "text/html";
						delete attachments[j].document;
					}
				}
			}

			// Fire itemSaving event
			translate._runHandler("itemSaving", item);

			if(translate instanceof Zotero.Translate.Web) {
				// For web translators, we queue saves
				translate.saveQueue.push(item);
			} else {
				// Save items
				translate._saveItems([item]);
			}
		},

		/**
		 * Gets translator options that were defined in displayOptions in translator header
		 *
		 * @param {Zotero.Translate} translate
		 * @param {String} option Option to be retrieved
		 */
		"getOption":function(translate, option) {
			if(typeof option !== "string") {
				throw(new Error("getOption: option must be a string"));
				return;
			}

			return translate._displayOptions[option];
		},

		/**
		 * Gets a hidden preference that can be defined by hiddenPrefs in translator header
		 *
		 * @param {Zotero.Translate} translate
		 * @param {String} pref Prefernce to be retrieved
		 */
		"getHiddenPref":function(translate, pref) {
			if(typeof(pref) != "string") {
				throw(new Error("getPref: preference must be a string"));
			}

			var hp = translate._translatorInfo.hiddenPrefs || {};

			var value;
			try {
				value = Zotero.Prefs.get('translators.' + pref);
			} catch(e) {}

			return (value !== undefined ? value : hp[pref]);
		},

		/**
		 * For loading other translators and accessing their methods
		 *
		 * @param {Zotero.Translate} translate
		 * @param {String} type Translator type ("web", "import", "export", or "search")
		 * @returns {Object} A safeTranslator object, which operates mostly like Zotero.Translate
		 */
		"loadTranslator":function(translate, type) {
			const setDefaultHandlers = function(translate, translation) {
				if(type !== "export"
					&& (!translation._handlers['itemDone'] || !translation._handlers['itemDone'].length)) {
					translation.setHandler("itemDone", function(obj, item) {
						translate.Sandbox._itemDone(translate, item);
					});
				}
				if(!translation._handlers['selectItems'] || !translation._handlers['selectItems'].length) {
					translation.setHandler("selectItems", translate._handlers["selectItems"]);
				}
			}

			if(typeof type !== "string") {
				throw(new Error("loadTranslator: type must be a string"));
				return;
			}

			Zotero.debug("Translate: Creating translate instance of type "+type+" in sandbox");
			var translation = Zotero.Translate.newInstance(type);
			translation._parentTranslator = translate;

			if(translation instanceof Zotero.Translate.Export && !(translation instanceof Zotero.Translate.Export)) {
				throw(new Error("Only export translators may call other export translators"));
			}

			/**
			 * @class Wrapper for {@link Zotero.Translate} for safely calling another translator
			 * from inside an existing translator
			 * @inner
			 */
			var safeTranslator = {};
			safeTranslator.__exposedProps__ = {
				"setSearch":"r",
				"setDocument":"r",
				"setHandler":"r",
				"setString":"r",
				"setTranslator":"r",
				"getTranslators":"r",
				"translate":"r",
				"getTranslatorObject":"r"
			};
			safeTranslator.setSearch = function(arg) {
				if(!Zotero.isBookmarklet) arg = JSON.parse(JSON.stringify(arg));
				return translation.setSearch(arg);
			};
			safeTranslator.setDocument = function(arg) {
				if (Zotero.isFx && !Zotero.isBookmarklet) {
					if (arg.wrappedJSObject && arg.wrappedJSObject.__wrappedObject) {
						arg = arg.wrappedJSObject.__wrappedObject;
					}
					return translation.setDocument(new XPCNativeWrapper(arg));
				} else {
					return translation.setDocument(arg);
				}
			};
			var errorHandlerSet = false;
			safeTranslator.setHandler = function(arg1, arg2) {
				if(arg1 === "error") errorHandlerSet = true;
				translation.setHandler(arg1,
					function(obj, item) {
						try {
							item = item.wrappedJSObject ? item.wrappedJSObject : item;
							if(arg1 == "itemDone") {
								item.complete = translate._sandboxZotero.Item.prototype.complete;
							} else if(arg1 == "translators" && Zotero.isFx && !Zotero.isBookmarklet) {
								var translators = new translate._sandboxManager.sandbox.Array();
								translators = translators.wrappedJSObject || translators;
								for (var i=0; i<item.length; i++) {
									translators.push(item[i]);
								}
								item = translators;
							}
							arg2(obj, item);
						} catch(e) {
							translate.complete(false, e);
						}
					}
				);
			};
			safeTranslator.setString = function(arg) { translation.setString(arg) };
			safeTranslator.setTranslator = function(arg) {
				var success = translation.setTranslator(arg);
				if(!success) {
					throw new Error("Translator "+translate.translator[0].translatorID+" attempted to call invalid translatorID "+arg);
				}
			};

			var translatorsHandlerSet = false;
			safeTranslator.getTranslators = function() {
				if(!translation._handlers["translators"] || !translation._handlers["translators"].length) {
					if(Zotero.isConnector) {
						throw new Error('Translator must register a "translators" handler to '+
							'call getTranslators() in this translation environment.');
					} else {
						translate._debug('COMPAT WARNING: Translator must register a "translators" handler to '+
							'call getTranslators() in connector');
					}
				}
				if(!translatorsHandlerSet) {
					translation.setHandler("translators", function() {
						translate.decrementAsyncProcesses("safeTranslator#getTranslators()");
					});
				}
				translate.incrementAsyncProcesses("safeTranslator#getTranslators()");
				return translation.getTranslators();
			};

			var doneHandlerSet = false;
			safeTranslator.translate = function() {
				translate.incrementAsyncProcesses("safeTranslator#translate()");
				setDefaultHandlers(translate, translation);
				if(!doneHandlerSet) {
					doneHandlerSet = true;
					translation.setHandler("done", function() { translate.decrementAsyncProcesses("safeTranslator#translate()") });
				}
				if(!errorHandlerSet) {
					errorHandlerSet = true;
					translation.setHandler("error", function(obj, error) { translate.complete(false, error) });
				}
				return translation.translate(false);
			};

			safeTranslator.getTranslatorObject = function(callback) {
				if(callback) {
					translate.incrementAsyncProcesses("safeTranslator#getTranslatorObject()");
				} else {
					translate._debug("COMPAT WARNING: Translator must pass a callback to getTranslatorObject() to operate in connector");
				}

				var sandbox;
				var haveTranslatorFunction = function(translator) {
					translation.translator[0] = translator;
					translation._loadTranslator(translator, function() {
						if(Zotero.isFx && !Zotero.isBookmarklet) {
							// do same origin check
							var secMan = Components.classes["@mozilla.org/scriptsecuritymanager;1"]
								.getService(Components.interfaces.nsIScriptSecurityManager);
							var ioService = Components.classes["@mozilla.org/network/io-service;1"]
								.getService(Components.interfaces.nsIIOService);

							var outerSandboxURI = ioService.newURI(typeof translate._sandboxLocation === "object" ?
								translate._sandboxLocation.location : translate._sandboxLocation, null, null);
							var innerSandboxURI = ioService.newURI(typeof translation._sandboxLocation === "object" ?
								translation._sandboxLocation.location : translation._sandboxLocation, null, null);

							try {
								secMan.checkSameOriginURI(outerSandboxURI, innerSandboxURI, false);
							} catch(e) {
								throw new Error("getTranslatorObject() may not be called from web or search "+
									"translators to web or search translators from different origins.");
							}
						}

						translation._prepareTranslation();
						setDefaultHandlers(translate, translation);
						sandbox = translation._sandboxManager.sandbox;
						if(!Zotero.Utilities.isEmpty(sandbox.exports)) {
							sandbox.exports.Zotero = sandbox.Zotero;
							sandbox = sandbox.exports;
						} else {
							translate._debug("COMPAT WARNING: "+translation.translator[0].label+" does "+
								"not export any properties. Only detect"+translation._entryFunctionSuffix+
								" and do"+translation._entryFunctionSuffix+" will be available in "+
								"connectors.");
						}

						if(callback) {
							try {
								callback(sandbox);
							} catch(e) {
								translate.complete(false, e);
								return;
							}
							translate.decrementAsyncProcesses("safeTranslator#getTranslatorObject()");
						}
					});
				};

				if(typeof translation.translator[0] === "object") {
					haveTranslatorFunction(translation.translator[0]);
					return translation._sandboxManager.sandbox;
				} else {
					if(Zotero.isConnector && (!Zotero.isFx || Zotero.isBookmarklet) && !callback) {
						throw new Error("Translator must pass a callback to getTranslatorObject() to "+
							"operate in this translation environment.");
					}

					Zotero.Translators.get(translation.translator[0], haveTranslatorFunction);
					if(Zotero.isConnector && Zotero.isFx && !callback) {
						while(!sandbox && translate._currentState) {
							// This processNextEvent call is used to handle a deprecated case
							Zotero.mainThread.processNextEvent(true);
						}
					}
					if(sandbox) return sandbox;
				}
			};

			if(Zotero.isFx && Zotero.platformMajorVersion >= 33) {
				for(var i in safeTranslator) {
					if (typeof(safeTranslator[i]) === "function") {
						safeTranslator[i] = translate._sandboxManager._makeContentForwarder(function(func) {
							return function() {
								func.apply(safeTranslator, this.args.wrappedJSObject || this.args);
							}
						}(safeTranslator[i]));
					}
				}
			}

			return safeTranslator;
		},

		/**
		 * Enables asynchronous detection or translation
		 * @param {Zotero.Translate} translate
		 * @deprecated
		 */
		"wait":function(translate) {},

		/**
		 * Sets the return value for detection
		 *
		 * @param {Zotero.Translate} translate
		 */
		"done":function(translate, returnValue) {
			if(translate._currentState === "detect") {
				translate._returnValue = returnValue;
			}
		},

		/**
		 * Proxy for translator _debug function
		 *
		 * @param {Zotero.Translate} translate
		 * @param {String} string String to write to console
		 * @param {String} [level] Level to log as (1 to 5)
		 */
		"debug":function(translate, string, level) {
			translate._debug(string, level);
		}
	},

	/**
	 * Web functions exposed to sandbox
	 * @namespace
	 */
	"Web":{
		/**
		 * Lets user pick which items s/he wants to put in his/her library
		 * @param {Zotero.Translate} translate
		 * @param {Object} items An set of id => name pairs in object format
		 */
		"selectItems":function(translate, items, callback) {
			function transferObject(obj) {
				return Zotero.isFx && !Zotero.isBookmarklet ? translate._sandboxManager.copyObject(obj) : obj;
			}

			if(Zotero.Utilities.isEmpty(items)) {
				throw new Error("Translator called select items with no items");
			}

			// Some translators pass an array rather than an object to Zotero.selectItems.
			// This will break messaging outside of Firefox, so we need to fix it.
			if(Object.prototype.toString.call(items) === "[object Array]") {
				translate._debug("WARNING: Zotero.selectItems should be called with an object, not an array");
				var itemsObj = {};
				for(var i in items) itemsObj[i] = items[i];
				items = itemsObj;
			}
			if(translate._selectedItems) {
				// if we have a set of selected items for this translation, use them
				return transferObject(translate._selectedItems);
			} else if(translate._handlers.select) {
					// whether the translator supports asynchronous selectItems
					var haveAsyncCallback = !!callback;
					// whether the handler operates asynchronously
					var haveAsyncHandler = false;
					var returnedItems = null;

					var callbackExecuted = false;
					if(haveAsyncCallback) {
						// if this translator provides an async callback for selectItems, rig things
						// up to pop off the async process
						var newCallback = function(selectedItems) {
							callbackExecuted = true;
							callback(transferObject(selectedItems));
							if(haveAsyncHandler) translate.decrementAsyncProcesses("Zotero.selectItems()");
						};
					} else {
						// if this translator doesn't provide an async callback for selectItems, set things
						// up so that we can wait to see if the select handler returns synchronously. If it
						// doesn't, we will need to restart translation.
						var newCallback = function(selectedItems) {
							callbackExecuted = true;
							if(haveAsyncHandler) {
								translate.translate(translate._libraryID, translate._saveAttachments, selectedItems);
							} else {
								returnedItems = transferObject(selectedItems);
							}
						};
					}

					if(Zotero.isFx && !Zotero.isBookmarklet) {
						items = Components.utils.cloneInto(items, {});
					}

					var returnValue = translate._runHandler("select", items, newCallback);
					if(returnValue !== undefined) {
						// handler may have returned a value, which makes callback unnecessary
						Zotero.debug("WARNING: Returning items from a select handler is deprecated. "+
							"Please pass items as to the callback provided as the third argument to "+
							"the handler.");

						returnedItems = transferObject(returnValue);
						haveAsyncHandler = false;
					} else {
						// if we don't have returnedItems set already, the handler is asynchronous
						haveAsyncHandler = !callbackExecuted;
					}

					if(haveAsyncCallback) {
						if(haveAsyncHandler) {
							// we are running asynchronously, so increment async processes
							translate.incrementAsyncProcesses("Zotero.selectItems()");
						} else if(!callbackExecuted) {
							// callback didn't get called from handler, so call it here
							callback(returnedItems);
						}
						return false;
					} else {
						translate._debug("COMPAT WARNING: No callback was provided for "+
							"Zotero.selectItems(). When executed outside of Firefox, a selectItems() call "+
							"will require this translator to be called multiple times.", 1);

						if(haveAsyncHandler) {
							// The select handler is asynchronous, but this translator doesn't support
							// asynchronous select. We return false to abort translation in this
							// instance, and we will restart it later when the selectItems call is
							// complete.
							translate._aborted = true;
							return false;
						} else {
							return returnedItems;
						}
					}
			} else { // no handler defined; assume they want all of them
				if(callback) callback(items);
				return items;
			}
		},

		/**
		 * Overloads {@link Zotero.Translate.Sandbox.Base._itemDone} to ensure that no standalone
		 * items are saved, that an item type is specified, and to add a libraryCatalog and
		 * shortTitle if relevant.
		 * @param {Zotero.Translate} translate
		 * @param {SandboxItem} An item created using the Zotero.Item class from the sandbox
		 */
		 "_itemDone":function(translate, item) {
		 	// Only apply checks if there is no parent translator
		 	if(!translate._parentTranslator) {
				if(!item.itemType) {
					item.itemType = "webpage";
					translate._debug("WARNING: No item type specified");
				}
				if(item.type == "attachment" || item.type == "note") {
					Zotero.debug("Translate: Discarding standalone "+item.type+" in non-import translator", 2);
					return;
				}

				// store library catalog if this item was captured from a website, and
				// libraryCatalog is truly undefined (not false or "")
				if(item.repository !== undefined) {
					Zotero.debug("Translate: 'repository' field is now 'libraryCatalog'; please fix your code", 2);
					item.libraryCatalog = item.repository;
					delete item.repository;
				}

				// automatically set library catalog
				if(item.libraryCatalog === undefined) {
					item.libraryCatalog = translate.translator[0].label;
				}

				// automatically set access date if URL is set
				if(item.url && typeof item.accessDate == 'undefined') {
					item.accessDate = "CURRENT_TIMESTAMP";
				}

				//consider type-specific "title" alternatives
				var altTitle = Zotero.ItemFields.getName(Zotero.ItemFields.getFieldIDFromTypeAndBase(item.itemType, 'title'));
				if(altTitle && item[altTitle]) item.title = item[altTitle];

				if(!item.title) {
					translate.complete(false, new Error("No title specified for item"), item);
					return;
				}

				// create short title
				if(item.shortTitle === undefined && Zotero.Utilities.fieldIsValidForType("shortTitle", item.itemType)) {
					// only set if changes have been made
					var setShortTitle = false;
					var title = item.title;

					// shorten to before first colon
					var index = title.indexOf(":");
					if(index !== -1) {
						title = title.substr(0, index);
						setShortTitle = true;
					}
					// shorten to after first question mark
					index = title.indexOf("?");
					if(index !== -1) {
						index++;
						if(index != title.length) {
							title = title.substr(0, index);
							setShortTitle = true;
						}
					}

					if(setShortTitle) item.shortTitle = title;
				}

				/* Clean up ISBNs
				 * Allow multiple ISBNs, but...
				 * (1) validate all ISBNs
				 * (2) convert all ISBNs to ISBN-13
				 * (3) remove any duplicates
				 * (4) separate them with space
				 */
				if (item.ISBN) {
					// Match ISBNs with groups separated by various dashes or even spaces
					var isbnRe = /\b(?:97[89][\s\x2D\xAD\u2010-\u2015\u2043\u2212]*)?(?:\d[\s\x2D\xAD\u2010-\u2015\u2043\u2212]*){9}[\dx](?![\x2D\xAD\u2010-\u2015\u2043\u2212])\b/gi,
						validISBNs = [],
						isbn;
					while (isbn = isbnRe.exec(item.ISBN)) {
						var validISBN = Zotero.Utilities.cleanISBN(isbn[0]);
						if (!validISBN) {
							// Back up and move up one character
							isbnRe.lastIndex = isbn.index + 1;
							continue;
						}

						var isbn13 = Zotero.Utilities.toISBN13(validISBN);
						if (validISBNs.indexOf(isbn13) == -1) validISBNs.push(isbn13);
					}
					item.ISBN = validISBNs.join(' ');
				}

				// refuse to save very long tags
				if(item.tags) {
					for(var i=0; i<item.tags.length; i++) {
						var tag = item.tags[i];
							tagString = typeof tag === "string" ? tag :
								typeof tag === "object" ? (tag.tag || tag.name) : null;
						if(tagString && tagString.length > 255) {
							translate._debug("WARNING: Skipping unsynchable tag "+JSON.stringify(tagString));
							item.tags.splice(i--, 1);
						}
					}
				}

				for(var i=0; i<item.attachments.length; i++) {
					var attachment = item.attachments[i];

					// Web translators are not allowed to use attachment.path
					if (attachment.path) {
						if (!attachment.url) attachment.url = attachment.path;
						delete attachment.path;
					}

					if(attachment.url) {
						// Remap attachment (but not link) URLs
						// TODO: provide both proxied and un-proxied URLs (also for documents)
						//   because whether the attachment is attached as link or file
						//   depends on Zotero preferences as well.
						attachment.url = translate.resolveURL(attachment.url, attachment.snapshot === false);
					}
				}
			}

			// call super
			Zotero.Translate.Sandbox.Base._itemDone(translate, item);
		},

		/**
		 * Tells Zotero to monitor changes to the DOM and re-trigger detectWeb
		 * Can only be set during the detectWeb call
		 * @param {DOMNode} target Document node to monitor for changes
		 * @param {MutationObserverInit} [config] specifies which DOM mutations should be reported
		 */
		"monitorDOMChanges":function(translate, target, config) {
			if(translate._currentState != "detect") {
				Zotero.debug("Translate: monitorDOMChanges can only be called during the 'detect' stage");
				return;
			}

			var window = translate.document.defaultView
			var mutationObserver = window && ( window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver );
			if(!mutationObserver) {
				Zotero.debug("Translate: This browser does not support mutation observers.");
				return;
			}

			var translator = translate._potentialTranslators[0];
			if(!translate._registeredDOMObservers[translator.translatorID])
				translate._registeredDOMObservers[translator.translatorID] = [];
			var obs = translate._registeredDOMObservers[translator.translatorID];

			//do not re-register observer by the same translator for the same node
			if(obs.indexOf(target) != -1) {
				Zotero.debug("Translate: Already monitoring this node");
				return;
			}

			obs.push(target);

			var observer = new mutationObserver(function(mutations, observer) {
				obs.splice(obs.indexOf(target),1);
				observer.disconnect();

				Zotero.debug("Translate: Page modified.");
				//we don't really care what got updated
				var doc = mutations[0].target.ownerDocument;
				translate._runHandler("pageModified", doc);
			});

			observer.observe(target, config || {childList: true, subtree: true});
			Zotero.debug("Translate: Mutation observer registered on <" + target.nodeName + "> node");
		}
	},

	/**
	 * Import functions exposed to sandbox
	 * @namespace
	 */
	"Import":{
		/**
		 * Saves a collection to the DB
		 * Called as {@link Zotero.Collection#complete} from the sandbox
		 * @param {Zotero.Translate} translate
		 * @param {SandboxCollection} collection
		 */
		"_collectionDone":function(translate, collection) {
			if(translate._libraryID == false) {
				translate.newCollections.push(collection);
				translate._runHandler("collectionDone", collection);
			} else {
				var newCollection = translate._itemSaver.saveCollection(collection);
				translate.newCollections.push(newCollection);
				translate._runHandler("collectionDone", newCollection);
			}
		},

		/**
		 * Sets the value of the progress indicator associated with export as a percentage
		 * @param {Zotero.Translate} translate
		 * @param {Number} value
		 */
		"setProgress":function(translate, value) {
			if(typeof value !== "number") {
				translate._progress = null;
			} else {
				translate._progress = value;
			}
		}
	},

	/**
	 * Export functions exposed to sandbox
	 * @namespace
	 */
	"Export":{
		/**
		 * Retrieves the next item to be exported
		 * @param {Zotero.Translate} translate
		 * @return {SandboxItem}
		 */
		"nextItem":function(translate) {
			var item = translate._itemGetter.nextItem();

			if(translate._displayOptions.hasOwnProperty("exportTags") && !translate._displayOptions["exportTags"]) {
				item.tags = [];
			}

			translate._runHandler("itemDone", item);

			return item;
		},

		/**
		 * Retrieves the next collection to be exported
		 * @param {Zotero.Translate} translate
		 * @return {SandboxCollection}
		 */
		"nextCollection":function(translate) {
			if(!translate._translatorInfo.configOptions || !translate._translatorInfo.configOptions.getCollections) {
				throw(new Error("getCollections configure option not set; cannot retrieve collection"));
			}

			return translate._itemGetter.nextCollection();
		},

		/**
		 * @borrows Zotero.Translate.Sandbox.Import.setProgress as this.setProgress
		 */
		"setProgress":function(translate, value) {
			Zotero.Translate.Sandbox.Import.setProgress(translate, value);
		}
	},

	/**
	 * Search functions exposed to sandbox
	 * @namespace
	 */
	"Search":{
		/**
		 * @borrows Zotero.Translate.Sandbox.Web._itemDone as this._itemDone
		 */
		"_itemDone":function(translate, item) {
			// Always set library catalog, even if we have a parent translator
			if(item.libraryCatalog === undefined) {
				item.libraryCatalog = translate.translator[0].label;
			}

			Zotero.Translate.Sandbox.Web._itemDone(translate, item);
		}
	}
}

/**
 * @class Base class for all translation types
 *
 * @property {String} type The type of translator. This is deprecated; use instanceof instead.
 * @property {Zotero.Translator[]} translator The translator currently in use. Usually, only the
 *     first entry of the Zotero.Translator array is populated; subsequent entries represent
 *     translators to be used if the first fails.
 * @property {String} path The path or URI string of the target
 * @property {String} newItems Items created when translate() was called
 * @property {String} newCollections Collections created when translate() was called
 * @property {Number} runningAsyncProcesses The number of async processes that are running. These
 *                                          need to terminate before Zotero.done() is called.
 */
Zotero.Translate.Base = function() {}
Zotero.Translate.Base.prototype = {
	/**
	 * Initializes a Zotero.Translate instance
	 */
	"init":function() {
		this._handlers = [];
		this._currentState = null;
		this._translatorInfo = null;
		this.document = null;
		this.location = null;
	},

	/**
	 * Sets the location to operate upon
	 *
	 * @param {String|nsIFile} location The URL to which the sandbox should be bound or path to local file
	 */
	"setLocation":function(location) {
		this.location = location;
		if(typeof this.location == "object") {	// if a file
			this.path = location.path;
		} else {								// if a url
			this.path = location;
		}
	},

	/**
	 * Sets the translator to be used for import/export
	 *
	 * @param {Zotero.Translator|string} Translator object or ID
	 */
	"setTranslator":function(translator) {
		if(!translator) {
			throw new Error("No translator specified");
		}

		this.translator = null;

		if(typeof(translator) == "object") {	// passed an object and not an ID
			if(translator.translatorID) {
				this.translator = [translator];
			} else {
				throw(new Error("No translatorID specified"));
			}
		} else {
			this.translator = [translator];
		}

		return !!this.translator;
	},

	/**
	 * Registers a handler function to be called when translation is complete
	 *
	 * @param {String} type Type of handler to register. Legal values are:
	 * select
	 *   valid: web
	 *   called: when the user needs to select from a list of available items
	 *   passed: an associative array in the form id => text
	 *   returns: a numerically indexed array of ids, as extracted from the passed
	 *            string
	 * itemDone
	 *   valid: import, web, search
	 *   called: when an item has been processed; may be called asynchronously
	 *   passed: an item object (see Zotero.Item)
	 *   returns: N/A
	 * collectionDone
	 *   valid: import
	 *   called: when a collection has been processed, after all items have been
	 *           added; may be called asynchronously
	 *   passed: a collection object (see Zotero.Collection)
	 *   returns: N/A
	 * done
	 *   valid: all
	 *   called: when all processing is finished
	 *   passed: true if successful, false if an error occurred
	 *   returns: N/A
	 * debug
	 *   valid: all
	 *   called: when Zotero.debug() is called
	 *   passed: string debug message
	 *   returns: true if message should be logged to the console, false if not
	 * error
	 *   valid: all
	 *   called: when a fatal error occurs
	 *   passed: error object (or string)
	 *   returns: N/A
	 * translators
	 *   valid: all
	 *   called: when a translator search initiated with Zotero.Translate.getTranslators() is
	 *           complete
	 *   passed: an array of appropriate translators
	 *   returns: N/A
	 * pageModified
	 *   valid: web
	 *   called: when a web page has been modified
	 *   passed: the document object for the modified page
	 *   returns: N/A
	 * @param {Function} handler Callback function. All handlers will be passed the current
	 * translate instance as the first argument. The second argument is dependent on the handler.
	 */
	"setHandler":function(type, handler) {
		if(!this._handlers[type]) {
			this._handlers[type] = new Array();
		}
		this._handlers[type].push(handler);
	},

	/**
	 * Clears all handlers for a given function
	 * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values
	 */
	"clearHandlers":function(type) {
		this._handlers[type] = new Array();
	},

	/**
	 * Clears a single handler for a given function
	 * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values
	 * @param {Function} handler Callback function to remove
	 */
	"removeHandler":function(type, handler) {
		var handlerIndex = this._handlers[type].indexOf(handler);
		if(handlerIndex !== -1) this._handlers[type].splice(handlerIndex, 1);
	},

	/**
	 * Indicates that a new async process is running
	 */
	"incrementAsyncProcesses":function(f) {
		this._runningAsyncProcesses++;
		if(this._parentTranslator) {
			this._parentTranslator.incrementAsyncProcesses(f+" from child translator");
		} else {
			//Zotero.debug("Translate: Incremented asynchronous processes to "+this._runningAsyncProcesses+" for "+f, 4);
			//Zotero.debug((new Error()).stack);
		}
	},

	/**
	 * Indicates that a new async process is finished
	 */
	"decrementAsyncProcesses":function(f, by) {
		this._runningAsyncProcesses -= (by ? by : 1);
		if(!this._parentTranslator) {
			//Zotero.debug("Translate: Decremented asynchronous processes to "+this._runningAsyncProcesses+" for "+f, 4);
			//Zotero.debug((new Error()).stack);
		}
		if(this._runningAsyncProcesses === 0) {
			this.complete();
		}
		if(this._parentTranslator) this._parentTranslator.decrementAsyncProcesses(f+" from child translator", by);
	},

	/**
	 * Clears all handlers for a given function
	 * @param {String} type See {@link Zotero.Translate.Base#setHandler} for valid values
	 * @param {Any} argument Argument to be passed to handler
	 */
	"_runHandler":function(type) {
		var returnValue = undefined;
		if(this._handlers[type]) {
			// compile list of arguments
			if(this._parentTranslator) {
				// if there is a parent translator, make sure we don't pass the Zotero.Translate
				// object, since it could open a security hole
				var args = [null];
			} else {
				var args = [this];
			}
			for(var i=1; i<arguments.length; i++) {
				args.push(arguments[i]);
			}

			var handlers = this._handlers[type].slice();
			for(var i=0, n=handlers.length; i<n; i++) {
				Zotero.debug("Translate: Running handler "+i+" for "+type, 5);
				try {
					returnValue = handlers[i].apply(null, args);
				} catch(e) {
					if(this._parentTranslator) {
						// throw handler errors if they occur when a translator is
						// called from another translator, so that the
						// "Could Not Translate" dialog will appear if necessary
						throw(e);
					} else {
						// otherwise, fail silently, so as not to interfere with
						// interface cleanup
						Zotero.debug("Translate: "+e+' in handler '+i+' for '+type, 5);
						Zotero.logError(e);
					}
				}
			}
		}
		return returnValue;
	},

	/**
	 * Gets all applicable translators of a given type
	 *
	 * For import, you should call this after setLocation; otherwise, you'll just get a list of all
	 * import filters, not filters equipped to handle a specific file
	 *
	 * @param {Boolean} [getAllTranslators] Whether all applicable translators should be returned,
	 *     rather than just the first available.
	 * @param {Boolean} [checkSetTranslator] If true, the appropriate detect function is run on the
	 *     set document/text/etc. using the translator set by setTranslator.
	 *     getAllTranslators parameter is meaningless in this context.
	 * @return {Zotero.Translator[]} An array of {@link Zotero.Translator} objects
	 */
	"getTranslators":function(getAllTranslators, checkSetTranslator) {
		// do not allow simultaneous instances of getTranslators
		if(this._currentState === "detect") throw new Error("getTranslators: detection is already running");
		this._currentState = "detect";
		this._getAllTranslators = getAllTranslators;

		if(checkSetTranslator) {
			// setTranslator must be called beforehand if checkSetTranslator is set
			if( !this.translator || !this.translator[0] ) {
				throw new Error("getTranslators: translator must be set via setTranslator before calling" +
													" getTranslators with the checkSetTranslator flag");
			}
			var translators = new Array();
			var t;
			for(var i=0, n=this.translator.length; i<n; i++) {
				if(typeof(this.translator[i]) == 'string') {
					t = Zotero.Translators.get(this.translator[i]);
					if(!t) Zotero.debug("getTranslators: could not retrieve translator '" + this.translator[i] + "'");
				} else {
					t = this.translator[i];
				}
				/**TODO: check that the translator is of appropriate type?*/
				if(t) translators.push(t);
			}
			if(!translators.length) throw new Error("getTranslators: no valid translators were set.");
			this._getTranslatorsTranslatorsReceived(translators);
		} else {
			this._getTranslatorsGetPotentialTranslators();
		}

		// if detection returns immediately, return found translators
		if(!this._currentState) return this._foundTranslators;
	},

	/**
	 * Get all potential translators
	 * @return {Zotero.Translator[]}
	 */
	"_getTranslatorsGetPotentialTranslators":function() {
		var me = this;
		Zotero.Translators.getAllForType(this.type,
			function(translators) { me._getTranslatorsTranslatorsReceived(translators) });
	},

	/**
	 * Called on completion of {@link #_getTranslatorsGetPotentialTranslators} call
	 */
	"_getTranslatorsTranslatorsReceived":function(allPotentialTranslators, properToProxyFunctions) {
		this._potentialTranslators = [];
		this._foundTranslators = [];

		// this gets passed out by Zotero.Translators.getWebTranslatorsForLocation() because it is
		// specific for each translator, but we want to avoid making a copy of a translator whenever
		// possible.
		this._properToProxyFunctions = properToProxyFunctions ? properToProxyFunctions : null;
		this._waitingForRPC = false;

		for(var i=0, n=allPotentialTranslators.length; i<n; i++) {
			var translator = allPotentialTranslators[i];
			if(translator.runMode === Zotero.Translator.RUN_MODE_IN_BROWSER) {
				this._potentialTranslators.push(translator);
			} else if(this instanceof Zotero.Translate.Web && Zotero.Connector) {
				this._waitingForRPC = true;
			}
		}

		if(this._waitingForRPC) {
			var me = this;
			Zotero.Connector.callMethod("detect", {"uri":this.location.toString(),
				"cookie":this.document.cookie,
				"html":this.document.documentElement.innerHTML},
				function(returnValue) { me._getTranslatorsRPCComplete(returnValue) });
		}

		this._detect();
	},

	/**
	 * Called on completion of detect RPC for
	 * {@link Zotero.Translate.Base#_getTranslatorsTranslatorsReceived}
	 */
	 "_getTranslatorsRPCComplete":function(rpcTranslators) {
		this._waitingForRPC = false;

		// if there are translators, add them to the list of found translators
		if(rpcTranslators) {
			for(var i=0, n=rpcTranslators.length; i<n; i++) {
				rpcTranslators[i].runMode = Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE;
			}
			this._foundTranslators = this._foundTranslators.concat(rpcTranslators);
		}

		// call _detectTranslatorsCollected to return detected translators
		if(this._currentState === null) {
			this._detectTranslatorsCollected();
		}
	 },

	/**
	 * Begins the actual translation. At present, this returns immediately for import/export
	 * translators, but new code should use {@link Zotero.Translate.Base#setHandler} to register a
	 * "done" handler to determine when execution of web/search translators is complete.
	 *
	 * @param 	{NULL|Integer|FALSE}	[libraryID=null]		Library in which to save items,
	 *																or NULL for default library;
	 *																if FALSE, don't save items
	 * @param 	{Boolean}				[saveAttachments=true]	Exclude attachments (e.g., snapshots) on import
	 */
	"translate":function(libraryID, saveAttachments) {		// initialize properties specific to each translation
		if(!this.translator || !this.translator.length) {
			var args = arguments;
			Zotero.debug("Translate: translate called without specifying a translator. Running detection first.");
			this.setHandler('translators', function(me, translators) {
				if(!translators.length) {
					me.complete(false, "Could not find an appropriate translator");
				} else {
					me.setTranslator(translators);
					Zotero.Translate.Base.prototype.translate.apply(me, args);
				}
			});
			this.getTranslators();
			return;
		}

		this._currentState = "translate";

		this._libraryID = libraryID;
		this._saveAttachments = saveAttachments === undefined || saveAttachments;
		this._savingAttachments = [];
		this._savingItems = 0;
		this._waitingForSave = false;

		var me = this;
		if(typeof this.translator[0] === "object") {
			// already have a translator object, so use it
			this._loadTranslator(this.translator[0], function() { me._translateTranslatorLoaded() });
		} else {
			// need to get translator first
			Zotero.Translators.get(this.translator[0],
					function(translator) {
						me.translator[0] = translator;
						me._loadTranslator(translator, function() { me._translateTranslatorLoaded() });
					});
		}
	},

	/**
	 * Called when translator has been retrieved and loaded
	 */
	"_translateTranslatorLoaded":function() {
		if(!this.translator[0].code) {
			this.complete(false,
				new Error("Translator "+this.translator[0].label+" is unsupported within this environment"));
			return;
		}

		// set display options to default if they don't exist
		if(!this._displayOptions) this._displayOptions = this._translatorInfo.displayOptions || {};

		// prepare translation
		this._prepareTranslation();

		Zotero.debug("Translate: Beginning translation with "+this.translator[0].label);

		this.incrementAsyncProcesses("Zotero.Translate#translate()");

		// translate
		try {
			Function.prototype.apply.call(this._sandboxManager.sandbox["do"+this._entryFunctionSuffix], null, this._getParameters());
		} catch(e) {
			this.complete(false, e);
			return false;
		}

		this.decrementAsyncProcesses("Zotero.Translate#translate()");
	},

	/**
	 * Return the progress of the import operation, or null if progress cannot be determined
	 */
	"getProgress":function() { return null },

	/**
	 * Translate a URL to a form that goes through the appropriate proxy, or
	 * convert a relative URL to an absolute one
	 *
	 * @param {String} url
	 * @param {Boolean} dontUseProxy If true, don't convert URLs to variants
	 *     that use the proxy
	 * @type String
	 * @private
	 */
	"resolveURL":function(url, dontUseProxy) {
		Zotero.debug("Translate: resolving URL " + url);

		const hostPortRe = /^([A-Z][-A-Z0-9+.]*):\/\/[^\/]+/i;
		const allowedSchemes = ['http', 'https', 'ftp'];

		var m = url.match(hostPortRe),
			resolved;
		if (!m) {
			// Convert relative URLs to absolute
			if(Zotero.isFx && this.location) {
				resolved = Components.classes["@mozilla.org/network/io-service;1"].
					getService(Components.interfaces.nsIIOService).
					newURI(this.location, "", null).resolve(url);
			} else if(Zotero.isNode && this.location) {
				resolved = require('url').resolve(this.location, url);
			} else if (this.document) {
				var a = this.document.createElement('a');
				a.href = url;
				resolved = a.href;
			} else if (url.indexOf('//') == 0) {
				// Protocol-relative URL with no associated web page
				// Use http by default
				resolved = 'http' + url;
			} else {
				throw new Error('Cannot resolve relative URL without an associated web page: ' + url);
			}
		} else if (allowedSchemes.indexOf(m[1].toLowerCase()) == -1) {
			Zotero.debug("Translate: unsupported scheme " + m[1]);
			return url;
		} else {
			resolved = url;
		}

		Zotero.debug("Translate: resolved to " + resolved);

		// convert proxy to proper if applicable
		if(!dontUseProxy && this.translator && this.translator[0]
				&& this.translator[0].properToProxy) {
			var proxiedURL = this.translator[0].properToProxy(resolved);
			if (proxiedURL != resolved) {
				Zotero.debug("Translate: proxified to " + proxiedURL);
			}
			resolved = proxiedURL;
		}

		/*var m = hostPortRe.exec(resolved);
		if(!m) {
			throw new Error("Invalid URL supplied for HTTP request: "+url);
		} else if(this._translate.document && this._translate.document.location) {
			var loc = this._translate.document.location;
			if(this._translate._currentState !== "translate" && loc
					&& (m[1].toLowerCase() !== loc.protocol.toLowerCase()
					|| m[2].toLowerCase() !== loc.host.toLowerCase())) {
				throw new Error("Attempt to access "+m[1]+"//"+m[2]+" from "+loc.protocol+"//"+loc.host
					+" blocked: Cross-site requests are only allowed during translation");
			}
		}*/

		return resolved;
	},

	/**
	 * Executed on translator completion, either automatically from a synchronous scraper or as
	 * done() from an asynchronous scraper. Finishes things up and calls callback function(s).
	 * @param {Boolean|String} returnValue An item type or a boolean true or false
	 * @param {String|Exception} [error] An error that occurred during translation.
	 * @returm {String|NULL} The exception serialized to a string, or null if translation
	 *     completed successfully.
	 */
	"complete":function(returnValue, error, item) {
		// allow translation to be aborted for re-running after selecting items
		if(this._aborted) {
			if (item) Zotero.API.notifyFullReferenceFail(item);
			return;
		}

		// Make sure this isn't called twice
		if(this._currentState === null) {
			if(!returnValue) {
				Zotero.debug("Translate: WARNING: Zotero.done() called after translator completion with error");
				Zotero.debug(error);
			} else {
				var e = new Error();
				Zotero.debug("Translate: WARNING: Zotero.done() called after translation completion. This should never happen. Please examine the stack below.");
				Zotero.debug(e.stack);
			}
			return;
		}

		// reset async processes and propagate them to parent
		if(this._parentTranslator && this._runningAsyncProcesses) {
			this._parentTranslator.decrementAsyncProcesses("Zotero.Translate#complete", this._runningAsyncProcesses);
		}
		this._runningAsyncProcesses = 0;

		if(!returnValue && this._returnValue) returnValue = this._returnValue;

		var errorString = null;
		if(!returnValue && error) errorString = this._generateErrorString(error);

		if(this._currentState === "detect") {
			if(this._potentialTranslators.length) {
				var lastTranslator = this._potentialTranslators.shift();
				var lastProperToProxyFunction = this._properToProxyFunctions ? this._properToProxyFunctions.shift() : null;

				if(returnValue) {
					var dupeTranslator = {"properToProxy":lastProperToProxyFunction};

					for(var i in lastTranslator) dupeTranslator[i] = lastTranslator[i];
					if(Zotero.isBookmarklet && returnValue === "server") {
						// In the bookmarklet, the return value from detectWeb can be "server" to
						// indicate the translator should be run on the Zotero server
						dupeTranslator.runMode = Zotero.Translator.RUN_MODE_ZOTERO_SERVER;
					} else {
						// Usually the return value from detectWeb will be either an item type or
						// the string "multiple"
						dupeTranslator.itemType = returnValue;
					}

					this._foundTranslators.push(dupeTranslator);
				} else if(error) {
					this._debug("Detect using "+lastTranslator.label+" failed: \n"+errorString, 2);
				}
			}

			if(this._potentialTranslators.length && (this._getAllTranslators || !returnValue)) {
				// more translators to try; proceed to next translator
				this._detect();
			} else {
				this._currentState = null;
				if(!this._waitingForRPC) this._detectTranslatorsCollected();
			}
		} else {
			// unset return value is equivalent to true
			if(returnValue === undefined) returnValue = true;

			if(returnValue) {
				if(this.saveQueue.length) {
					this._waitingForSave = true;
					this._saveItems(this.saveQueue);
					this.saveQueue = [];
					return;
				}
				this._debug("Translation successful");
			} else {
				if(error) {
					// report error to console
					Zotero.logError(error);

					// report error to debug log
					this._debug("Translation using "+(this.translator && this.translator[0] && this.translator[0].label ? this.translator[0].label : "no translator")+" failed: \n"+errorString, 2);
				}

				this._runHandler("error", error);
			}

			this._currentState = null;

			// call handlers
			this._runHandler("itemsDone", returnValue);
			if(returnValue) {
				this._checkIfDone();
			} else {
				this._runHandler("done", returnValue);
			}
		}

		return errorString;
	},

	/**
	 * Saves items to the database, taking care to defer attachmentProgress notifications
	 * until after save
	 */
	"_saveItems":function(items) {
		var me = this,
			itemDoneEventsDispatched = false,
			deferredProgress = [],
			attachmentsWithProgress = [];

		this._savingItems++;
		this._itemSaver.saveItems(items.slice(), function(returnValue, newItems) {
			if(returnValue) {
				// Remove attachments not being saved from item.attachments
				for(var i=0; i<items.length; i++) {
					var item = items[i];
					for(var j=0; j<item.attachments.length; j++) {
						if(attachmentsWithProgress.indexOf(item.attachments[j]) === -1) {
							item.attachments.splice(j--, 1);
						}
					}
				}

				// Trigger itemDone events
				for(var i=0, nItems = items.length; i<nItems; i++) {
					me._runHandler("itemDone", newItems[i], items[i]);
				}

				// Specify that itemDone event was dispatched, so that we don't defer
				// attachmentProgress notifications anymore
				itemDoneEventsDispatched = true;

				// Run deferred attachmentProgress notifications
				for(var i=0; i<deferredProgress.length; i++) {
					me._runHandler("attachmentProgress", deferredProgress[i][0],
						deferredProgress[i][1], deferredProgress[i][2]);
				}

				me.newItems = me.newItems.concat(newItems);
				me._savingItems--;
				me._checkIfDone();
			} else {
				Zotero.logError(newItems);
				me.complete(returnValue, newItems);
			}
		},
		function(attachment, progress, error) {
			var attachmentIndex = me._savingAttachments.indexOf(attachment);
			if(progress === false || progress === 100) {
				if(attachmentIndex !== -1) {
					me._savingAttachments.splice(attachmentIndex, 1);
				}
			} else if(attachmentIndex === -1) {
				me._savingAttachments.push(attachment);
			}

			if(itemDoneEventsDispatched) {
				// itemDone event has already fired, so we can fire attachmentProgress
				// notifications
				me._runHandler("attachmentProgress", attachment, progress, error);
				me._checkIfDone();
			} else {
				// Defer until after we fire the itemDone event
				deferredProgress.push([attachment, progress, error]);
				attachmentsWithProgress.push(attachment);
			}
		});
	},

	/**
	 * Checks if saving done, and if so, fires done event
	 */
	"_checkIfDone":function() {
		if(!this._savingItems && !this._savingAttachments.length && (!this._currentState || this._waitingForSave)) {
			this._runHandler("done", true);
		}
	},

	/**
	 * Begins running detect code for a translator, first loading it
	 */
	"_detect":function() {
		// there won't be any translators if we need an RPC call
		if(!this._potentialTranslators.length) {
			this.complete(true);
			return;
		}

		var me = this;
		this._loadTranslator(this._potentialTranslators[0],
			function() { me._detectTranslatorLoaded() });
	},

	/**
	 * Runs detect code for a translator
	 */
	"_detectTranslatorLoaded":function() {
		this._prepareDetection();

		this.incrementAsyncProcesses("Zotero.Translate#getTranslators");

		try {
			var returnValue = Function.prototype.apply.call(this._sandboxManager.sandbox["detect"+this._entryFunctionSuffix], null, this._getParameters());
		} catch(e) {
			this.complete(false, e);
			return;
		}

		if(returnValue !== undefined) this._returnValue = returnValue;
		this.decrementAsyncProcesses("Zotero.Translate#getTranslators");
	},

	/**
	 * Called when all translators have been collected for detection
	 */
	"_detectTranslatorsCollected":function() {
		Zotero.debug("Translate: All translator detect calls and RPC calls complete:");
		this._foundTranslators.sort(function(a, b) { return a.priority-b.priority });
		if (this._foundTranslators.length) {
			this._foundTranslators.forEach(function(t) {
				Zotero.debug("\t" + t.label + ": " + t.priority);
			});
		} else {
			Zotero.debug("\tNo suitable translators found");
		}
		this._runHandler("translators", this._foundTranslators);
	},

	/**
	 * Loads the translator into its sandbox
	 * @param {Zotero.Translator} translator
	 * @return {Boolean} Whether the translator could be successfully loaded
	 */
	"_loadTranslator":function(translator, callback) {
		var sandboxLocation = this._getSandboxLocation();
		if(!this._sandboxLocation || sandboxLocation !== this._sandboxLocation) {
			this._sandboxLocation = sandboxLocation;
			this._generateSandbox();
		}

		this._currentTranslator = translator;
		this._runningAsyncProcesses = 0;
		this._returnValue = undefined;
		this._aborted = false;
		this.saveQueue = [];

		Zotero.debug("Translate: Parsing code for " + translator.label + " "
			+ "(" + translator.translatorID + ", " + translator.lastUpdated + ")", 4);

		try {
			this._sandboxManager.eval("var exports = {}, ZOTERO_TRANSLATOR_INFO = "+translator.code,
				["detect"+this._entryFunctionSuffix, "do"+this._entryFunctionSuffix, "exports",
					"ZOTERO_TRANSLATOR_INFO"],
				(translator.file ? translator.file.path : translator.label));
		} catch(e) {
			this.complete(false, e);
			return;
		}
		this._translatorInfo = this._sandboxManager.sandbox.ZOTERO_TRANSLATOR_INFO;

		if(callback) callback();
	},

	/**
	 * Generates a sandbox for scraping/scraper detection
	 */
	"_generateSandbox":function() {
		Zotero.debug("Translate: Binding sandbox to "+(typeof this._sandboxLocation == "object" ? this._sandboxLocation.document.location : this._sandboxLocation), 4);
		if (this._parentTranslator && this._parentTranslator._sandboxManager.newChild) {
			this._sandboxManager = this._parentTranslator._sandboxManager.newChild();
		} else {
			this._sandboxManager = new Zotero.Translate.SandboxManager(this._sandboxLocation);
		}
		const createArrays = "['creators', 'notes', 'tags', 'seeAlso', 'attachments']";
		var src = "var Zotero = {};"+
		"Zotero.Item = function (itemType) {"+
				"const createArrays = "+createArrays+";"+
				"this.itemType = itemType;"+
				"for(var i=0, n=createArrays.length; i<n; i++) {"+
					"this[createArrays[i]] = [];"+
				"}"+
		"};";

		if(this instanceof Zotero.Translate.Export || this instanceof Zotero.Translate.Import) {
			src += "Zotero.Collection = function () {};"+
			"Zotero.Collection.prototype.complete = function() { Zotero._collectionDone(this); };";
		}

		src += "Zotero.Item.prototype.complete = function() { Zotero._itemDone(this); }";

		this._sandboxManager.eval(src);
		this._sandboxManager.importObject(this.Sandbox, this);
		this._sandboxManager.importObject({"Utilities":new Zotero.Utilities.Translate(this)});

		this._sandboxZotero = this._sandboxManager.sandbox.Zotero;

		if(Zotero.isFx) {
			if(this._sandboxZotero.wrappedJSObject) this._sandboxZotero = this._sandboxZotero.wrappedJSObject;
		}
		this._sandboxZotero.Utilities.HTTP = this._sandboxZotero.Utilities;

		this._sandboxZotero.isBookmarklet = Zotero.isBookmarklet || false;
		this._sandboxZotero.isConnector = Zotero.isConnector || false;
		this._sandboxZotero.isServer = Zotero.isServer || false;
		this._sandboxZotero.parentTranslator = this._parentTranslator
			&& this._parentTranslator._currentTranslator ?
			this._parentTranslator._currentTranslator.translatorID : null;

		// create shortcuts
		this._sandboxManager.sandbox.Z = this._sandboxZotero;
		this._sandboxManager.sandbox.ZU = this._sandboxZotero.Utilities;
		this._transferItem = this._sandboxZotero._transferItem;
	},

	/**
	 * Logs a debugging message
	 * @param {String} string Debug string to log
	 * @param {Integer} level Log level (1-5, higher numbers are higher priority)
	 */
	"_debug":function(string, level) {
		if(level !== undefined && typeof level !== "number") {
			Zotero.debug("debug: level must be an integer");
			return;
		}

		// if handler does not return anything explicitly false, show debug
		// message in console
		if(this._runHandler("debug", string) !== false) {
			if(typeof string == "string") string = "Translate: "+string;
			Zotero.debug(string, level);
		}
	},
	/**
	 * Generates a string from an exception
	 * @param {String|Exception} error
	 */
	"_generateErrorString":function(error) {
		var errorString = "";
		if(typeof(error) == "string") {
			errorString = "\nthrown exception => "+error;
		} else {
			var haveStack = false;
			for(var i in error) {
				if(typeof(error[i]) != "object") {
					if(i === "stack") haveStack = true;
					errorString += "\n"+i+' => '+error[i];
				}
			}
			errorString += "\nstring => "+error.toString();
			if(!haveStack && error.stack) {
				// In case the stack is not enumerable
				errorString += "\nstack => "+error.stack.toString();
			}
		}

		errorString += "\nurl => "+this.path
			+ "\ndownloadAssociatedFiles => "+Zotero.Prefs.get("downloadAssociatedFiles")
			+ "\nautomaticSnapshots => "+Zotero.Prefs.get("automaticSnapshots");
		return errorString.substr(1);
	},

	/**
	 * Determines the location where the sandbox should be bound
	 * @return {String|document} The location to which to bind the sandbox
	 */
	"_getSandboxLocation":function() {
		return (this._parentTranslator ? this._parentTranslator._sandboxLocation : "http://www.example.com/");
	},

	/**
	 * Gets parameters to be passed to detect* and do* functions
	 * @return {Array} A list of parameters
	 */
	"_getParameters":function() { return []; },

	/**
	 * No-op for preparing detection
	 */
	"_prepareDetection":function() {},

	/**
	 * No-op for preparing translation
	 */
	"_prepareTranslation":function() {}
}

/**
 * @class Web translation
 *
 * @property {Document} document The document object to be used for web scraping (set with setDocument)
 * @property {Zotero.CookieSandbox} cookieSandbox A CookieSandbox to manage cookies for
 *     this Translate instance.
 */
Zotero.Translate.Web = function() {
	this._registeredDOMObservers = {}
	this.init();
}
Zotero.Translate.Web.prototype = new Zotero.Translate.Base();
Zotero.Translate.Web.prototype.type = "web";
Zotero.Translate.Web.prototype._entryFunctionSuffix = "Web";
Zotero.Translate.Web.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Web);

/**
 * Sets the browser to be used for web translation
 * @param {Document} doc An HTML document
 */
Zotero.Translate.Web.prototype.setDocument = function(doc) {
	this.document = doc;
	this.setLocation(doc.location.href);
}

/**
 * Sets a Zotero.CookieSandbox to handle cookie management for XHRs initiated from this
 * translate instance
 *
 * @param {Zotero.CookieSandbox} cookieSandbox
 */
Zotero.Translate.Web.prototype.setCookieSandbox = function(cookieSandbox) {
	this.cookieSandbox = cookieSandbox;
}

/**
 * Sets the location to operate upon
 *
 * @param {String} location The URL of the page to translate
 */
Zotero.Translate.Web.prototype.setLocation = function(location) {
	this.location = location;
	this.path = this.location;
}

/**
 * Get potential web translators
 */
Zotero.Translate.Web.prototype._getTranslatorsGetPotentialTranslators = function() {
	var me = this;
	Zotero.Translators.getWebTranslatorsForLocation(this.location,
			function(data) {
				// data[0] = list of translators
				// data[1] = list of functions to convert proper URIs to proxied URIs
				me._getTranslatorsTranslatorsReceived(data[0], data[1]);
			});
}

/**
 * Bind sandbox to document being translated
 */
Zotero.Translate.Web.prototype._getSandboxLocation = function() {
	if(this._parentTranslator) {
		return this._parentTranslator._sandboxLocation;
	} else if(this.document.defaultView
			&& (this.document.defaultView.toString().indexOf("Window") !== -1
				|| this.document.defaultView.toString().indexOf("XrayWrapper") !== -1)) {
		return this.document.defaultView;
	} else {
		return this.document.location.toString();
	}
}

/**
 * Pass document and location to detect* and do* functions
 */
Zotero.Translate.Web.prototype._getParameters = function() {
	if (Zotero.Translate.DOMWrapper &&
		Zotero.Translate.DOMWrapper.isWrapped(this.document) &&
		Zotero.platformMajorVersion >= 35) {
		return [this._sandboxManager.wrap(Zotero.Translate.DOMWrapper.unwrap(this.document), null,
			                              this.document.__wrapperOverrides), this.location];
	} else {
		return [this.document, this.location];
	}
};

/**
 * Prepare translation
 */
Zotero.Translate.Web.prototype._prepareTranslation = function() {
	this._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,
		Zotero.Translate.ItemSaver[(this._saveAttachments ? "ATTACHMENT_MODE_DOWNLOAD" : "ATTACHMENT_MODE_IGNORE")], 1,
		this.document, this._cookieSandbox, this.location);
	this.newItems = [];
}

/**
 * Overload translate to set selectedItems
 */
Zotero.Translate.Web.prototype.translate = function(libraryID, saveAttachments, selectedItems) {
	this._selectedItems = selectedItems;
	Zotero.Translate.Base.prototype.translate.apply(this, [libraryID, saveAttachments]);
}

/**
 * Overload _translateTranslatorLoaded to send an RPC call if necessary
 */
Zotero.Translate.Web.prototype._translateTranslatorLoaded = function() {
	var runMode = this.translator[0].runMode;
	if(runMode === Zotero.Translator.RUN_MODE_IN_BROWSER || this._parentTranslator) {
		Zotero.Translate.Base.prototype._translateTranslatorLoaded.apply(this);
	} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE ||
			(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER && Zotero.Connector.isOnline)) {
		var me = this;
		Zotero.Connector.callMethod("savePage", {
				"uri":this.location.toString(),
				"translatorID":(typeof this.translator[0] === "object"
				                ? this.translator[0].translatorID : this.translator[0]),
				"cookie":this.document.cookie,
				"html":this.document.documentElement.innerHTML
			}, function(obj) { me._translateRPCComplete(obj) });
	} else if(runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER) {
		var me = this;
		Zotero.API.createItem({"url":this.document.location.href.toString()},
			function(statusCode, response) {
				me._translateServerComplete(statusCode, response);
			});
	}
}

/**
 * Called when an call to Zotero Standalone for translation completes
 */
Zotero.Translate.Web.prototype._translateRPCComplete = function(obj, failureCode) {
	if(!obj) this.complete(false, failureCode);

	if(obj.selectItems) {
		// if we have to select items, call the selectItems handler and do it
		var me = this;
		this._runHandler("select", obj.selectItems,
			function(selectedItems) {
				Zotero.Connector.callMethod("selectItems",
					{"instanceID":obj.instanceID, "selectedItems":selectedItems},
					function(obj) { me._translateRPCComplete(obj) })
			}
		);
	} else {
		// if we don't have to select items, continue
		for(var i=0, n=obj.items.length; i<n; i++) {
			this._runHandler("itemDone", null, obj.items[i]);
		}
		this.newItems = obj.items;
		this.complete(true);
	}
}

/**
 * Called when an call to the Zotero Translator Server for translation completes
 */
Zotero.Translate.Web.prototype._translateServerComplete = function(statusCode, response) {
	if(statusCode === 300) {
		// Multiple Choices
		try {
			response = JSON.parse(response);
		} catch(e) {
			Zotero.logError(e);
			this.complete(false, "Invalid JSON response received from server");
			return;
		}
		var me = this;
		this._runHandler("select", response,
			function(selectedItems) {
				Zotero.API.createItem({
						"url":me.document.location.href.toString(),
						"items":selectedItems
					},
					function(statusCode, response) {
							me._translateServerComplete(statusCode, response);
					});
			}
		);
	} else if(statusCode === 201) {
		// Created
		try {
			response = (new DOMParser()).parseFromString(response, "application/xml");
		} catch(e) {
			Zotero.logError(e);
			this.complete(false, "Invalid XML response received from server");
			return;
		}

		// Extract items from ATOM/JSON response
		var items = [], contents;
		if("getElementsByTagNameNS" in response) {
			contents = response.getElementsByTagNameNS("http://www.w3.org/2005/Atom", "content");
		} else { // IE...
			contents = response.getElementsByTagName("content");
		}
		for(var i=0, n=contents.length; i<n; i++) {
			var content = contents[i];
			if("getAttributeNS" in content) {
				if(content.getAttributeNS("http://zotero.org/ns/api", "type") != "json") continue;
			} else if(content.getAttribute("zapi:type") != "json") { // IE...
				continue;
			}

			try {
				var item = JSON.parse("textContent" in content ?
					content.textContent : content.text);
			} catch(e) {
				Zotero.logError(e);
				this.complete(false, "Invalid JSON response received from server");
				return;
			}

			if(!("attachments" in item)) item.attachments = [];
			this._runHandler("itemDone", null, item);
			items.push(item);
		}
		this.newItems = items;
		this.complete(true);
	} else {
		this.complete(false, response);
	}
}

/**
 * Overload complete to report translation failure
 */
Zotero.Translate.Web.prototype.complete = function(returnValue, error, item) {
	// call super
	var oldState = this._currentState;
	var errorString = Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error, item]);

	// Report translation failure if we failed
	if(oldState == "translate" && errorString && !this._parentTranslator && this.translator.length
		&& this.translator[0].inRepository && Zotero.Prefs.get("reportTranslationFailure")) {
		var translator = this.translator[0];
	}
}

/**
 * @class Import translation
 */
Zotero.Translate.Import = function() {
	this.init();
}
Zotero.Translate.Import.prototype = new Zotero.Translate.Base();
Zotero.Translate.Import.prototype.type = "import";
Zotero.Translate.Import.prototype._entryFunctionSuffix = "Import";
Zotero.Translate.Import.prototype._io = false;

Zotero.Translate.Import.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Import);

/**
 * Sets string for translation and initializes string IO
 */
Zotero.Translate.Import.prototype.setString = function(string) {
	this._string = string;
	this._io = false;
}

/**
 * Overload {@link Zotero.Translate.Base#complete} to close file
 */
Zotero.Translate.Import.prototype.complete = function(returnValue, error) {
	if(this._io) {
		this._progress = null;
		this._io.close(false);
	}

	// call super
	Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);
}

/**
 * Get all potential import translators, ordering translators with the right file extension first
 */
Zotero.Translate.Import.prototype._getTranslatorsGetPotentialTranslators = function() {
	if(this.location) {
		var me = this;
		Zotero.Translators.getImportTranslatorsForLocation(this.location,
			function(translators) { me._getTranslatorsTranslatorsReceived(translators) });
	} else {
		Zotero.Translate.Base.prototype._getTranslatorsGetPotentialTranslators.call(this);
	}
}

/**
 * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately only
 * if no string or location is set
 */
Zotero.Translate.Import.prototype.getTranslators = function() {
	if(!this._string && !this.location) {
		if(this._currentState === "detect") throw new Error("getTranslators: detection is already running");
		this._currentState = "detect";
		var me = this;
		Zotero.Translators.getAllForType(this.type, function(translators) {
			me._potentialTranslators = [];
			me._foundTranslators = translators;
			me.complete(true);
		});
		if(this._currentState === null) return this._foundTranslators;
	} else {
		return Zotero.Translate.Base.prototype.getTranslators.call(this);
	}
}

/**
 * Overload {@link Zotero.Translate.Base#_loadTranslator} to prepare translator IO
 */
Zotero.Translate.Import.prototype._loadTranslator = function(translator, callback) {
	// call super
	var me = this;
	Zotero.Translate.Base.prototype._loadTranslator.call(this, translator, function() {
		me._loadTranslatorPrepareIO(translator, callback);
	});
}

/**
 * Prepare translator IO
 */
Zotero.Translate.Import.prototype._loadTranslatorPrepareIO = function(translator, callback) {
	var configOptions = this._translatorInfo.configOptions;
	var dataMode = configOptions ? configOptions["dataMode"] : "";

	var me = this;
	var initCallback = function(status, err) {
		if(!status) {
			me.complete(false, err);
		} else {
			me._sandboxManager.importObject(me._io);
			if(callback) callback();
		}
	};

	var err = false;
	if(!this._io) {
		if(Zotero.Translate.IO.Read && this.location && this.location instanceof Components.interfaces.nsIFile) {
			try {
				this._io = new Zotero.Translate.IO.Read(this.location, this._sandboxManager);
			} catch(e) {
				err = e;
			}
		} else {
			try {
				this._io = new Zotero.Translate.IO.String(this._string, this.path ? this.path : "", this._sandboxManager);
			} catch(e) {
				err = e;
			}
		}

		if(err) {
			this.complete(false, err);
			return;
		}
	}

	try {
		this._io.init(dataMode, initCallback);
	} catch(e) {
		err = e;
	}
	if(err) {
		this.complete(false, err);
		return;
	}
}

/**
 * Prepare translation
 */
Zotero.Translate.Import.prototype._prepareTranslation = function() {
	this._progress = undefined;

	var baseURI = null;
	if(this.location) {
		try {
			baseURI = Components.classes["@mozilla.org/network/io-service;1"].
				getService(Components.interfaces.nsIIOService).newFileURI(this.location);
		} catch(e) {}
	}

	this._itemSaver = new Zotero.Translate.ItemSaver(this._libraryID,
		Zotero.Translate.ItemSaver[(this._saveAttachments ? "ATTACHMENT_MODE_FILE" : "ATTACHMENT_MODE_IGNORE")],
		undefined, undefined, undefined, baseURI);
	this.newItems = [];
	this.newCollections = [];
}

/**
 * Return the progress of the import operation, or null if progress cannot be determined
 */
Zotero.Translate.Import.prototype.getProgress = function() {
	if(this._progress !== undefined) return this._progress;
	if(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 || this._mode === "xml/e4x" || this._mode == "xml/dom" || !this._io) {
		return null;
	}
	return this._io.bytesRead/this._io.contentLength*100;
};


/**
 * @class Export translation
 */
Zotero.Translate.Export = function() {
	this.init();
}
Zotero.Translate.Export.prototype = new Zotero.Translate.Base();
Zotero.Translate.Export.prototype.type = "export";
Zotero.Translate.Export.prototype._entryFunctionSuffix = "Export";
Zotero.Translate.Export.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Export);

/**
 * Sets the items to be exported
 * @param {Zotero.Item[]} items
 */
Zotero.Translate.Export.prototype.setItems = function(items) {
	this._export = {type: 'items', items: items};
}

/**
 * Sets the group to be exported (overrides setItems/setCollection)
 * @param {Zotero.Group[]} group
 */
Zotero.Translate.Export.prototype.setLibraryID = function(libraryID) {
	this._export = {type: 'library', id: libraryID};
}

/**
 * Sets the collection to be exported (overrides setItems/setGroup)
 * @param {Zotero.Collection[]} collection
 */
Zotero.Translate.Export.prototype.setCollection = function(collection) {
	this._export = {type: 'collection', collection: collection};
}

/**
 * Sets the translator to be used for export
 *
 * @param {Zotero.Translator|string} Translator object or ID. If this contains a displayOptions
 *    attribute, setDisplayOptions is automatically called with the specified value.
 */
Zotero.Translate.Export.prototype.setTranslator = function(translator) {
	if(typeof translator == "object" && translator.displayOptions) {
		this._displayOptions = translator.displayOptions;
	}
	return Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);
}

/**
 * Sets translator display options. you can also pass a translator (not ID) to
 * setTranslator that includes a displayOptions argument
 */
Zotero.Translate.Export.prototype.setDisplayOptions = function(displayOptions) {
	this._displayOptions = displayOptions;
}

/**
 * Overload {@link Zotero.Translate.Base#complete} to close file and set complete
 */
Zotero.Translate.Export.prototype.complete = function(returnValue, error) {
	if(this._io) {
		this._progress = null;
		this._io.close(true);
		if(this._io instanceof Zotero.Translate.IO.String) {
			this.string = this._io.string;
		}
	}

	// call super
	Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);
}

/**
 * Overload {@link Zotero.Translate.Base#getTranslators} to return all translators immediately
 */
Zotero.Translate.Export.prototype.getTranslators = function() {
	if(this._currentState === "detect") throw new Error("getTranslators: detection is already running");
	this._currentState = "detect";
	this._foundTranslators = Zotero.Translators.getAllForType(this.type);
	this._potentialTranslators = [];
	this.complete(true);
	return this._foundTranslators;
}

/**
 * Does the actual export, after code has been loaded and parsed
 */
Zotero.Translate.Export.prototype._prepareTranslation = function() {
	this._progress = undefined;

	// initialize ItemGetter
	this._itemGetter = new Zotero.Translate.ItemGetter();

	// Toggle legacy mode for translators pre-4.0.27
	this._itemGetter.legacy = Services.vc.compare('4.0.27', this._translatorInfo.minVersion) > 0;

	var configOptions = this._translatorInfo.configOptions || {},
		getCollections = configOptions.getCollections || false;
	switch (this._export.type) {
		case 'collection':
			this._itemGetter.setCollection(this._export.collection, getCollections);
			break;
		case 'items':
			this._itemGetter.setItems(this._export.items);
			break;
		case 'library':
			this._itemGetter.setAll(this._export.id, getCollections);
			break;
		default:
			throw new Error('No export set up');
			break;
	}
	delete this._export;

	// export file data, if requested
	if(this._displayOptions["exportFileData"]) {
		this.location = this._itemGetter.exportFiles(this.location, this.translator[0].target);
	}

	// initialize IO
	// this is currently hackish since we pass null callbacks to the init function (they have
	// callbacks to be consistent with import, but they are synchronous, so we ignore them)
	if(!this.location) {
		this._io = new Zotero.Translate.IO.String(null, this.path ? this.path : "", this._sandboxManager);
		this._io.init(configOptions["dataMode"], function() {});
	} else if(!Zotero.Translate.IO.Write) {
		throw new Error("Writing to files is not supported in this build of Zotero.");
	} else {
		this._io = new Zotero.Translate.IO.Write(this.location);
		this._io.init(configOptions["dataMode"],
			this._displayOptions["exportCharset"] ? this._displayOptions["exportCharset"] : null,
			function() {});
	}

	this._sandboxManager.importObject(this._io);
}

/**
 * Overload Zotero.Translate.Base#translate to make sure that
 *   Zotero.Translate.Export#translate is not called without setting a
 *   translator first. Doesn't make sense to run detection for export.
 */
Zotero.Translate.Export.prototype.translate = function() {
	if(!this.translator || !this.translator.length) {
		this.complete(false, new Error("Export translation initiated without setting a translator"));
	} else {
		Zotero.Translate.Base.prototype.translate.apply(this, arguments);
	}
};

/**
 * Return the progress of the import operation, or null if progress cannot be determined
 */
Zotero.Translate.Export.prototype.getProgress = function() {
	if(this._progress !== undefined) return this._progress;
	if(!this._itemGetter) {
		return null;
	}
	return (1-this._itemGetter.numItemsRemaining/this._itemGetter.numItems)*100;
};

/**
 * @class Search translation
 * @property {Array[]} search Item (in {@link Zotero.Item#serialize} format) to extrapolate data
 *    (set with setSearch)
 */
Zotero.Translate.Search = function() {
	this.init();
};
Zotero.Translate.Search.prototype = new Zotero.Translate.Base();
Zotero.Translate.Search.prototype.type = "search";
Zotero.Translate.Search.prototype._entryFunctionSuffix = "Search";
Zotero.Translate.Search.prototype.Sandbox = Zotero.Translate.Sandbox._inheritFromBase(Zotero.Translate.Sandbox.Search);

/**
 * @borrows Zotero.Translate.Web#setCookieSandbox
 */
Zotero.Translate.Search.prototype.setCookieSandbox = Zotero.Translate.Web.prototype.setCookieSandbox;

/**
 * Sets the item to be used for searching
 * @param {Object} item An item, with as many fields as desired, in the format returned by
 *     {@link Zotero.Item#serialize}
 */
Zotero.Translate.Search.prototype.setSearch = function(search) {
	this.search = search;
}

/**
 * Overloads {@link Zotero.Translate.Base#getTranslators} to always return all potential translators
 */
Zotero.Translate.Search.prototype.getTranslators = function() {
	return Zotero.Translate.Base.prototype.getTranslators.call(this, true);
}

/**
 * Sets the translator or translators to be used for search
 *
 * @param {Zotero.Translator|string} Translator object or ID
 */
Zotero.Translate.Search.prototype.setTranslator = function(translator) {
	if(typeof translator == "object" && !translator.translatorID) {
		// we have an array of translators

		// accept a list of objects
		this.translator = [];
		for(var i=0, n=translator.length; i<n; i++) {
			this.translator.push(translator[i]);
		}
		return true;
	} else {
		return Zotero.Translate.Base.prototype.setTranslator.apply(this, [translator]);
	}
}

/**
 * Overload Zotero.Translate.Base#complete to move onto the next translator if
 * translation fails
 */
Zotero.Translate.Search.prototype.complete = function(returnValue, error) {
	if(this._currentState == "translate" && (!this.newItems || !this.newItems.length)
		&& this.translator.length) { //length is 0 only when translate was called without translators
		Zotero.debug("Translate: Could not find a result using "+this.translator[0].label, 3);
		if(error) Zotero.debug(this._generateErrorString(error), 3);
		if(this.translator.length > 1) {
			this.translator.shift();
			this.translate(this._libraryID, this._saveAttachments);
			return;
		} else {
			error = "No items returned from any translator";
			returnValue = false;
		}
	}

	// call super
	Zotero.Translate.Base.prototype.complete.apply(this, [returnValue, error]);
}

/**
 * Pass search item to detect* and do* functions
 */
Zotero.Translate.Search.prototype._getParameters = function() {
	if(Zotero.isFx) {
		return [this._sandboxManager.copyObject(this.search)];
	}
	return [this.search];
};

/**
 * Extract sandbox location from translator target
 */
Zotero.Translate.Search.prototype._getSandboxLocation = function() {
	// generate sandbox for search by extracting domain from translator target
	if(this.translator && this.translator[0] && this.translator[0].target) {
		// so that web translators work too
		const searchSandboxRe = /^http:\/\/[\w.]+\//;
		var tempURL = this.translator[0].target.replace(/\\/g, "").replace(/\^/g, "");
		var m = searchSandboxRe.exec(tempURL);
		if(m) return m[0];
	}
	return Zotero.Translate.Base.prototype._getSandboxLocation.call(this);
}

Zotero.Translate.Search.prototype._prepareTranslation = Zotero.Translate.Web.prototype._prepareTranslation;

/**
 * IO-related functions
 * @namespace
 */
Zotero.Translate.IO = {
	/**
	 * Parses XML using DOMParser
	 */
	"parseDOMXML":function(input, charset, size) {
		try {
			var dp = new DOMParser();
		} catch(e) {
			try {
				var dp = Components.classes["@mozilla.org/xmlextras/domparser;1"]
				   .createInstance(Components.interfaces.nsIDOMParser);
			} catch(e) {
				throw new Error("DOMParser not supported");
			}
		}

		if(typeof input == "string") {
			var nodes = dp.parseFromString(input, "text/xml");
		} else {
			var nodes = dp.parseFromStream(input, charset, size, "text/xml");
		}

		if(nodes.getElementsByTagName("parsererror").length) {
			throw "DOMParser error: loading data into data store failed";
		}

		if("normalize" in nodes) nodes.normalize();

		return nodes;
	},

	/**
	 * Names of RDF data modes
	 */
	"rdfDataModes":["rdf", "rdf/xml", "rdf/n3"]
};

/******* String support *******/

/**
 * @class Translate backend for translating from a string
 */
Zotero.Translate.IO.String = function(string, uri, sandboxManager) {
	if(string && typeof string === "string") {
		this.string = string;
	} else {
		this.string = "";
	}
	this.contentLength = this.string.length;
	this.bytesRead = 0;
	this._uri = uri;
	this._sandboxManager = sandboxManager;
}

Zotero.Translate.IO.String.prototype = {
	"__exposedProps__":{
		"RDF":"r",
		"read":"r",
		"write":"r",
		"setCharacterSet":"r",
		"getXML":"r"
	},

	"_initRDF":function(callback) {
		Zotero.debug("Translate: Initializing RDF data store");
		this._dataStore = new Zotero.RDF.AJAW.IndexedFormula();
		this.RDF = new Zotero.Translate.IO._RDFSandbox(this._dataStore);

		if(this.contentLength) {
			try {
				var xml = Zotero.Translate.IO.parseDOMXML(this.string);
			} catch(e) {
				this._xmlInvalid = true;
				throw e;
			}
			var parser = new Zotero.RDF.AJAW.RDFParser(this._dataStore);
			parser.parse(xml, this._uri);
		}
		callback(true);
	},

	"setCharacterSet":function(charset) {},

	"read":function(bytes) {
		// if we are reading in RDF data mode and no string is set, serialize current RDF to the
		// string
		if(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === "") {
			this.string = this.RDF.serialize();
		}

		// return false if string has been read
		if(this.bytesRead >= this.contentLength) {
			return false;
		}

		if(bytes !== undefined) {
			if(this.bytesRead >= this.contentLength) return false;
			var oldPointer = this.bytesRead;
			this.bytesRead += bytes;
			return this.string.substr(oldPointer, bytes);
		} else {
			// bytes not specified; read a line
			var oldPointer = this.bytesRead;
			var lfIndex = this.string.indexOf("\n", this.bytesRead);

			if(lfIndex !== -1) {
				// in case we have a CRLF
				this.bytesRead = lfIndex+1;
				if(this.contentLength > lfIndex && this.string.substr(lfIndex-1, 1) === "\r") {
					lfIndex--;
				}
				return this.string.substr(oldPointer, lfIndex-oldPointer);
			}

			if(!this._noCR) {
				var crIndex = this.string.indexOf("\r", this.bytesRead);
				if(crIndex === -1) {
					this._noCR = true;
				} else {
					this.bytesRead = crIndex+1;
					return this.string.substr(oldPointer, crIndex-oldPointer-1);
				}
			}

			this.bytesRead = this.contentLength;
			return this.string.substr(oldPointer);
		}
	},

	"write":function(data) {
		this.string += data;
		this.contentLength = this.string.length;
	},

	"getXML":function() {
		try {
			var xml = Zotero.Translate.IO.parseDOMXML(this.string);
		} catch(e) {
			this._xmlInvalid = true;
			throw e;
		}
		return (Zotero.isFx && !Zotero.isBookmarklet ? this._sandboxManager.wrap(xml) : xml);
	},

	"init":function(newMode, callback) {
		this.bytesRead = 0;
		this._noCR = undefined;

		this._mode = newMode;
		if(newMode === "xml/e4x") {
			throw "E4X is not supported";
		} else if(newMode && (Zotero.Translate.IO.rdfDataModes.indexOf(newMode) !== -1
				|| newMode.substr(0, 3) === "xml/dom") && this._xmlInvalid) {
			throw "XML known invalid";
		} else if(Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1) {
			this._initRDF(callback);
		} else {
			callback(true);
		}
	},

	"close":function(serialize) {
		// if we are writing in RDF data mode and no string is set, serialize current RDF to the
		// string
		if(serialize && Zotero.Translate.IO.rdfDataModes.indexOf(this._mode) !== -1 && this.string === "") {
			this.string = this.RDF.serialize();
		}
	}
}

/****** RDF DATA MODE ******/

/**
 * @class An API for handling RDF from the sandbox. This is exposed to translators as Zotero.RDF.
 *
 * @property {Zotero.RDF.AJAW.IndexedFormula} _dataStore
 * @property {Integer[]} _containerCounts
 * @param {Zotero.RDF.AJAW.IndexedFormula} dataStore
 */
Zotero.Translate.IO._RDFSandbox = function(dataStore) {
	this._dataStore = dataStore;
}

Zotero.Translate.IO._RDFSandbox.prototype = {
	"_containerCounts":[],
	"__exposedProps__":{
		"addStatement":"r",
		"newResource":"r",
		"newContainer":"r",
		"addContainerElement":"r",
		"getContainerElements":"r",
		"addNamespace":"r",
		"getAllResources":"r",
		"getResourceURI":"r",
		"getArcsIn":"r",
		"getArcsOut":"r",
		"getSources":"r",
		"getTargets":"r",
		"getStatementsMatching":"r",
		"serialize":"r"
	},

	/**
	 * Gets a resource as a Zotero.RDF.AJAW.Symbol, rather than a string
	 * @param {String|Zotero.RDF.AJAW.Symbol} about
	 * @return {Zotero.RDF.AJAW.Symbol}
	 */
	"_getResource":function(about) {
		return (typeof about == "object" ? about : new Zotero.RDF.AJAW.Symbol(about));
	},

	/**
	 * Runs a callback to initialize this RDF store
	 */
	"_init":function() {
		if(this._prepFunction) {
			this._dataStore = this._prepFunction();
			delete this._prepFunction;
		}
	},

	/**
	 * Serializes the current RDF to a string
	 */
	"serialize":function(dataMode) {
		var serializer = Zotero.RDF.AJAW.Serializer(this._dataStore);

		for(var prefix in this._dataStore.namespaces) {
			serializer.suggestPrefix(prefix, this._dataStore.namespaces[prefix]);
		}

		// serialize in appropriate format
		if(dataMode == "rdf/n3") {
			return serializer.statementsToN3(this._dataStore.statements);
		}

		return serializer.statementsToXML(this._dataStore.statements);
	},

	/**
	 * Adds an RDF triple
	 * @param {String|Zotero.RDF.AJAW.Symbol} about
	 * @param {String|Zotero.RDF.AJAW.Symbol} relation
	 * @param {String|Zotero.RDF.AJAW.Symbol} value
	 * @param {Boolean} literal Whether value should be treated as a literal (true) or a resource
	 *     (false)
	 */
	"addStatement":function(about, relation, value, literal) {
		if(about === null || about === undefined) {
			throw new Error("about must be defined in Zotero.RDF.addStatement");
		}
		if(relation === null || relation === undefined) {
			throw new Error("relation must be defined in Zotero.RDF.addStatement");
		}
		if(value === null || value === undefined) {
			throw new Error("value must be defined in Zotero.RDF.addStatement");
		}

		if(literal) {
			// zap chars that Mozilla will mangle
			value = value.toString().replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
		} else {
			value = this._getResource(value);
		}

		this._dataStore.add(this._getResource(about), this._getResource(relation), value);
	},

	/**
	 * Creates a new anonymous resource
	 * @return {Zotero.RDF.AJAW.Symbol}
	 */
	"newResource":function() {
		return new Zotero.RDF.AJAW.BlankNode();
	},

	/**
	 * Creates a new container resource
	 * @param {String} type The type of the container ("bag", "seq", or "alt")
	 * @param {String|Zotero.RDF.AJAW.Symbol} about The URI of the resource
	 * @return {Zotero.Translate.RDF.prototype.newContainer
	 */
	"newContainer":function(type, about) {
		const rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
		const containerTypes = {"bag":"Bag", "seq":"Seq", "alt":"Alt"};

		type = type.toLowerCase();
		if(!containerTypes[type]) {
			throw new Error("Invalid container type in Zotero.RDF.newContainer");
		}

		var about = this._getResource(about);
		this.addStatement(about, rdf+"type", rdf+containerTypes[type], false);
		this._containerCounts[about.toNT()] = 1;

		return about;
	},

	/**
	 * Adds a new element to a container
	 * @param {String|Zotero.RDF.AJAW.Symbol} about The container
	 * @param {String|Zotero.RDF.AJAW.Symbol} element The element to add to the container
	 * @param {Boolean} literal Whether element should be treated as a literal (true) or a resource
	 *     (false)
	 */
	"addContainerElement":function(about, element, literal) {
		const rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";

		var about = this._getResource(about);
		this._dataStore.add(about, new Zotero.RDF.AJAW.Symbol(rdf+"_"+(this._containerCounts[about.toNT()]++)), element, literal);
	},

	/**
	 * Gets all elements within a container
	 * @param {String|Zotero.RDF.AJAW.Symbol} about The container
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 */
	"getContainerElements":function(about) {
		const liPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#_";

		var about = this._getResource(about);
		var statements = this._dataStore.statementsMatching(about);
		var containerElements = [];

		// loop over arcs out looking for list items
		for(var i=0; i<statements.length; i++) {
			var statement = statements[i];
			if(statement.predicate.uri.substr(0, liPrefix.length) == liPrefix) {
				var number = statement.predicate.uri.substr(liPrefix.length);

				// make sure these are actually numeric list items
				var intNumber = parseInt(number);
				if(number == intNumber.toString()) {
					// add to element array
					containerElements[intNumber-1] = (statement.object.termType == "literal" ? statement.object.toString() : statement.object);
				}
			}
		}

		return containerElements;
	},

	/**
	 * Adds a namespace for a specific URI
	 * @param {String} prefix Namespace prefix
	 * @param {String} uri Namespace URI
	 */
	"addNamespace":function(prefix, uri) {
		this._dataStore.setPrefixForURI(prefix, uri);
	},

	/**
	 * Gets the URI a specific resource
	 * @param {String|Zotero.RDF.AJAW.Symbol} resource
	 * @return {String}
	 */
	"getResourceURI":function(resource) {
		if(typeof(resource) == "string") return resource;

		const rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
		var values = this.getTargets(resource, rdf + 'value');
		if(values && values.length) return this.getResourceURI(values[0]);

		if(resource.uri) return resource.uri;
		if(resource.toNT == undefined) throw new Error("Zotero.RDF: getResourceURI called on invalid resource");
		return resource.toNT();
	},

	/**
	 * Gets all resources in the RDF data store
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 */
	"getAllResources":function() {
		var returnArray = [];
		for(var i in this._dataStore.subjectIndex) {
			returnArray.push(this._dataStore.subjectIndex[i][0].subject);
		}
		return returnArray;
	},

	/**
	 * Gets all arcs (predicates) into a resource
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 * @deprecated Since 2.1. Use {@link Zotero.Translate.IO["rdf"]._RDFBase#getStatementsMatching}
	 */
	"getArcsIn":function(resource) {
		var statements = this._dataStore.objectIndex[this._dataStore.canon(this._getResource(resource))];
		if(!statements) return false;

		var returnArray = [];
		for(var i=0; i<statements.length; i++) {
			returnArray.push(statements[i].predicate.uri);
		}
		return returnArray;
	},

	/**
	 * Gets all arcs (predicates) out of a resource
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 * @deprecated Since 2.1. Use {@link Zotero.Translate.IO["rdf"]._RDFBase#getStatementsMatching}
	 */
	"getArcsOut":function(resource) {
		var statements = this._dataStore.subjectIndex[this._dataStore.canon(this._getResource(resource))];
		if(!statements) return false;

		var returnArray = [];
		for(var i=0; i<statements.length; i++) {
			returnArray.push(statements[i].predicate.uri);
		}
		return returnArray;
	},

	/**
	 * Gets all subjects whose predicates point to a resource
	 * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject that predicates should point to
	 * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 * @deprecated Since 2.1. Use {@link Zotero.Translate.IO["rdf"]._RDFBase#getStatementsMatching}
	 */
	"getSources":function(resource, property) {
		var statements = this._dataStore.statementsMatching(undefined, this._getResource(property), this._getResource(resource));
		if(!statements.length) return false;

		var returnArray = [];
		for(var i=0; i<statements.length; i++) {
			returnArray.push(statements[i].subject);
		}
		return returnArray;
	},

	/**
	 * Gets all objects of a given subject with a given predicate
	 * @param {String|Zotero.RDF.AJAW.Symbol} resource Subject
	 * @param {String|Zotero.RDF.AJAW.Symbol} property Predicate
	 * @return {Zotero.RDF.AJAW.Symbol[]}
	 * @deprecated Since 2.1. Use {@link Zotero.Translate.IO["rdf"]._RDFBase#getStatementsMatching}
	 */
	"getTargets":function(resource, property) {
		var statements = this._dataStore.statementsMatching(this._getResource(resource), this._getResource(property));
		if(!statements.length) return false;

		var returnArray = [];
		for(var i=0; i<statements.length; i++) {
			returnArray.push(statements[i].object.termType == "literal" ? statements[i].object.toString() : statements[i].object);
		}
		return returnArray;
	},

	/**
	 * Gets statements matching a certain pattern
	 *
	 * @param	{String|Zotero.RDF.AJAW.Symbol}	subj 		Subject
	 * @param	{String|Zotero.RDF.AJAW.Symbol}	predicate	Predicate
	 * @param	{String|Zotero.RDF.AJAW.Symbol}	obj			Object
	 * @param	{Boolean}							objLiteral	Whether the object is a literal (as
	 *															opposed to a URI)
	 * @param	{Boolean}							justOne		Whether to stop when a single result is
	 *															retrieved
	 */
	"getStatementsMatching":function(subj, pred, obj, objLiteral, justOne) {
		var statements = this._dataStore.statementsMatching(
			(subj ? this._getResource(subj) : undefined),
			(pred ? this._getResource(pred) : undefined),
			(obj ? (objLiteral ? objLiteral : this._getResource(obj)) : undefined),
			undefined, justOne);
		if(!statements.length) return false;


		var returnArray = [];
		for(var i=0; i<statements.length; i++) {
			returnArray.push([statements[i].subject, statements[i].predicate, (statements[i].object.termType == "literal" ? statements[i].object.toString() : statements[i].object)]);
		}
		return returnArray;
	}
};
/******** END translate.js ********/
/******** BEGIN translate_item.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2012 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

Zotero.Translate.ItemSaver = function(libraryID, attachmentMode, forceTagType, document,
		cookieSandbox) {
	this.newItems = [];
	this._timeoutID = null;

	if(document) {
		this._uri = document.location.toString();
		this._cookie = document.cookie;
	}

	// Add listener for callbacks, but only for Safari or the bookmarklet. In Chrome, we
	// (have to) save attachments from the inject page.
	if(Zotero.Messaging && !Zotero.Translate.ItemSaver._attachmentCallbackListenerAdded
			&& (Zotero.isBookmarklet || Zotero.isSafari)) {
		Zotero.Messaging.addMessageListener("attachmentCallback", function(data) {
			var id = data[0],
				status = data[1];
			 var callback = Zotero.Translate.ItemSaver._attachmentCallbacks[id];
			 if(callback) {
				if(status === false || status === 100) {
					delete Zotero.Translate.ItemSaver._attachmentCallbacks[id];
				} else {
					data[1] = 50+data[1]/2;
				}
				callback(data[1], data[2]);
			 }
		});
		Zotero.Translate.ItemSaver._attachmentCallbackListenerAdded = true;
	}
}
Zotero.Translate.ItemSaver._attachmentCallbackListenerAdded = false;
Zotero.Translate.ItemSaver._attachmentCallbacks = {};

Zotero.Translate.ItemSaver.ATTACHMENT_MODE_IGNORE = 0;
Zotero.Translate.ItemSaver.ATTACHMENT_MODE_DOWNLOAD = 1;
Zotero.Translate.ItemSaver.ATTACHMENT_MODE_FILE = 2;

Zotero.Translate.ItemSaver.prototype = {
	/**
	 * Saves items to Standalone or the server
	 * @param items Items in Zotero.Item.toArray() format
	 * @param {Function} callback A callback to be executed when saving is complete. If saving
	 *    succeeded, this callback will be passed true as the first argument and a list of items
	 *    saved as the second. If saving failed, the callback will be passed false as the first
	 *    argument and an error object as the second
	 * @param {Function} [attachmentCallback] A callback that receives information about attachment
	 *     save progress. The callback will be called as attachmentCallback(attachment, false, error)
	 *     on failure or attachmentCallback(attachment, progressPercent) periodically during saving.
	 */
	"saveItems":function(items, callback, attachmentCallback) {
		this._saveToServer(items, callback, attachmentCallback);
	},

	/**
	 * Polls for updates to attachment progress
	 * @param items Items in Zotero.Item.toArray() format
	 * @param {Function} attachmentCallback A callback that receives information about attachment
	 *     save progress. The callback will be called as attachmentCallback(attachment, false, error)
	 *     on failure or attachmentCallback(attachment, progressPercent) periodically during saving.
	 *     attachmentCallback() will be called with all attachments that will be saved
	 */
	"_pollForProgress":function(items, attachmentCallback) {
		var attachments = [];
		var progressIDs = [];
		var previousStatus = [];
		for(var i=0; i<items.length; i++) {
			var itemAttachments = items[i].attachments;
			for(var j=0; j<itemAttachments.length; j++) {
				if(itemAttachments[j].id) {
					attachments.push(itemAttachments[j]);
					progressIDs.push(itemAttachments[j].id);
					previousStatus.push(0);
				}
			}
		}

		var nPolls = 0;
		var poll = function() {
			Zotero.Connector.callMethod("attachmentProgress", progressIDs, function(currentStatus, status) {
				if(currentStatus) {
					for(var i=0; i<attachments.length; i++) {
						if(currentStatus[i] === 100 || currentStatus[i] === false) {
							attachmentCallback(attachments[i], currentStatus[i]);
							attachments.splice(i, 1);
							progressIDs.splice(i, 1);
							previousStatus.splice(i, 1);
							currentStatus.splice(i, 1);
							i--;
						} else if(currentStatus[i] !== previousStatus[i]) {
							attachmentCallback(attachments[i], currentStatus[i]);
							previousStatus[i] = currentStatus[i];
						}
					}

					if(nPolls++ < 60 && attachments.length) {
						setTimeout(poll, 1000);
					}
				} else {
					for(var i=0; i<attachments.length; i++) {
						attachmentCallback(attachments[i], false, "Lost connection to Zotero Standalone");
					}
				}
			});
		};
		poll();
	},

	// ALL CODE BELOW THIS POINT IS EXECUTED ONLY IN NON-FIREFOX ENVIRONMENTS

	/**
	 * Saves items to server
	 * @param items Items in Zotero.Item.toArray() format
	 * @param {Function} callback A callback to be executed when saving is complete. If saving
	 *    succeeded, this callback will be passed true as the first argument and a list of items
	 *    saved as the second. If saving failed, the callback will be passed false as the first
	 *    argument and an error object as the second
	 * @param {Function} attachmentCallback A callback that receives information about attachment
	 *     save progress. The callback will be called as attachmentCallback(attachment, false, error)
	 *     on failure or attachmentCallback(attachment, progressPercent) periodically during saving.
	 *     attachmentCallback() will be called with all attachments that will be saved
	 */
	"_saveToServer":function(items, callback, attachmentCallback) {

		var newItems = [], itemIndices = [], typedArraysSupported = false;
		try {
			typedArraysSupported = !!(new Uint8Array(1) && new Blob());
		} catch(e) {}

		for(var i=0, n=items.length; i<n; i++) {
			var item = items[i];
			itemIndices[i] = newItems.length;
			newItems = newItems.concat(Zotero.Utilities.itemToServerJSON(item));
			if(typedArraysSupported) {
				for(var j=0; j<item.attachments.length; j++) {
					item.attachments[j].id = Zotero.Utilities.randomString();
				}
			} else {
				item.attachments = [];
			}
		}

		var me = this;
		Zotero.API.createItem({"items":newItems}, function(statusCode, response) {
			if(statusCode !== 200) {
				callback(false, new Error("Save to server failed with "+statusCode+" "+response));
				return;
			}

			try {
				var resp = JSON.parse(response);
			} catch(e) {
				callback(false, new Error("Unexpected response received from server"));
				return;
			}
			for(var i in resp.failed) {
				callback(false, new Error("Save to server failed with "+statusCode+" "+response));
				return;
			}

			Zotero.debug("Translate: Save to server complete");
			Zotero.Prefs.getCallback(["downloadAssociatedFiles", "automaticSnapshots"],
			function(prefs) {

				if(typedArraysSupported) {
					for(var i=0; i<items.length; i++) {
						var item = items[i], key = resp.success[itemIndices[i]];
						if(item.attachments && item.attachments.length) {
							me._saveAttachmentsToServer(key, me._getFileBaseNameFromItem(item),
								item.attachments, prefs, attachmentCallback);
						}
					}
				}

				callback(true, items);
			});
		});
	},

	/**
	 * Saves an attachment to server
	 * @param {Object[]} attachments An array of attachment objects
	 * @param {Object} prefs An object with the values of the downloadAssociatedFiles and automaticSnapshots preferences
	 * @param {Function} attachmentCallback A callback that receives information about attachment
	 *     save progress. The callback will be called as attachmentCallback(attachment, false, error)
	 *     on failure or attachmentCallback(attachment, progressPercent) periodically during saving.
	 */
	"_saveAttachmentsToServer":function(attachments, prefs, attachmentCallback) {
		Zotero.debug("saveattachmentstoserver");
		var me = this,
			uploadAttachments = [],
			retrieveHeadersForAttachments = attachments.length;

		/**
		 * Creates attachments on the z.org server. This is executed after we have received
		 * headers for all attachments to be downloaded, but before they are uploaded to
		 * z.org.
		 * @inner
		 */
		var createAttachments = function() {
			if(uploadAttachments.length === 0) return;

				for(var i=0; i<uploadAttachments.length; i++) {
					var attachment = uploadAttachments[i];
					if(attachment.linkMode === "linked_url") {
						attachmentCallback(attachment, 100);
					} else if("data" in attachment) {
						me._uploadAttachmentToServer(attachment, attachmentCallback);
					}
				}
		};

		for(var i=0; i<attachments.length; i++) {
			// Also begin to download attachments
			(function(attachment) {
				var headersValidated = null;

				var isSnapshot = false;
				if(attachment.mimeType) {
					switch(attachment.mimeType.toLowerCase()) {
						case "text/html":
						case "application/xhtml+xml":
							isSnapshot = true;
					}
				}

				if((isSnapshot && !prefs.automaticSnapshots) || (!isSnapshot && !prefs.downloadAssociatedFiles)) {
					// Check preferences to see if we should download this file
					if(--retrieveHeadersForAttachments === 0) createAttachments();
					return;
				} else if(attachment.snapshot === false && attachment.mimeType) {
					// If we aren't taking a snapshot and we have the MIME type, we don't need
					// to retrieve anything
					attachment.linkMode = "linked_url";
					uploadAttachments.push(attachment);
					if(attachmentCallback) attachmentCallback(attachment, 0);
					if(--retrieveHeadersForAttachments === 0) createAttachments();
					return;
				}

				/**
				 * Checks headers to ensure that they reflect our expectations. When headers have
				 * been checked for all attachments, creates new items on the z.org server and
				 * begins uploading them.
				 * @inner
				 */
				var checkHeaders = function() {
					if(headersValidated !== null) return headersValidated;

					retrieveHeadersForAttachments--;
					headersValidated = false;

					var err = null,
						status = xhr.status;

					// Validate status
					if(status === 0 || attachment.snapshot === false) {
						// Failed due to SOP, or we are supposed to be getting a snapshot
						attachment.linkMode = "linked_url";
					} else if(status !== 200) {
						err = new Error("Server returned unexpected status code "+status);
					} else {
						// Validate content type
						var contentType = "application/octet-stream",
							charset = null,
							contentTypeHeader = xhr.getResponseHeader("Content-Type");
						if(contentTypeHeader) {
							// See RFC 2616 sec 3.7
							var m = /^[^\x00-\x1F\x7F()<>@,;:\\"\/\[\]?={} ]+\/[^\x00-\x1F\x7F()<>@,;:\\"\/\[\]?={} ]+/.exec(contentTypeHeader);
							if(m) contentType = m[0].toLowerCase();
							m = /;\s*charset\s*=\s*("[^"]+"|[^\x00-\x1F\x7F()<>@,;:\\"\/\[\]?={} ]+)/.exec(contentTypeHeader);
							if(m) {
								charset = m[1];
								if(charset[0] === '"') charset = charset.substring(1, charset.length-1);
							}

							if(attachment.mimeType
									&& attachment.mimeType.toLowerCase() !== contentType.toLowerCase()) {
								err = new Error("Attachment MIME type "+contentType+
									" does not match specified type "+attachment.mimeType);
							}
						}

						if(!err) {
							attachment.mimeType = contentType;
							attachment.linkMode = "imported_url";
							if(charset) attachment.charset = charset;
							headersValidated = true;
						}
					}

					// If we didn't validate the headers, cancel the request
					if(headersValidated === false && "abort" in xhr) xhr.abort();

					// Add attachments to attachment payload if there was no error
					if(!err) {
						uploadAttachments.push(attachment);
					}

					// If we have retrieved the headers for all attachments, create items on z.org
					// server
					if(retrieveHeadersForAttachments === 0) createAttachments();

					// If there was an error, throw it now
					if(err) {
						attachmentCallback(attachment, false, err);
						Zotero.logError(err);
					}
					return headersValidated;
				};

				var xhr = new XMLHttpRequest();
				var url = attachment.url.replace(/^https*:\/\//, "//");	// Try getting the attachment using the protocol of the page (it still might fail but at least it will be caught by onerror)
				xhr.open((attachment.snapshot === false ? "HEAD" : "GET"), url, true);
				xhr.responseType = (isSnapshot ? "document" : "arraybuffer");
				xhr.onreadystatechange = function() {
					if(xhr.readyState !== 4 || !checkHeaders()) return;

					attachmentCallback(attachment, 50);
					attachment.data = xhr.response;
					// If item already created, head to upload
					if("key" in attachment) {
						me._uploadAttachmentToServer(attachment, attachmentCallback);
					}
				};
				xhr.onprogress = function(event) {
					if(xhr.readyState < 2 || !checkHeaders()) return;

					if(event.total && attachmentCallback) {
						attachmentCallback(attachment, event.loaded/event.total*50);
					}
				};
				xhr.onerror = function(event) {
					if(attachmentCallback) {
						attachmentCallback(attachment, 0, {"status": event.target.status});
					}
				};

				xhr.send();

				if(attachmentCallback) attachmentCallback(attachment, 0);
			})(attachments[i]);
		}
	},

	/**
	 * Uploads an attachment to the Zotero server
	 * @param {Object} attachment Attachment object, including
	 * @param {Function} attachmentCallback A callback that receives information about attachment
	 *     save progress. The callback will be called as attachmentCallback(attachment, false, error)
	 *     on failure or attachmentCallback(attachment, progressPercent) periodically during saving.
	 */
	"_uploadAttachmentToServer":function(attachment, attachmentCallback) {
		Zotero.debug("Uploading attachment to server");
		switch(attachment.mimeType.toLowerCase()) {
			case "text/html":
			case "application/xhtml+xml":
				// It's possible that we didn't know if this was a snapshot until after the
				// download began. If this is the case, we need to convert it to a document.
				if(attachment.data instanceof ArrayBuffer) {
					var me = this,
						blob = new Blob([attachment.data], {"type":attachment.mimeType}),
						reader = new FileReader();
					reader.onloadend = function() {
						if(reader.error) {
							attachmentCallback(attachment, false, reader.error);
						} else {
							// Convert to an HTML document
							var result = reader.result, doc;
							try {
								// First try using DOMParser
								doc = (new DOMParser()).parseFromString(result, "text/html");
							} catch(e) {}

							// If DOMParser fails, use document.implementation.createHTMLDocument,
							// as documented at https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
							if(!doc) {
								doc = document.implementation.createHTMLDocument("");
								var docEl = doc.documentElement;
								// AMO reviewer: This code is not run in Firefox, and the document
								// is never rendered anyway
								docEl.innerHTML = result;
								if(docEl.children.length === 1 && docEl.firstElementChild === "html") {
									doc.replaceChild(docEl.firstElementChild, docEl);
								}
							}

							attachment.data = doc;
							me._uploadAttachmentToServer(attachment, attachmentCallback);
						}
					}
					reader.readAsText(blob, attachment.charset || "iso-8859-1");
					return;
				}

				// We are now assured that attachment.data is an HTMLDocument, so we can
				// add a base tag

				// Get the head tag
				var doc = attachment.data,
					head = doc.getElementsByTagName("head");
				if(!head.length) {
					head = doc.createElement("head");
					var docEl = attachment.data.documentElement;
					docEl.insertBefore(head, docEl.firstChildElement);
				} else {
					head = head[0];
				}

				// Add the base tag
				var base = doc.createElement("base");
				base.href = attachment.url;
				head.appendChild(base);

				// Remove content type tags
				var metaTags = doc.getElementsByTagName("meta"), metaTag;
				for(var i=0; i<metaTags.length; i++) {
					metaTag = metaTags[i];
					var attr = metaTag.getAttribute("http-equiv");
					if(attr && attr.toLowerCase() === "content-type") {
						metaTag.parentNode.removeChild(metaTag);
					}
				}

				// Add UTF-8 content type
				metaTag = doc.createElement("meta");
				metaTag.setAttribute("http-equiv", "Content-Type");
				metaTag.setAttribute("content", attachment.mimeType+"; charset=UTF-8");
				head.insertBefore(metaTag, head.firstChild);

				// Serialize document to UTF-8
				var src = new XMLSerializer().serializeToString(doc),
					srcLength = Zotero.Utilities.getStringByteLength(src),
					srcArray = new Uint8Array(srcLength);
				Zotero.Utilities.stringToUTF8Array(src, srcArray);

				// Rewrite data
				attachment.data = srcArray.buffer;
				attachment.charset = "UTF-8";
			break;
		}

		var binaryHash = this._md5(new Uint8Array(attachment.data), 0, attachment.data.byteLength),
			hash = "";
		for(var i=0; i<binaryHash.length; i++) {
			if(binaryHash[i] < 16) hash += "0";
			hash += binaryHash[i].toString(16);
		}
		attachment.md5 = hash;

		if(Zotero.isChrome && !Zotero.isBookmarklet) {
			// In Chrome, we don't use messaging for Zotero.API.uploadAttachment, since
			// we can't pass ArrayBuffers to the background page
			Zotero.API.uploadAttachment(attachment, attachmentCallback.bind(this, attachment));
		} else {
			// In Safari and the connectors, we can pass ArrayBuffers
			Zotero.Translate.ItemSaver._attachmentCallbacks[attachment.id] = function(status, error) {
				attachmentCallback(attachment, status, error);
			};
			Zotero.API.uploadAttachment(attachment);
		}
	},

	"notifyAttachmentProgress": function(attachment, progressPercent, error) {
		Zotero.API.notifyAttachmentProgress({attachment:attachment, progressPercent: progressPercent, error: error});
		//TODO: Make progress in savetorefworks app reflect real progress
		//console.log(attachment);
		//console.log(progressPercent);
		//console.log(error);
	},

	/**
	 * Gets the base name for an attachment from an item object. This mimics the default behavior
	 * of Zotero.Attachments.getFileBaseNameFromItem
	 * @param {Object} item
	 */
	"_getFileBaseNameFromItem":function(item) {
		var parts = [];
		if(item.creators && item.creators.length) {
			if(item.creators.length === 1) {
				parts.push(item.creators[0].lastName);
			} else if(item.creators.length === 2) {
				parts.push(item.creators[0].lastName+" and "+item.creators[1].lastName);
			} else {
				parts.push(item.creators[0].lastName+" et al.");
			}
		}

		if(item.date) {
			var date = Zotero.Date.strToDate(item.date);
			if(date.year) parts.push(date.year);
		}

		if(item.title) {
			parts.push(item.title.substr(0, 50));
		}

		if(parts.length) return parts.join(" - ");
		return "Attachment";
	},

	/*
	  pdf.js MD5 implementation
	  Copyright (c) 2011 Mozilla Foundation

	  Contributors: Andreas Gal <gal@mozilla.com>
	                Chris G Jones <cjones@mozilla.com>
	                Shaon Barman <shaon.barman@gmail.com>
	                Vivien Nicolas <21@vingtetun.org>
	                Justin D'Arcangelo <justindarc@gmail.com>
	                Yury Delendik
	                Kalervo Kujala
	                Adil Allawi <@ironymark>
	                Jakob Miland <saebekassebil@gmail.com>
	                Artur Adib <aadib@mozilla.com>
	                Brendan Dahl <bdahl@mozilla.com>
	                David Quintana <gigaherz@gmail.com>

	  Permission is hereby granted, free of charge, to any person obtaining a
	  copy of this software and associated documentation files (the "Software"),
	  to deal in the Software without restriction, including without limitation
	  the rights to use, copy, modify, merge, publish, distribute, sublicense,
	  and/or sell copies of the Software, and to permit persons to whom the
	  Software is furnished to do so, subject to the following conditions:

	  The above copyright notice and this permission notice shall be included in
	  all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	  DEALINGS IN THE SOFTWARE.
	*/
	"_md5":(function calculateMD5Closure() {
		// Don't throw if typed arrays are not supported
		try {
			var r = new Uint8Array([
				7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
				5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
				4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
				6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);

			var k = new Int32Array([
				-680876936, -389564586, 606105819, -1044525330, -176418897, 1200080426,
				-1473231341, -45705983, 1770035416, -1958414417, -42063, -1990404162,
				1804603682, -40341101, -1502002290, 1236535329, -165796510, -1069501632,
				643717713, -373897302, -701558691, 38016083, -660478335, -405537848,
				568446438, -1019803690, -187363961, 1163531501, -1444681467, -51403784,
				1735328473, -1926607734, -378558, -2022574463, 1839030562, -35309556,
				-1530992060, 1272893353, -155497632, -1094730640, 681279174, -358537222,
				-722521979, 76029189, -640364487, -421815835, 530742520, -995338651,
				-198630844, 1126891415, -1416354905, -57434055, 1700485571, -1894986606,
				-1051523, -2054922799, 1873313359, -30611744, -1560198380, 1309151649,
				-145523070, -1120210379, 718787259, -343485551]);
		} catch(e) {};

		function hash(data, offset, length) {
			var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
			// pre-processing
			var paddedLength = (length + 72) & ~63; // data + 9 extra bytes
			var padded = new Uint8Array(paddedLength);
			var i, j, n;
			if (offset || length != data.byteLength) {
				padded.set(new Uint8Array(data.buffer, offset, length));
			} else {
				padded.set(data);
			}
			i = length;
			padded[i++] = 0x80;
			n = paddedLength - 8;
			while (i < n)
				padded[i++] = 0;
			padded[i++] = (length << 3) & 0xFF;
			padded[i++] = (length >> 5) & 0xFF;
			padded[i++] = (length >> 13) & 0xFF;
			padded[i++] = (length >> 21) & 0xFF;
			padded[i++] = (length >>> 29) & 0xFF;
			padded[i++] = 0;
			padded[i++] = 0;
			padded[i++] = 0;
			// chunking
			// TODO ArrayBuffer ?
			var w = new Int32Array(16);
			for (i = 0; i < paddedLength;) {
				for (j = 0; j < 16; ++j, i += 4) {
					w[j] = (padded[i] | (padded[i + 1] << 8) |
						   (padded[i + 2] << 16) | (padded[i + 3] << 24));
				}
				var a = h0, b = h1, c = h2, d = h3, f, g;
				for (j = 0; j < 64; ++j) {
					if (j < 16) {
						f = (b & c) | ((~b) & d);
						g = j;
					} else if (j < 32) {
						f = (d & b) | ((~d) & c);
						g = (5 * j + 1) & 15;
					} else if (j < 48) {
						f = b ^ c ^ d;
						g = (3 * j + 5) & 15;
					} else {
						f = c ^ (b | (~d));
						g = (7 * j) & 15;
					}
					var tmp = d, rotateArg = (a + f + k[j] + w[g]) | 0, rotate = r[j];
					d = c;
					c = b;
					b = (b + ((rotateArg << rotate) | (rotateArg >>> (32 - rotate)))) | 0;
					a = tmp;
				}
				h0 = (h0 + a) | 0;
				h1 = (h1 + b) | 0;
				h2 = (h2 + c) | 0;
				h3 = (h3 + d) | 0;
			}
			return new Uint8Array([
					h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >>> 24) & 0xFF,
					h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >>> 24) & 0xFF,
					h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >>> 24) & 0xFF,
					h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >>> 24) & 0xFF
			]);
		}
		return hash;
	})()
};
/******** END translate_item.js ********/
/******** BEGIN translate_inject.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

/**
 * @class Manages the translator sandbox
 * @param {Zotero.Translate} translate
 * @param {String|window} sandboxLocation
 */
Zotero.Translate.SandboxManager = function(sandboxLocation) {
	this.sandbox = {"Zotero":{}};
}

Zotero.Translate.SandboxManager.prototype = {
	/**
	 * Evaluates code in the sandbox
	 * @param {String} code Code to evaluate
	 * @param {String[]} functions Functions to import into the sandbox (rather than leaving
	 *                                 as inner functions)
	 */
	"eval":function(code, functions) {
		// delete functions to import
		for(var i in functions) {
			delete this.sandbox[functions[i]];
		}

		// eval in sandbox scope
		with(this.sandbox) {
			eval(code);
		}
		// import inner functions (what a mess)
		for(var i in functions) {
			try {
				this.sandbox[functions[i]] = eval(functions[i]);
			} catch(e) {}
		}
	},

	/**
	 * Imports an object into the sandbox
	 *
	 * @param {Object} object Object to be imported (under Zotero)
	 * @param {Boolean} passTranslateAsFirstArgument Whether the translate instance should be passed
	 *     as the first argument to the function.
	 */
	"importObject":function(object, passAsFirstArgument, attachTo) {
		if(!attachTo) attachTo = this.sandbox.Zotero;

		for(var key in (object.__exposedProps__ ? object.__exposedProps__ : object)) {
			if(Function.prototype[key]) continue;
			if(typeof object[key] === "function" || typeof object[key] === "object") {
				// magic closures
				attachTo[key] = new function() {
					var fn = object[key];
					return function() {
						var args = (passAsFirstArgument ? [passAsFirstArgument] : []);
						for(var i=0; i<arguments.length; i++) {
							args.push(arguments[i]);
						}

						return fn.apply(object, args);
					};
				}

				// attach members
				this.importObject(object[key], passAsFirstArgument ? passAsFirstArgument : null, attachTo[key]);
			} else {
				attachTo[key] = object[key];
			}
		}
	}
}
/******** END translate_inject.js ********/
/******** BEGIN translator.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

Zotero.Translators = {
	/**
	 * Add proper to proxy converter function to translator data sent back via IPC for
	 * Zotero.Translators.getWebTranslatorsForLocation
	 */
	"getConverterFunctions":function(converterDataArray) {
		var converterFunctions = new Array(converterDataArray.length);
		for(var i=0; i<converterDataArray.length; i++) {
			if(converterDataArray[i] === null) {
				converterFunctions[i] = null;
			} else {
				converterFunctions[i] = new function() {
					var re = new RegExp('^https?://(?:[^/]\\.)?'+Zotero.Utilities.quotemeta(converterDataArray[i][0]) + '(?=/)', "gi");
					var proxyHost = converterDataArray[i][1].replace(/\$/g, "$$$$");
					return function(uri) { return uri.replace(re, "$&."+proxyHost) };
				};
			}
		}
		return converterFunctions;
	}
}

Zotero.Translator = function() {};
Zotero.Translator.RUN_MODE_IN_BROWSER = 1;
Zotero.Translator.RUN_MODE_ZOTERO_STANDALONE = 2;
Zotero.Translator.RUN_MODE_ZOTERO_SERVER = 4;
/******** END translator.js ********/
/******** BEGIN typeSchemaData.js ********/
Zotero.Connector_Types.schema = {"itemTypes":{"1":["note","Note",[false],[],{},"treeitem-note.png"],"2":["book","Book",[1,2,3,5,4],[110,90,3,30,4,45,6,7,8,14,118,87,11,116,1,27,123,19,62,18,2,22],{},"treeitem-book.png"],"3":["bookSection","Book Section",[1,29,2,3,5,4],[110,90,115,3,30,4,45,6,7,8,14,10,87,11,116,1,27,123,19,62,18,2,22],{"115":12},"treeitem-bookSection.png"],"4":["journalArticle","Journal Article",[1,2,3,27,4],[110,90,12,4,5,10,14,3,28,29,25,87,26,13,116,1,27,123,19,62,18,2,22],{},"treeitem-journalArticle.png"],"5":["magazineArticle","Magazine Article",[1,2,27,4],[110,90,12,4,5,14,10,87,13,116,1,27,123,19,62,18,2,22],{},"treeitem-magazineArticle.png"],"6":["newspaperArticle","Newspaper Article",[1,2,27,4],[110,90,12,7,6,14,15,10,87,116,13,1,27,123,19,62,18,2,22],{},"treeitem-newspaperArticle.png"],"7":["thesis","Thesis",[1,2],[110,90,69,89,7,14,118,87,116,1,27,123,19,62,18,2,22],{"69":108,"89":8},"treeitem-thesis.png"],"8":["letter","Letter",[1,2,16],[110,90,65,14,87,116,1,27,123,19,62,18,2,22],{"65":108},"treeitem-letter.png"],"9":["manuscript","Manuscript",[1,2,4],[110,90,66,7,14,118,87,116,1,27,123,19,62,18,2,22],{"66":108},"treeitem-manuscript.png"],"10":["interview","Interview",[6,2,7,4],[110,90,14,64,87,116,1,27,123,19,62,18,2,22],{"64":109},"treeitem-interview.png"],"11":["film","Film",[8,2,10,9],[110,90,21,14,122,63,77,87,116,1,27,123,19,62,18,2,22],{"21":8,"122":108,"63":109},"treeitem-film.png"],"12":["artwork","Artwork",[22,2],[110,90,59,61,14,87,116,123,19,62,18,1,27,2,22],{"59":109},"treeitem-artwork.png"],"13":["webpage","Web Page",[1,2,4],[110,90,91,70,14,116,1,27,87,2,22],{"91":12,"70":108},"treeitem-webpage.png"],"14":["attachment","Attachment",[false],[110,27,1],{},"treeitem.png"],"15":["report","Report",[1,2,5,4],[110,90,92,32,28,7,31,14,10,87,116,1,27,123,19,62,18,2,22],{"92":60,"32":108,"31":8},"treeitem-report.png"],"16":["bill","Bill",[12,2,28],[110,90,93,36,94,15,95,41,40,42,14,87,1,27,116,2,22],{"93":60,"94":4,"95":10},"treeitem-bill.png"],"17":["case","Case",[1,2,13],[111,90,43,97,44,117,98,42,96,87,116,1,27,2,22],{"111":110,"97":4,"117":60,"98":10,"96":14},"treeitem-case.png"],"18":["hearing","Hearing",[2],[110,90,46,7,8,45,99,10,41,40,42,14,87,116,1,27,2,22],{"99":60},"treeitem-hearing.png"],"19":["patent","Patent",[14,15,2],[110,90,7,102,48,120,50,121,10,103,51,52,53,54,87,116,1,27,2,22],{"50":60,"52":14},"treeitem-patent.png"],"20":["statute","Statute",[1,2],[112,90,36,55,101,100,10,15,40,42,87,116,1,27,2,22],{"112":110,"101":60,"100":14},"treeitem-statute.png"],"21":["email","E-mail",[1,2,16],[113,90,14,116,1,27,87,2,22],{"113":110},"treeitem-email.png"],"22":["map","Map",[20,2,5],[110,90,67,68,28,6,7,8,14,87,11,116,1,27,123,19,62,18,2,22],{"67":108},"treeitem-map.png"],"23":["blogPost","Blog Post",[1,23,2],[110,90,107,70,14,1,27,87,116,2,22],{"107":12,"70":108},"treeitem-blogPost.png"],"24":["instantMessage","Instant Message",[1,2,16],[110,90,14,87,116,1,27,2,22],{},"treeitem-instantMessage.png"],"25":["forumPost","Forum Post",[1,2],[110,90,104,79,14,87,116,1,27,2,22],{"104":12,"79":108},"treeitem-forumPost.png"],"26":["audioRecording","Audio Recording",[17,18,2,19],[110,90,71,28,4,45,7,72,14,77,87,11,116,123,19,62,18,1,27,2,22],{"71":109,"72":8},"treeitem-audioRecording.png"],"27":["presentation","Presentation",[24,2],[110,90,74,14,7,75,1,27,87,116,2,22],{"74":108},"treeitem-presentation.png"],"28":["videoRecording","Video Recording",[8,11,2,10,9],[110,90,63,28,4,45,7,76,14,77,87,11,116,1,27,123,19,62,18,2,22],{"63":109,"76":8},"treeitem-videoRecording.png"],"29":["tvBroadcast","TV Broadcast",[8,11,2,25,10,9],[110,90,119,105,63,7,78,14,77,87,116,1,27,123,19,62,18,2,22],{"119":12,"105":60,"63":109,"78":8},"treeitem-tvBroadcast.png"],"30":["radioBroadcast","Radio Broadcast",[8,11,2,25,10,9],[110,90,119,105,71,7,78,14,77,87,116,1,27,123,19,62,18,2,22],{"119":12,"105":60,"71":109,"78":8},"treeitem-radioBroadcast.png"],"31":["podcast","Podcast",[26,2,25],[110,90,28,105,80,77,1,27,87,116,2,22],{"105":60,"80":109},"treeitem-podcast.png"],"32":["computerProgram","Computer Program",[21,2],[110,90,28,81,14,82,7,83,88,11,116,1,2,123,19,62,18,27,22],{"83":8},"treeitem-computerProgram.png"],"33":["conferencePaper","Conference Paper",[1,2,3,5,4],[110,90,14,114,84,7,8,4,10,3,87,26,11,116,1,27,123,19,62,18,2,22],{"114":12},"treeitem-conferencePaper.png"],"34":["document","Document",[1,2,3,27,4],[110,90,8,14,87,116,1,27,123,19,62,18,2,22],{},"treeitem-document.png"],"35":["encyclopediaArticle","Encyclopedia Article",[1,2,3,5,4],[110,90,85,3,30,4,45,6,7,8,14,10,11,116,1,27,87,123,19,62,18,2,22],{"85":12},"treeitem-encyclopediaArticle.png"],"36":["dictionaryEntry","Dictionary Entry",[1,2,3,5,4],[110,90,86,3,30,4,45,6,7,8,14,10,87,11,116,1,27,123,19,62,18,2,22],{"86":12},"treeitem-dictionaryEntry.png"]},"creatorTypes":{"1":["author","Author"],"2":["contributor","Contributor"],"3":["editor","Editor"],"4":["translator","Translator"],"5":["seriesEditor","Series Editor"],"6":["interviewee","Interview With"],"7":["interviewer","Interviewer"],"8":["director","Director"],"9":["scriptwriter","Scriptwriter"],"10":["producer","Producer"],"11":["castMember","Cast Member"],"12":["sponsor","Sponsor"],"13":["counsel","Counsel"],"14":["inventor","Inventor"],"15":["attorneyAgent","Attorney/Agent"],"16":["recipient","Recipient"],"17":["performer","Performer"],"18":["composer","Composer"],"19":["wordsBy","Words By"],"20":["cartographer","Cartographer"],"21":["programmer","Programmer"],"22":["artist","Artist"],"23":["commenter","Commenter"],"24":["presenter","Presenter"],"25":["guest","Guest"],"26":["podcaster","Podcaster"],"27":["reviewedAuthor","Reviewed Author"],"28":["cosponsor","Cosponsor"],"29":["bookAuthor","Book Author"]},"fields":{"1":["url"],"2":["rights"],"3":["series"],"4":["volume"],"5":["issue"],"6":["edition"],"7":["place"],"8":["publisher"],"10":["pages"],"11":["ISBN"],"12":["publicationTitle"],"13":["ISSN"],"14":["date"],"15":["section"],"18":["callNumber"],"19":["archiveLocation"],"21":["distributor"],"22":["extra"],"25":["journalAbbreviation"],"26":["DOI"],"27":["accessDate"],"28":["seriesTitle"],"29":["seriesText"],"30":["seriesNumber"],"31":["institution"],"32":["reportType"],"36":["code"],"40":["session"],"41":["legislativeBody"],"42":["history"],"43":["reporter"],"44":["court"],"45":["numberOfVolumes"],"46":["committee"],"48":["assignee"],"50":["patentNumber"],"51":["priorityNumbers"],"52":["issueDate"],"53":["references"],"54":["legalStatus"],"55":["codeNumber"],"59":["artworkMedium"],"60":["number"],"61":["artworkSize"],"62":["libraryCatalog"],"63":["videoRecordingFormat"],"64":["interviewMedium"],"65":["letterType"],"66":["manuscriptType"],"67":["mapType"],"68":["scale"],"69":["thesisType"],"70":["websiteType"],"71":["audioRecordingFormat"],"72":["label"],"74":["presentationType"],"75":["meetingName"],"76":["studio"],"77":["runningTime"],"78":["network"],"79":["postType"],"80":["audioFileType"],"81":["version"],"82":["system"],"83":["company"],"84":["conferenceName"],"85":["encyclopediaTitle"],"86":["dictionaryTitle"],"87":["language"],"88":["programmingLanguage"],"89":["university"],"90":["abstractNote"],"91":["websiteTitle"],"92":["reportNumber"],"93":["billNumber"],"94":["codeVolume"],"95":["codePages"],"96":["dateDecided"],"97":["reporterVolume"],"98":["firstPage"],"99":["documentNumber"],"100":["dateEnacted"],"101":["publicLawNumber"],"102":["country"],"103":["applicationNumber"],"104":["forumTitle"],"105":["episodeNumber"],"107":["blogTitle"],"108":["type"],"109":["medium"],"110":["title"],"111":["caseName"],"112":["nameOfAct"],"113":["subject"],"114":["proceedingsTitle"],"115":["bookTitle"],"116":["shortTitle"],"117":["docketNumber"],"118":["numPages"],"119":["programTitle"],"120":["issuingAuthority"],"121":["filingDate"],"122":["genre"],"123":["archive"]}}
/******** END typeSchemaData.js ********/
/******** BEGIN utilities_translate.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2009 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.


	Utilities based in part on code taken from Piggy Bank 2.1.1 (BSD-licensed)

    ***** END LICENSE BLOCK *****
*/

/**
 * @class All functions accessible from within Zotero.Utilities namespace inside sandboxed
 * translators
 *
 * @constructor
 * @augments Zotero.Utilities
 * @borrows Zotero.Date.formatDate as this.formatDate
 * @borrows Zotero.Date.strToDate as this.strToDate
 * @borrows Zotero.Date.strToISO as this.strToISO
 * @borrows Zotero.OpenURL.createContextObject as this.createContextObject
 * @borrows Zotero.OpenURL.parseContextObject as this.parseContextObject
 * @borrows Zotero.HTTP.processDocuments as this.processDocuments
 * @borrows Zotero.HTTP.doPost as this.doPost
 * @param {Zotero.Translate} translate
 */
Zotero.Utilities.Translate = function(translate) {
	this._translate = translate;
}

var tmp = function() {};
tmp.prototype = Zotero.Utilities;
Zotero.Utilities.Translate.prototype = new tmp();

Zotero.Utilities.Translate.prototype.formatDate = Zotero.Date.formatDate;
Zotero.Utilities.Translate.prototype.strToDate = Zotero.Date.strToDate;
Zotero.Utilities.Translate.prototype.strToISO = Zotero.Date.strToISO;
Zotero.Utilities.Translate.prototype.createContextObject = Zotero.OpenURL.createContextObject;
Zotero.Utilities.Translate.prototype.parseContextObject = Zotero.OpenURL.parseContextObject;

/**
 * Hack to overloads {@link Zotero.Utilities.capitalizeTitle} to allow overriding capitalizeTitles
 * pref on a per-translate instance basis (for translator testing only)
 */
Zotero.Utilities.Translate.prototype.capitalizeTitle = function(string, force) {
	if(force === undefined) {
		var translate = this._translate;
		do {
			if(translate.capitalizeTitles !== undefined) {
				force = translate.capitalizeTitles;
				break;
			}
		} while(translate = translate._parentTranslator);
	}

	return Zotero.Utilities.capitalizeTitle(string, force);
}

/**
 * Gets the current Zotero version
 *
 * @type String
 */
Zotero.Utilities.Translate.prototype.getVersion = function() {
	return Zotero.version;
}

/**
 * Takes an XPath query and returns the results
 *
 * @deprecated Use {@link Zotero.Utilities.xpath} or doc.evaluate() directly
 * @type Node[]
 */
Zotero.Utilities.Translate.prototype.gatherElementsOnXPath = function(doc, parentNode, xpath, nsResolver) {
	var elmts = [];

	var iterator = doc.evaluate(xpath, parentNode, nsResolver,
		(Zotero.isFx ? Components.interfaces.nsIDOMXPathResult.ANY_TYPE : XPathResult.ANY_TYPE),
		null);
	var elmt = iterator.iterateNext();
	var i = 0;
	while (elmt) {
		elmts[i++] = elmt;
		elmt = iterator.iterateNext();
	}
	return elmts;
}

/**
 * Gets a given node as a string containing all child nodes
 *
 * @deprecated Use doc.evaluate and the "nodeValue" or "textContent" property
 * @type String
 */
Zotero.Utilities.Translate.prototype.getNodeString = function(doc, contextNode, xpath, nsResolver) {
	var elmts = this.gatherElementsOnXPath(doc, contextNode, xpath, nsResolver);
	var returnVar = "";
	for(var i=0; i<elmts.length; i++) {
		returnVar += elmts[i].nodeValue;
	}
	return returnVar;
}

/**
 * Grabs items based on URLs
 *
 * @param {Document} doc DOM document object
 * @param {Element|Element[]} inHere DOM element(s) to process
 * @param {RegExp} [urlRe] Regexp of URLs to add to list
 * @param {RegExp} [urlRe] Regexp of URLs to reject
 * @return {Object} Associative array of link => textContent pairs, suitable for passing to
 *	Zotero.selectItems from within a translator
 */
Zotero.Utilities.Translate.prototype.getItemArray = function(doc, inHere, urlRe, rejectRe) {
	var availableItems = new Object();	// Technically, associative arrays are objects

	// Require link to match this
	if(urlRe) {
		if(urlRe.exec) {
			var urlRegexp = urlRe;
		} else {
			var urlRegexp = new RegExp();
			urlRegexp.compile(urlRe, "i");
		}
	}
	// Do not allow text to match this
	if(rejectRe) {
		if(rejectRe.exec) {
			var rejectRegexp = rejectRe;
		} else {
			var rejectRegexp = new RegExp();
			rejectRegexp.compile(rejectRe, "i");
		}
	}

	if(!inHere.length) {
		inHere = new Array(inHere);
	}

	for(var j=0; j<inHere.length; j++) {
		var links = inHere[j].getElementsByTagName("a");
		for(var i=0; i<links.length; i++) {
			if(!urlRe || urlRegexp.test(links[i].href)) {
				var text = "textContent" in links[i] ? links[i].textContent : links[i].innerText;
				if(text) {
					text = this.trimInternal(text);
					if(!rejectRe || !rejectRegexp.test(text)) {
						if(availableItems[links[i].href]) {
							if(text != availableItems[links[i].href]) {
								availableItems[links[i].href] += " "+text;
							}
						} else {
							availableItems[links[i].href] = text;
						}
					}
				}
			}
		}
	}

	return availableItems;
}


/**
 * Load a single document in a hidden browser
 *
 * @deprecated Use processDocuments with a single URL
 * @see Zotero.Utilities.Translate#processDocuments
 */
Zotero.Utilities.Translate.prototype.loadDocument = function(url, succeeded, failed) {
	Zotero.debug("Zotero.Utilities.loadDocument is deprecated; please use processDocuments in new code");
	this.processDocuments([url], succeeded, null, failed);
}

/**
 * Already documented in Zotero.HTTP
 * @ignore
 */
Zotero.Utilities.Translate.prototype.processDocuments = function(urls, processor, done, exception) {
	var translate = this._translate;

	if(typeof(urls) == "string") {
		urls = [translate.resolveURL(urls)];
	} else {
		for(var i in urls) {
			urls[i] = translate.resolveURL(urls[i]);
		}
	}

	// Unless the translator has proposed some way to handle an error, handle it
	// by throwing a "scraping error" message
	if(exception) {
		var myException = function(e) {
			var browserDeleted;
			try {
				exception(e);
			} catch(e) {
				if(hiddenBrowser) {
					try {
						Zotero.Browser.deleteHiddenBrowser(hiddenBrowser);
					} catch(e) {}
				}
				browserDeleted = true;
				translate.complete(false, e);
			}

			if(!browserDeleted) {
				try {
					Zotero.Browser.deleteHiddenBrowser(hiddenBrowser);
				} catch(e) {}
			}
		}
	} else {
		var myException = function(e) {
			if(hiddenBrowser) {
				try {
					Zotero.Browser.deleteHiddenBrowser(hiddenBrowser);
				} catch(e) {}
			}
			translate.complete(false, e);
		}
	}

	if(Zotero.isFx) {
		if(typeof translate._sandboxLocation === "object") {
			var protocol = translate._sandboxLocation.location.protocol,
				host = translate._sandboxLocation.location.host;
        } else {
			var url = Components.classes["@mozilla.org/network/io-service;1"]
					.getService(Components.interfaces.nsIIOService)
					.newURI(translate._sandboxLocation, null, null),
				protocol = url.scheme+":",
				host = url.host;
		}
	}

	for(var i=0; i<urls.length; i++) {
		if(this._translate.document && this._translate.document.location
				&& this._translate.document.location.toString() === urls[i]) {
			// Document is attempting to reload itself
			Zotero.debug("Translate: Attempted to load the current document using processDocuments; using loaded document instead");
			processor(this._translate.document, urls[i]);
			urls.splice(i, 1);
			i--;
		}
	}

	translate.incrementAsyncProcesses("Zotero.Utilities.Translate#processDocuments");
	var hiddenBrowser = Zotero.HTTP.processDocuments(urls, function(doc) {
		if(!processor) return;

		var newLoc = doc.location;
		if(Zotero.isFx && !Zotero.isBookmarklet && (protocol != newLoc.protocol || host != newLoc.host)) {
			// Cross-site; need to wrap
			processor(translate._sandboxManager.wrap(doc), newLoc.toString());
		} else {
			// Not cross-site; no need to wrap
			processor(doc, newLoc.toString());
		}
	},
	function() {
		if(done) done();
		var handler = function() {
			if(hiddenBrowser) {
				try {
					Zotero.Browser.deleteHiddenBrowser(hiddenBrowser);
				} catch(e) {}
			}
			translate.removeHandler("done", handler);
		};
		translate.setHandler("done", handler);
		translate.decrementAsyncProcesses("Zotero.Utilities.Translate#processDocuments");
	}, myException, true, translate.cookieSandbox);
}

/**
* Send an HTTP GET request via XMLHTTPRequest
*
* @param {String|String[]} urls URL(s) to request
* @param {Function} processor Callback to be executed for each document loaded
* @param {Function} done Callback to be executed after all documents have been loaded
* @param {String} responseCharset Character set to force on the response
* @return {Boolean} True if the request was sent, or false if the browser is offline
*/
Zotero.Utilities.Translate.prototype.doGet = function(urls, processor, done, responseCharset) {
	var callAgain = false,
		me = this,
		translate = this._translate;

	if(typeof(urls) == "string") {
		var url = urls;
	} else {
		if(urls.length > 1) callAgain = true;
		var url = urls.shift();
	}

	url = translate.resolveURL(url);

	translate.incrementAsyncProcesses("Zotero.Utilities.Translate#doGet");
	var xmlhttp = Zotero.HTTP.doGet(url, function(xmlhttp) {
		try {
			if(processor) {
				processor(xmlhttp.responseText, xmlhttp, url);
			}

			if(callAgain) {
				me.doGet(urls, processor, done, responseCharset);
			} else {
				if(done) {
					done();
				}
			}
			translate.decrementAsyncProcesses("Zotero.Utilities.Translate#doGet");
		} catch(e) {
			translate.complete(false, e);
		}
	}, responseCharset, this._translate.cookieSandbox);
}

/**
 * Already documented in Zotero.HTTP
 * @ignore
 */
Zotero.Utilities.Translate.prototype.doPost = function(url, body, onDone, headers, responseCharset) {
	var translate = this._translate;
	url = translate.resolveURL(url);

	translate.incrementAsyncProcesses("Zotero.Utilities.Translate#doPost");
	var xmlhttp = Zotero.HTTP.doPost(url, body, function(xmlhttp) {
		try {
			onDone(xmlhttp.responseText, xmlhttp);
			translate.decrementAsyncProcesses("Zotero.Utilities.Translate#doPost");
		} catch(e) {
			translate.complete(false, e);
		}
	}, headers, responseCharset, translate.cookieSandbox ? translate.cookieSandbox : undefined);
}

Zotero.Utilities.Translate.prototype.__exposedProps__ = {"HTTP":"r"};
for(var j in Zotero.Utilities.Translate.prototype) {
	if(typeof Zotero.Utilities.Translate.prototype[j] === "function" && j[0] !== "_" && j != "Translate") {
		Zotero.Utilities.Translate.prototype.__exposedProps__[j] = "r";
	}
}
/******** END utilities_translate.js ********/
/******** BEGIN messaging_inject.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2011 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

/**
 * @namespace
 * See messages.js for an overview of the message handling process.
 */
Zotero.Messaging = new function() {
	var _callbacks = {},
		_messageListeners = {},
		_listenerRegistered = false,
		_structuredCloneSupported = false;

	/**
	 * Add a message listener
	 */
	this.addMessageListener = function(messageName, callback) {
		_messageListeners[messageName] = callback;
	}

	/**
	 * Adds messaging functions to injected script. This adds Zotero.xxx.yyy functions for all
	 * entries in MESSAGES. These will send a message to the global script and return immediately.
	 * When a message is received, they will call the callback function, which should be passed
	 * as the last argument to Zotero.xxx.yyy.
	 */
	this.init = function(iFrameSrc) {
		for(var ns in MESSAGES) {
			if(!Zotero[ns]) Zotero[ns] = {};
			for(var meth in MESSAGES[ns]) {
				Zotero[ns][meth] = new function() {
					var messageName = ns+MESSAGE_SEPARATOR+meth;
					var messageConfig = MESSAGES[ns][meth];
					return function() {
						// make sure last argument is a callback
						var callback, callbackArg;
						if(messageConfig) {
							callbackArg = (messageConfig.callbackArg
								? messageConfig.callbackArg : arguments.length-1);
							callback = arguments[callbackArg];
							if(typeof callback !== "function") {
								Zotero.logError(new Error("Zotero: "+messageName+" must be called with a callback"));
								return;
							}
						}

						// copy arguments to newArgs
						var newArgs = new Array(arguments.length);
						for(var i=0; i<arguments.length; i++) {
							newArgs[i] = (i === callbackArg ? null : arguments[i]);
						}

						// set up a request ID and save the callback
						if(callback) {
							var requestID = Math.floor(Math.random()*1e12);
							_callbacks[requestID] = callback;
						}

						// send message
						var message = [requestID, messageName, newArgs];
						var iFrameSrc = iFrameSrc ? iFrameSrc : ZOTERO_CONFIG.BOOKMARKLET_URL+("iframe.html");
						var _structuredCloneSupportedForThisMessage = message[2][0] && message[2][0].error ? false : _structuredCloneSupported;	// Errors don't work with structured clones (https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)
						zoteroIFrame.contentWindow.postMessage(
							(_structuredCloneSupportedForThisMessage ? message : JSON.stringify(message)),
							iFrameSrc);
					};
				};
			}
		}

		if(_listenerRegistered) return;

		var listener = function(event) {
			try {
				var data = event.data, origin = event.origin;

				if(typeof data === "string") {
					try {
						// parse out the data
						data = JSON.parse(data);
					} catch(e) {
						return;
					}
				} else if(!_structuredCloneSupported) {
					_structuredCloneSupported = true;
					Zotero.debug("Structured clone algorithm is supported");
				}

				// first see if there is a message listener
				if(_messageListeners[data[0]]) {
					_messageListeners[data[0]](data[1], event);
					return;
				}

				// next determine original function name
				var messageParts = data[1].split(MESSAGE_SEPARATOR);
				var ns = messageParts[0];
				var meth = messageParts[1];

				var callback = _callbacks[data[0]];
				// if no function matching, message must have been for another instance in this tab
				if(!callback) return;
				delete _callbacks[data[0]];

				// run postReceive function
				var response = data[2];
				var messageConfig = MESSAGES[ns][meth];
				if(messageConfig.postReceive) {
					response = messageConfig.postReceive.apply(null, response);
				}

				// run callback
				callback.apply(null, response);
			} catch(e) {
				Zotero.logError(e);
			}
		}

		// in the bookmarklet, our listener must also handle responses
		if(window.addEventListener) {
			window.addEventListener("message", listener, false);
		} else {
			window.attachEvent("onmessage", function() { listener(event) });
		}

		_listenerRegistered = true;
	}
}

/******** END messaging_inject.js ********/
/******** BEGIN inject_base.js ********/
/*
    ***** BEGIN LICENSE BLOCK *****

    Copyright © 2011 Center for History and New Media
                     George Mason University, Fairfax, Virginia, USA
                     http://zotero.org

    This file is part of Zotero.

    Zotero is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Zotero is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with Zotero.  If not, see <http://www.gnu.org/licenses/>.

    ***** END LICENSE BLOCK *****
*/

var pos = (Zotero.isIE && document.compatMode === "BackCompat" ? "absolute" : "fixed");
var cssBookmarkletFrameDimmer = {"background":"black", "opacity":"0.5", "position":pos,
	"top":"0px", "bottom":"0px", "left":"0px", "right":"0px", "zIndex":"1000000092",
	"height":"100%", "width":"100%", "filter":"alpha(opacity = 50);"};
var cssBookmarkletFrame = {"position":pos, "zIndex":"1000000093", "top":"0",
	"right":"0", "bottom": 0, "background":"white", "border-left":"1px solid #CCC"};

Zotero.initInject();
Zotero.Connector_Types.init();

/**
 * Creates a new frame with the specified width and height
 * @constructor
 */
var BookmarkletFrame = function(url, width, height, name) {
	var parentWin = window.parent,
		parentDoc = parentWin.document;

	this._appendFrameTo = (document.body ? document.body : document.documentElement);
	this._appendDimmerTo = (parentDoc.body ? parentDoc.body : parentDoc.documentElement);

	// Make sure iframe is not bigger than window
	var windowWidth, windowHeight;
	if(parentWin.innerWidth) {
		windowWidth = parentWin.innerWidth;
		windowHeight = parentWin.innerHeight;
	} else if(parentDoc.documentElement.offsetWidth) {
		windowWidth = parentDoc.documentElement.offsetWidth;
		windowHeight = parentDoc.documentElement.offsetHeight;
	} else if(parentDoc.body && parentDoc.body.offsetWidth) {
		windowWidth = parentDoc.body.offsetWidth;
		windowHeight = parentDoc.body.offsetHeight;
	} else {
		windowWidth = windowHeight = Infinity;
	}

	// Add width and height
	height = Math.min(windowHeight-10, height);
	width = Math.min(windowWidth-10, width);


	// Add iframe
	if(url || name) {
		this._frame = document.createElement("iframe");
		if(name) this._frame.name = name;
		if(url) this._frame.src = url + "?referrer=" + document.referrer+"&EXT_SERVICE_PROVIDER="+encodeURIComponent(window.EXT_SERVICE_PROVIDER) + "&PME_SERVICE_PROVIDER="+encodeURIComponent(window.PME_SERVICE_PROVIDER);
	} else {
		this._frame = zoteroIFrame;
		zoteroIFrame.style.display = "block";
	}
	this._frame.style.position = "absolute";
	this._frame.style.top = "0px";
	this._frame.style.left = "0px";
	this._frame.style.width = "100%";
	this._frame.style.height = "100%";
	this._frame.style.borderStyle = "none";
	this._frame.setAttribute("frameborder", "0");

	var frameElementStyle = window.frameElement.style;
	for(var i in cssBookmarkletFrame) frameElementStyle[i] = cssBookmarkletFrame[i];
	frameElementStyle.display = "block";
	//frameElementStyle.margin = "-"+height/2+"px 0 0 -"+width/2+"px";
	frameElementStyle.width = width+"px";
	//frameElementStyle.height = height+"px";
	frameElementStyle.height = "100%";
	if(url || name) this._appendFrameTo.appendChild(this._frame);



}

/**
 * Removes the frame
 */
BookmarkletFrame.prototype.remove = function() {
	this._appendDimmerTo.removeChild(this._dimmer);
	if(this._frame == zoteroIFrame) {
		zoteroIFrame.style.display = "none";
	} else {
		this._appendFrameTo.removeChild(this._frame);
	}
	window.frameElement.style.display = "none";
}

var translate = new Zotero.Translate.Web(),
	selectCallback, cancelled, haveItem, attachmentsSaving;
translate.setDocument(window.parent.document);
translate.setHandler("translators", function(obj, translators) {
	selectCallback = cancelled = haveItem = null;

	if(translators && translators.length) {
		if(translators[0].runMode === Zotero.Translator.RUN_MODE_IN_BROWSER) {
			Zotero.ProgressWindow.changeHeadline("Analyzing...");
		} else if(translators[0].runMode === Zotero.Translator.RUN_MODE_ZOTERO_SERVER) {
			Zotero.ProgressWindow.changeHeadline("Saving via Server...");
		} else {
			Zotero.ProgressWindow.changeHeadline("Saving via Zotero Standalone...");
		}

		translate.setTranslator(translators[0]);
		translate.translate();
	} else {
		Zotero.ProgressWindow.changeHeadline("No Translators Found");
		Zotero.API.createItem({
				"items":[]
			},
			function(statusCode, response) {
			});
	}
});
var originalCallback;
translate.setHandler("select", function(obj, items, callback) {
	for(var i in items) {
		var title;
		if(items[i] && typeof(items[i]) == "object" && items[i].title !== undefined) {
			title = items[i].title;
		} else {
			title = items[i];
		}
		items[i].title = title;
	}

	//callback(items);
	if (Zotero.getDetails === true){
		originalCallback(items);
	} else {
		originalCallback = callback;
		var payload = {items:items};
		Zotero.API.createSelection(payload,function(){console.log("completed Zotero.API.createSelection")});
	}
});
var _itemProgress = {};
translate.setHandler("itemSaving", function(obj, item) {
	Zotero.API.notifyFullReference(item);
	/*if(!_itemProgress[item.id]) {
		_itemProgress[item.id] = new Zotero.ProgressWindow.ItemProgress(
			Zotero.ItemTypes.getImageSrc(item.itemType), item.title);
	}*/
});
translate.setHandler("itemDone", function(obj, dbItem, item) {
	var itemProgress = _itemProgress[item.id];
	if(!itemProgress) {
		itemProgress = _itemProgress[item.id] = new Zotero.ProgressWindow.ItemProgress(
			Zotero.ItemTypes.getImageSrc(item.itemType), item.title);
	}
	itemProgress.setProgress(100);
	haveItem = true;
	for(var i=0; i<item.attachments.length; i++) {
		var attachment = item.attachments[i];
		_itemProgress[attachment.id] = new Zotero.ProgressWindow.ItemProgress(
			Zotero.ItemTypes.getImageSrc(attachment.mimeType === "application/pdf"
				? "attachment-pdf" : "attachment-snapshot"), attachment.title, itemProgress);
	}
});
translate.setHandler("attachmentProgress", function(obj, attachment, progress) {
	var attachmentProgress = _itemProgress[attachment.id];
	if(!attachmentProgress) return;
	if(progress === false) {
		attachmentProgress.setError();
	} else {
		if(attachment.linkMode === "linked_url") {
			attachmentProgress.setIcon(Zotero.ItemTypes.getImageSrc("attachment-web-link"));
		}
		attachmentProgress.setProgress(progress);
	}
});
translate.setHandler("done", function(obj, returnValue) {
	if(returnValue && haveItem) {
		Zotero.ProgressWindow.startCloseTimer(2500);
	} else if(!cancelled) {
		new Zotero.ProgressWindow.ErrorMessage("translationError");
		Zotero.ProgressWindow.startCloseTimer(8000);
	}
	cleanup();
});

// Add message listener for translate, so we don't call until the iframe is loaded
Zotero.Messaging.addMessageListener("translate", function(data, event) {
	Zotero.ProgressWindow.changeHeadline("Looking for Translators...");
	if(Zotero.isIE) installXPathIfNecessary(window.parent);
	if(event.origin.substr(0, 6) === "https:" && ZOTERO_CONFIG.BOOKMARKLET_URL.substr(0, 5) === "http:") {
		ZOTERO_CONFIG.BOOKMARKLET_URL = "https:"+ZOTERO_CONFIG.BOOKMARKLET_URL.substr(5);
	}
	translate.getTranslators();
});
Zotero.Messaging.addMessageListener("selectDone", function(returnItems) {
	Zotero.getDetails = true;
	Zotero.Translate.Sandbox.Web.selectItems(translate, returnItems);
});

// We use these for OAuth, so that we can load the OAuth pages in a child frame of the privileged
// iframe
var revealedFrame;
Zotero.Messaging.addMessageListener("revealZoteroIFrame", function() {
	if(revealedFrame) return;
	revealedFrame = new BookmarkletFrame(null, 400, 400);
});
Zotero.Messaging.addMessageListener("hideZoteroIFrame", function() {
	revealedFrame.remove();
});

Zotero.Messaging.addMessageListener("_getAttachment", function(args) {
	var itemSaver = new Zotero.Translate.ItemSaver(undefined, "ATTACHMENT_MODE_FILE", undefined, undefined, undefined, undefined);
	itemSaver._saveAttachmentsToServer(args.attachments, {automaticSnapshots: true, downloadAssociatedFiles: true}, itemSaver.notifyAttachmentProgress);
});

Zotero.Messaging.addMessageListener("cleanup", function() {
	Zotero.ProgressWindow.close();
	cleanup();
});

// For IE, load from http to avoid a warning
if(Zotero.isIE && window.parent.location.protocol === "http:") {
	ZOTERO_CONFIG.BOOKMARKLET_URL = ZOTERO_CONFIG.BOOKMARKLET_URL.replace("https", "http");
}

var zoteroIFrame;

/**
 * Load privileged iframe and begin translation
 */
function startTranslation() {
	Zotero.ProgressWindow.show();
	zoteroIFrame = document.createElement("iframe");
	zoteroIFrame.id = "zotero-privileged-iframe";
	zoteroIFrame.src = ZOTERO_CONFIG.BOOKMARKLET_URL+"iframe.html" + "?referrer=" + document.referrer + "&pageTitle=" + window.parent.document.title + "&EXT_SERVICE_PROVIDER="+encodeURIComponent(window.EXT_SERVICE_PROVIDER) + "&PME_SERVICE_PROVIDER="+encodeURIComponent(window.PME_SERVICE_PROVIDER);
	zoteroIFrame.style.display = "none";
	document.body.appendChild(zoteroIFrame);
	document.body.style.overflow = "hidden";

}

/**
 * Remove the frames
 */
function cleanup() {
	zoteroIFrame.parentNode.removeChild(zoteroIFrame);
	window.frameElement.parentNode.removeChild(window.frameElement);
}


/******* inject_ie_compat.js (mostly) *********/

if (Zotero.isIE) {



if(!String.prototype.trim) {
	String.prototype.trim = function() { return this.replace(/^\s+|\s+$/, ''); };
}

/**
 * Provides textContent property in IE. explorerify rewrites the AST to replace the
 * textContent property with a function call to this.
 * @param {Object} el
 * @return {String}
 */
function textContent(el) {
	if(typeof el !== "object" || el === null) return el.textContent;
	return "textContent" in el ? el.textContent
		: "innerText" in el ? el.innerText
		: "text" in el ? el.text
		: el.nodeValue;
}

/**
 * Provides defaultView property in IE. explorerify rewrites the AST to replace the
 * defaultView property with a function call to this.
 * @param {Object} doc
 * @return {Window}
 */
function defaultView(doc) {
	if(typeof doc !== "object" || doc === null) return doc.defaultView;
	return "defaultView" in doc ? doc.defaultView : doc.parentWindow;
}

/**
 * explorerify rewrites all calls to the "filter" property on an object with a call to
 * this. It uses the "filter" property if available, or else performs its own filtering.
 * Implementation derived from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter
 */
function arrayFilter(array, fun, thisp) {
	if("filter" in array) {
		var args = [];
		for(var i=1; i<arguments.length; i++) args.push(arguments[i]);
		return array.filter.apply(array, args);
	}

	if (array == null) throw new TypeError();

	var t = Object(array);
	var len = t.length >>> 0;
	if (typeof fun != "function") throw new TypeError();

	var res = [];
	for (var i = 0; i < len; i++) {
		if (i in t)	 {
			var val = t[i]; // in case fun mutates this
			if (fun.call(thisp, val, i, t))	res.push(val);
		}
	}

	return res;
};

/**
 * explorerify rewrites all calls to the "map" property on an object with a call to
 * this. It uses the "map" property if available, or else performs its own filtering.
 * Implementation derived from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map
 */
function arrayMap(array, callback, thisArg) {
	if("map" in array) {
		var args = [];
		for(var i=1; i<arguments.length; i++) args.push(arguments[i]);
		return array.map.apply(array, args);
	}

	var T, A, k;

	if (array == null) {
		throw new TypeError("array is null or not defined");
	}

	// 1. Let O be the result of calling ToObject passing the |this| value as the argument.
	var O = Object(array);

	// 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
	// 3. Let len be ToUint32(lenValue).
	var len = O.length >>> 0;

	// 4. If IsCallable(callback) is false, throw a TypeError exception.
	// See: http://es5.github.com/#x9.11
	if ({}.toString.call(callback) != "[object Function]") {
		throw new TypeError(callback + " is not a function");
	}

	// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
	if (thisArg) {
		T = thisArg;
	}

	// 6. Let A be a new array created as if by the expression new Array(len) where Array is
	// the standard built-in constructor with that name and len is the value of len.
	A = new Array(len);

	// 7. Let k be 0
	k = 0;

	// 8. Repeat, while k < len
	while(k < len) {

		var kValue, mappedValue;

		// a. Let Pk be ToString(k).
		//	 This is implicit for LHS operands of the in operator
		// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
		//	 This step can be combined with c
		// c. If kPresent is true, then
		if (k in O) {

			// i. Let kValue be the result of calling the Get internal method of O with argument Pk.
			kValue = O[ k ];

			// ii. Let mappedValue be the result of calling the Call internal method of callback
			// with T as the this value and argument list containing kValue, k, and O.
			mappedValue = callback.call(T, kValue, k, O);

			// iii. Call the DefineOwnProperty internal method of A with arguments
			// Pk, Property Descriptor {Value: mappedValue, Writable: true, Enumerable: true, Configurable: true},
			// and false.

			// In browsers that support Object.defineProperty, use the following:
			// Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });

			// For best browser support, use the following:
			A[ k ] = mappedValue;
		}
		// d. Increase k by 1.
		k++;
	}

	// 9. return A
	return A;
};

/**
 * explorerify rewrites all calls to the "forEach" property on an object with a call to
 * this. It uses the "forEach" property if available, or else performs its own filtering.
 * Implementation derived from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
 */
function arrayForEach(array, callback, thisArg) {
	if("forEach" in array) {
		var args = [];
		for(var i=1; i<arguments.length; i++) args.push(arguments[i]);
		return array.forEach.apply(array, args);
	}

	var T, k;

	if ( array == null ) {
		throw new TypeError( "array is null or not defined" );
	}

	// 1. Let O be the result of calling ToObject passing the |this| value as the argument.
	var O = Object(array);

	// 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
	// 3. Let len be ToUint32(lenValue).
	var len = O.length >>> 0; // Hack to convert O.length to a UInt32

	// 4. If IsCallable(callback) is false, throw a TypeError exception.
	// See: http://es5.github.com/#x9.11
	if ( {}.toString.call(callback) != "[object Function]" ) {
		throw new TypeError( callback + " is not a function" );
	}

	// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
	if ( thisArg ) {
		T = thisArg;
	}

	// 6. Let k be 0
	k = 0;

	// 7. Repeat, while k < len
	while( k < len ) {

		var kValue;

		// a. Let Pk be ToString(k).
		//	 This is implicit for LHS operands of the in operator
		// b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
		//	 This step can be combined with c
		// c. If kPresent is true, then
		if ( k in O ) {

			// i. Let kValue be the result of calling the Get internal method of O with argument Pk.
			kValue = O[ k ];

			// ii. Call the Call internal method of callback with T as the this value and
			// argument list containing kValue, k, and O.
			callback.call( T, kValue, k, O );
		}
		// d. Increase k by 1.
		k++;
	}
	// 8. return undefined
}

var XMLHttpRequest = window.parent.XMLHttpRequest;

/*  JavaScript-XPath 0.1.12
 *  (c) 2007 Cybozu Labs, Inc.
 *
 *  JavaScript-XPath is freely distributable under the terms of an MIT-style license.
 *  For details, see the JavaScript-XPath web site: http://coderepos.org/share/wiki/JavaScript-XPath
 *
 /*--------------------------------------------------------------------------*/



(function () {

	var undefined = void(0);

	var defaultConfig = {
		targetFrame: undefined,
		exportInstaller: true,
		useNative: true,
		useInnerText: true
	};

	var config;

	if (window.jsxpath) {
		config = window.jsxpath;
	}
	else {
		var scriptElms = document.getElementsByTagName('script');
		var scriptElm = scriptElms[scriptElms.length - 1];
		var scriptSrc = scriptElm.src;
		config = {};
		var scriptSrcMatchResult = scriptSrc.match(/\?(.*)$/);
		if (scriptSrcMatchResult) {
			var configStrings = scriptSrcMatchResult[1].split('&');
			for (var i = 0, l = configStrings.length; i < l; i++) {
				var configString = configStrings[i];
				var configStringSplited = configString.split('=');
				var configName = configStringSplited[0];
				var configValue = configStringSplited[1];
				if (configValue == undefined) {
					configValue == true;
				}
				else if (configValue == 'false' || /^-?\d+$/.test(configValue)) {
					configValue = eval(configValue);
				}
				config[configName] = configValue;
			}
		}
	}

	for (var n in defaultConfig) {
		if (!(n in config)) config[n] = defaultConfig[n];
	}

	config.hasNative = !!(document.implementation
	&& document.implementation.hasFeature
	&& document.implementation.hasFeature("XPath", null));

	if (config.hasNative && config.useNative && !config.exportInstaller) {
		return;
	}


	var BinaryExpr;
	var FilterExpr;
	var FunctionCall;
	var Literal;
	var NameTest;
	var NodeSet;
	var NodeType;
	var NodeUtil;
	var Number;
	var PathExpr;
	var Step;
	var UnaryExpr;
	var UnionExpr;
	var VariableReference;

	/*
	 * object: user agent identifier
	 */
	var uai = new function () {

		var ua = navigator.userAgent;

		if (RegExp == undefined) {
			if (ua.indexOf("Opera") >= 0) {
				this.opera = true;
			} else if (ua.indexOf("Netscape") >= 0) {
				this.netscape = true;
			} else if (ua.indexOf("Mozilla/") == 0) {
				this.mozilla = true;
			} else {
				this.unknown = true;
			}

			if (ua.indexOf("Gecko/") >= 0) {
				this.gecko = true;
			}

			if (ua.indexOf("Win") >= 0) {
				this.windows = true;
			} else if (ua.indexOf("Mac") >= 0) {
				this.mac = true;
			} else if (ua.indexOf("Linux") >= 0) {
				this.linux = true;
			} else if (ua.indexOf("BSD") >= 0) {
				this.bsd = true;
			} else if (ua.indexOf("SunOS") >= 0) {
				this.sunos = true;
			}
		}
		else {
			this.windows = true;
			this.trident = "7.0";
			if (/MSIE (\d+\.\d+)b?;/.test(ua)) {
				this.ie = RegExp.$1;
				this['ie' + RegExp.$1.charAt(0)] = true;
			}

			if (typeof(opera) == "object" && typeof(opera.version) == "function") {
				this.opera = opera.version();
				this['opera' + this.opera[0] + this.opera[2]] = true;
			} else if (typeof opera == "object"
				&& (/Opera[\/ ](\d+\.\d+)/.test(ua))) {
				this.opera = RegExp.$1;
			} else if (this.ie) {
			} else if (/Safari\/(\d+(?:\.\d+)*)/.test(ua)) {
				this.safari = RegExp.$1;
			} else if (/NetFront\/(\d+(?:\.\d+)*)/.test(ua)) {
				this.netfront = RegExp.$1;
			} else if (/Konqueror\/(\d+(?:\.\d+)*)/.test(ua)) {
				this.konqueror = RegExp.$1;
			} else if (ua.indexOf("(compatible;") < 0
				&& (/^Mozilla\/(\d+\.\d+)/.test(ua))) {
				this.mozilla = RegExp.$1;
				if (/\([^(]*rv:(\d+(?:\.\d+)*).*?\)/.test(ua))
					this.mozillarv = RegExp.$1;
				if (/Firefox\/(\d+(?:\.\d+)*)/.test(ua)) {
					this.firefox = RegExp.$1;
				} else if (/Netscape\d?\/(\d+(?:\.\d+)*)/.test(ua)) {
					this.netscape = RegExp.$1;
				}
			} else {
				this.unknown = true;
			}

			if (ua.indexOf("Win 9x 4.90") >= 0) {
				this.windows = "ME";
			} else if (/Win(?:dows)? ?(NT ?(\d+\.\d+)?|\d+|ME|Vista|XP)/.test(ua)) {
				this.windows = RegExp.$1;
				if (RegExp.$2) {
					this.winnt = RegExp.$2;
				} else switch (RegExp.$1) {
					case "2000":
						this.winnt = "5.0";
						break;
					case "XP":
						this.winnt = "5.1";
						break;
					case "Vista":
						this.winnt = "6.0";
						break;
				}
			} else if (ua.indexOf("Mac") >= 0) {
				this.mac = true;
			} else if (ua.indexOf("Linux") >= 0) {
				this.linux = true;
			} else if (/(\w*BSD)/.test(ua)) {
				this.bsd = RegExp.$1;
			} else if (ua.indexOf("SunOS") >= 0) {
				this.sunos = true;
			}
		}
	};


	/**
	 * pseudo class: Lexer
	 */
	var Lexer = function (source) {
		var proto = Lexer.prototype;
		var tokens = source.match(proto.regs.token);
		for (var i = 0, l = tokens.length; i < l; i++) {
			if (proto.regs.strip.test(tokens[i])) {
				tokens.splice(i, 1);
			}
		}
		for (var n in proto) tokens[n] = proto[n];
		tokens.index = 0;
		return tokens;
	};

	Lexer.prototype.regs = {
		token: /\$?(?:(?![0-9-])[\w-]+:)?(?![0-9-])[\w-]+|\/\/|\.\.|::|\d+(?:\.\d*)?|\.\d+|"[^"]*"|'[^']*'|[!<>]=|(?![0-9-])[\w-]+:\*|\s+|./g,
		strip: /^\s/
	};

	Lexer.prototype.peek = function (i) {
		return this[this.index + (i || 0)];
	};
	Lexer.prototype.next = function () {
		return this[this.index++];
	};
	Lexer.prototype.back = function () {
		this.index--;
	};
	Lexer.prototype.empty = function () {
		return this.length <= this.index;
	};


	/**
	 * class: Ctx
	 */
	var Ctx = function (node, position, last) {
		this.node = node;
		this.position = position || 1;
		this.last = last || 1;
	};


	/**
	 * abstract class: BaseExpr
	 */
	var BaseExpr = function () {
	};

	BaseExpr.prototype.number = function (ctx) {
		var exrs = this.evaluate(ctx);
		if (exrs.isNodeSet) return exrs.number();
		return +exrs;
	};

	BaseExpr.prototype.string = function (ctx) {
		var exrs = this.evaluate(ctx);
		if (exrs.isNodeSet) return exrs.string();
		return '' + exrs;
	};

	BaseExpr.prototype.bool = function (ctx) {
		var exrs = this.evaluate(ctx);
		if (exrs.isNodeSet) return exrs.bool();
		return !!exrs;
	};


	/**
	 * abstract class: BaseExprHasPredicates
	 */
	var BaseExprHasPredicates = function () {
	};

	BaseExprHasPredicates.parsePredicates = function (lexer, expr) {
		while (lexer.peek() == '[') {
			lexer.next();
			if (lexer.empty()) {
				throw Error('missing predicate expr');
			}
			var predicate = BinaryExpr.parse(lexer);
			expr.predicate(predicate);
			if (lexer.empty()) {
				throw Error('unclosed predicate expr');
			}
			if (lexer.next() != ']') {
				lexer.back();
				throw Error('bad token: ' + lexer.next());
			}
		}
	};

	BaseExprHasPredicates.prototype = new BaseExpr();

	BaseExprHasPredicates.prototype.evaluatePredicates = function (nodeset, start) {
		var predicates, predicate, nodes, node, nodeset, position, reverse;

		reverse = this.reverse;
		predicates = this.predicates;

		nodeset.sort();

		for (var i = start || 0, l0 = predicates.length; i < l0; i++) {
			predicate = predicates[i];

			var deleteIndexes = [];
			var nodes = nodeset.list();

			for (var j = 0, l1 = nodes.length; j < l1; j++) {

				position = reverse ? (l1 - j) : (j + 1);
				exrs = predicate.evaluate(new Ctx(nodes[j], position, l1));

				switch (typeof exrs) {
					case 'number':
						exrs = (position == exrs);
						break;
					case 'string':
						exrs = !!exrs;
						break;
					case 'object':
						exrs = exrs.bool();
						break;
				}

				if (!exrs) {
					deleteIndexes.push(j);
				}
			}

			for (var j = deleteIndexes.length - 1, l1 = 0; j >= l1; j--) {
				nodeset.del(deleteIndexes[j]);
			}

		}

		return nodeset;
	};


	/**
	 * class: BinaryExpr
	 */
	if (!window.BinaryExpr && window.defaultConfig)
		window.BinaryExpr = null;

	BinaryExpr = function (op, left, right, datatype) {
		this.op = op;
		this.left = left;
		this.right = right;

		this.datatype = BinaryExpr.ops[op][2];

		this.needContextPosition = left.needContextPosition || right.needContextPosition;
		this.needContextNode = left.needContextNode || right.needContextNode;

		// Optimize [@id="foo"] and [@name="bar"]
		if (this.op == '=') {
			if (!right.needContextNode && !right.needContextPosition &&
				right.datatype != 'nodeset' && right.datatype != 'void' && left.quickAttr) {
				this.quickAttr = true;
				this.attrName = left.attrName;
				this.attrValueExpr = right;
			}
			else if (!left.needContextNode && !left.needContextPosition &&
				left.datatype != 'nodeset' && left.datatype != 'void' && right.quickAttr) {
				this.quickAttr = true;
				this.attrName = right.attrName;
				this.attrValueExpr = left;
			}
		}
	};

	BinaryExpr.compare = function (op, comp, left, right, ctx) {
		var type, lnodes, rnodes, nodes, nodeset, primitive;

		left = left.evaluate(ctx);
		right = right.evaluate(ctx);

		if (left.isNodeSet && right.isNodeSet) {
			lnodes = left.list();
			rnodes = right.list();
			for (var i = 0, l0 = lnodes.length; i < l0; i++)
				for (var j = 0, l1 = rnodes.length; j < l1; j++)
					if (comp(NodeUtil.to('string', lnodes[i]), NodeUtil.to('string', rnodes[j])))
						return true;
			return false;
		}

		if (left.isNodeSet || right.isNodeSet) {
			if (left.isNodeSet)
				nodeset = left, primitive = right;
			else
				nodeset = right, primitive = left;

			nodes = nodeset.list();
			type = typeof primitive;
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (comp(NodeUtil.to(type, nodes[i]), primitive))
					return true;
			}
			return false;
		}

		if (op == '=' || op == '!=') {
			if (typeof left == 'boolean' || typeof right == 'boolean') {
				return comp(!!left, !!right);
			}
			if (typeof left == 'number' || typeof right == 'number') {
				return comp(+left, +right);
			}
			return comp(left, right);
		}

		return comp(+left, +right);
	};


	BinaryExpr.ops = {
		'div': [6, function (left, right, ctx) {
			return left.number(ctx) / right.number(ctx);
		}, 'number'],
		'mod': [6, function (left, right, ctx) {
			return left.number(ctx) % right.number(ctx);
		}, 'number'],
		'*': [6, function (left, right, ctx) {
			return left.number(ctx) * right.number(ctx);
		}, 'number'],
		'+': [5, function (left, right, ctx) {
			return left.number(ctx) + right.number(ctx);
		}, 'number'],
		'-': [5, function (left, right, ctx) {
			return left.number(ctx) - right.number(ctx);
		}, 'number'],
		'<': [4, function (left, right, ctx) {
			return BinaryExpr.compare('<',
				function (a, b) {
					return a < b
				}, left, right, ctx);
		}, 'boolean'],
		'>': [4, function (left, right, ctx) {
			return BinaryExpr.compare('>',
				function (a, b) {
					return a > b
				}, left, right, ctx);
		}, 'boolean'],
		'<=': [4, function (left, right, ctx) {
			return BinaryExpr.compare('<=',
				function (a, b) {
					return a <= b
				}, left, right, ctx);
		}, 'boolean'],
		'>=': [4, function (left, right, ctx) {
			return BinaryExpr.compare('>=',
				function (a, b) {
					return a >= b
				}, left, right, ctx);
		}, 'boolean'],
		'=': [3, function (left, right, ctx) {
			return BinaryExpr.compare('=',
				function (a, b) {
					return a == b
				}, left, right, ctx);
		}, 'boolean'],
		'!=': [3, function (left, right, ctx) {
			return BinaryExpr.compare('!=',
				function (a, b) {
					return a != b
				}, left, right, ctx);
		}, 'boolean'],
		'and': [2, function (left, right, ctx) {
			return left.bool(ctx) && right.bool(ctx);
		}, 'boolean'],
		'or': [1, function (left, right, ctx) {
			return left.bool(ctx) || right.bool(ctx);
		}, 'boolean']
	};


	BinaryExpr.parse = function (lexer) {
		var op, precedence, info, expr, stack = [], index = lexer.index;

		while (true) {

			if (lexer.empty()) {
				throw Error('missing right expression');
			}
			expr = UnaryExpr.parse(lexer);

			op = lexer.next();
			if (!op) {
				break;
			}

			info = this.ops[op];
			precedence = info && info[0];
			if (!precedence) {
				lexer.back();
				break;
			}

			while (stack.length && precedence <= this.ops[stack[stack.length - 1]][0]) {
				expr = new BinaryExpr(stack.pop(), stack.pop(), expr);
			}

			stack.push(expr, op);
		}

		while (stack.length) {
			expr = new BinaryExpr(stack.pop(), stack.pop(), expr);
		}

		return expr;
	};

	BinaryExpr.prototype = new BaseExpr();

	BinaryExpr.prototype.evaluate = function (ctx) {
		return BinaryExpr.ops[this.op][1](this.left, this.right, ctx);
	};

	BinaryExpr.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'binary: ' + this.op + '\n';
		indent += '	';
		t += this.left.show(indent);
		t += this.right.show(indent);
		return t;
	};


	/**
	 * class: UnaryExpr
	 */
	if (!window.UnaryExpr && window.defaultConfig)
		window.UnaryExpr = null;

	UnaryExpr = function (op, expr) {
		this.op = op;
		this.expr = expr;

		this.needContextPosition = expr.needContextPosition;
		this.needContextNode = expr.needContextNode;
	};

	UnaryExpr.ops = {'-': 1};

	UnaryExpr.parse = function (lexer) {
		var token;
		if (this.ops[lexer.peek()])
			return new UnaryExpr(lexer.next(), UnaryExpr.parse(lexer));
		else
			return UnionExpr.parse(lexer);
	};

	UnaryExpr.prototype = new BaseExpr();

	UnaryExpr.prototype.datatype = 'number';

	UnaryExpr.prototype.evaluate = function (ctx) {
		return -this.expr.number(ctx);
	};

	UnaryExpr.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'unary: ' + this.op + '\n';
		indent += '	';
		t += this.expr.show(indent);
		return t;
	};


	/**
	 * class: UnionExpr
	 */
	if (!window.UnionExpr && window.defaultConfig)
		window.UnionExpr = null;

	UnionExpr = function () {
		this.paths = [];
	};

	UnionExpr.ops = {'|': 1};


	UnionExpr.parse = function (lexer) {
		var union, expr;

		expr = PathExpr.parse(lexer);
		if (!this.ops[lexer.peek()])
			return expr;

		union = new UnionExpr();
		union.path(expr);

		while (true) {
			if (!this.ops[lexer.next()]) break;
			if (lexer.empty()) {
				throw Error('missing next union location path');
			}
			union.path(PathExpr.parse(lexer));
		}


		lexer.back();
		return union;
	};

	UnionExpr.prototype = new BaseExpr();

	UnionExpr.prototype.datatype = 'nodeset';

	UnionExpr.prototype.evaluate = function (ctx) {
		var paths = this.paths;
		var nodeset = new NodeSet();
		for (var i = 0, l = paths.length; i < l; i++) {
			var exrs = paths[i].evaluate(ctx);
			if (!exrs.isNodeSet) throw Error('PathExpr must be nodeset');
			nodeset.merge(exrs);
		}
		return nodeset;
	};

	UnionExpr.prototype.path = function (path) {
		this.paths.push(path);

		if (path.needContextPosition) {
			this.needContextPosition = true;
		}
		if (path.needContextNode) {
			this.needContextNode = true;
		}
	}
	UnionExpr.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'union:' + '\n';
		indent += '	';
		for (var i = 0; i < this.paths.length; i++) {
			t += this.paths[i].show(indent);
		}
		return t;
	};


	/**
	 * class: PathExpr
	 */
	if (!window.PathExpr && window.defaultConfig)
		window.PathExpr = null;

	PathExpr = function (filter) {
		this.filter = filter;
		this.steps = [];

		this.datatype = filter.datatype;

		this.needContextPosition = filter.needContextPosition;
		this.needContextNode = filter.needContextNode;
	};

	PathExpr.ops = {'//': 1, '/': 1};

	PathExpr.parse = function (lexer) {
		var op, expr, path, token;

		if (this.ops[lexer.peek()]) {
			op = lexer.next();
			token = lexer.peek();

			if (op == '/' && (lexer.empty() ||
				(token != '.' && token != '..' && token != '@' && token != '*' && !/(?![0-9])[\w]/.test(token)))) {
				return FilterExpr.root();
			}

			path = new PathExpr(FilterExpr.root()); // RootExpr

			if (lexer.empty()) {
				throw Error('missing next location step');
			}
			expr = Step.parse(lexer);
			path.step(op, expr);
		}
		else {
			expr = FilterExpr.parse(lexer);
			if (!expr) {
				expr = Step.parse(lexer);
				path = new PathExpr(FilterExpr.context());
				path.step('/', expr);
			}
			else if (!this.ops[lexer.peek()])
				return expr;
			else
				path = new PathExpr(expr);
		}

		while (true) {
			if (!this.ops[lexer.peek()]) break;
			op = lexer.next();
			if (lexer.empty()) {
				throw Error('missing next location step');
			}
			path.step(op, Step.parse(lexer));
		}

		return path;
	};

	PathExpr.prototype = new BaseExpr();

	PathExpr.prototype.evaluate = function (ctx) {
		var nodeset = this.filter.evaluate(ctx);
		if (!nodeset.isNodeSet) throw Exception('Filter nodeset must be nodeset type');

		var steps = this.steps;

		for (var i = 0, l0 = steps.length; i < l0 && nodeset.length; i++) {
			var step = steps[i][1];
			var reverse = step.reverse;
			var iter = nodeset.iterator(reverse);
			var prevNodeset = nodeset;
			nodeset = null;
			var node, next;
			if (!step.needContextPosition && step.axis == 'following') {
				for (node = iter(); next = iter(); node = next) {

					// Safari 2 node.contains problem
					if (uai.applewebkit2) {
						var contains = false;
						var ancestor = next;
						do {
							if (ancestor == node) {
								contains = true;
								break;
							}
						} while (ancestor = ancestor.parentNode);
						if (!contains) break;
					}
					else {
						try {
							if (!node.contains(next)) break
						}
						catch (e) {
							if (!(next.compareDocumentPosition(node) & 8)) break
						}
					}
				}
				nodeset = step.evaluate(new Ctx(node));
			}
			else if (!step.needContextPosition && step.axis == 'preceding') {
				node = iter();
				nodeset = step.evaluate(new Ctx(node));
			}
			else {
				node = iter();
				var j = 0;
				nodeset = step.evaluate(new Ctx(node), false, prevNodeset, j);
				while (node = iter()) {
					j++;
					nodeset.merge(step.evaluate(new Ctx(node), false, prevNodeset, j));
				}
			}
		}

		return nodeset;
	};

	PathExpr.prototype.step = function (op, step) {
		step.op = op;
		this.steps.push([op, step]);

		this.quickAttr = false;

		if (this.steps.length == 1) {
			if (op == '/' && step.axis == 'attribute') {
				var test = step.test;
				if (!test.notOnlyElement && test.name != '*') {
					this.quickAttr = true;
					this.attrName = test.name;
				}
			}
		}
	};

	PathExpr.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'path:' + '\n';
		indent += '	';
		t += indent + 'filter:' + '\n';
		t += this.filter.show(indent + '	');
		if (this.steps.length) {
			t += indent + 'steps:' + '\n';
			indent += '	';
			for (var i = 0; i < this.steps.length; i++) {
				var step = this.steps[i];
				t += indent + 'operator: ' + step[0] + '\n';
				t += step[1].show(indent);
			}
		}
		return t;
	};


	/**
	 * class: FilterExpr
	 */
	if (!window.FilterExpr && window.defaultConfig)
		window.FilterExpr = null;

	FilterExpr = function (primary) {
		this.primary = primary;
		this.predicates = [];

		this.datatype = primary.datatype;

		this.needContextPosition = primary.needContextPosition;

		this.needContextNode = primary.needContextNode;
	};

	FilterExpr.parse = function (lexer) {
		var expr, filter, token, ch;

		token = lexer.peek();
		ch = token.charAt(0);

		switch (ch) {
			case '$':
				expr = VariableReference.parse(lexer);
				break;

			case '(':
				lexer.next();
				expr = BinaryExpr.parse(lexer);
				if (lexer.empty()) {
					throw Error('unclosed "("');
				}
				if (lexer.next() != ')') {
					lexer.back();
					throw Error('bad token: ' + lexer.next());
				}
				break;

			case '"':
			case "'":
				expr = Literal.parse(lexer);
				break;

			default:
				if (!isNaN(+token)) {
					expr = Number.parse(lexer);
				}

				else if (NodeType.types[token]) {
					return null;
				}

				else if (/(?![0-9])[\w]/.test(ch) && lexer.peek(1) == '(') {
					expr = FunctionCall.parse(lexer);
				}
				else {
					return null;
				}
				break;
		}

		if (lexer.peek() != '[') return expr;

		filter = new FilterExpr(expr);

		BaseExprHasPredicates.parsePredicates(lexer, filter);

		return filter;
	};

	FilterExpr.root = function () {
		return new FunctionCall('root-node');
	};
	FilterExpr.context = function () {
		return new FunctionCall('context-node');
	};

	FilterExpr.prototype = new BaseExprHasPredicates();

	FilterExpr.prototype.evaluate = function (ctx) {
		var nodeset = this.primary.evaluate(ctx);
		if (!nodeset.isNodeSet) {
			if (this.predicates.length)
				throw Error(
					'Primary result must be nodeset type ' +
					'if filter have predicate expression');
			return nodeset;
		}

		return this.evaluatePredicates(nodeset);
	};

	FilterExpr.prototype.predicate = function (predicate) {
		this.predicates.push(predicate);
	};

	FilterExpr.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'filter: ' + '\n';
		indent += '	';
		t += this.primary.show(indent);
		if (this.predicates.length) {
			t += indent + 'predicates: ' + '\n';
			indent += '	';
			for (var i = 0; i < this.predicates.length; i++) {
				t += this.predicates[i].show(indent);
			}
		}
		return t;
	};


	if (!window.NodeUtil && window.defaultConfig)
		window.NodeUtil = null;

	NodeUtil = {
		to: function (valueType, node) {
			var t, type = node.nodeType;
			// Safari2: innerText contains some bugs
			if (type == 1 && config.useInnerText && !uai.applewebkit2) {
				t = node.textContent;
				t = (t == undefined || t == null) ? node.innerText : t;
				t = (t == undefined || t == null) ? '' : t;
			}
			if (typeof t != 'string') {
				if (type == 1 && node.nodeName.toLowerCase() == 'title') {
					t = node.text;
				}
				else if (type == 9 || type == 1) {
					if (type == 9) {
						node = node.documentElement;
					}
					else {
						node = node.firstChild;
					}
					for (t = '', stack = [], i = 0; node;) {
						do {
							if (node.nodeType != 1) {
								t += node.nodeValue;
							}
							else if (node.nodeName.toLowerCase() == 'title') {
								t += node.text;
							}
							stack[i++] = node; // push
						} while (node = node.firstChild);
						while (i && !(node = stack[--i].nextSibling)) {
						}
					}
				}
				else {
					t = node.nodeValue;
				}
			}
			switch (valueType) {
				case 'number':
					return +t;
				case 'boolean':
					return !!t;
				default:
					return t;
			}
		},
		attrPropMap: {
			name: 'name',
			'class': 'className',
			dir: 'dir',
			id: 'id',
			name: 'name',
			title: 'title'
		},
		attrMatch: function (node, attrName, attrValue) {
			var propName = NodeUtil.attrPropMap[attrName];
			if (!attrName ||
				attrValue == null && (
				propName && node[propName] ||
				!propName && node.getAttribute && node.getAttribute(attrName, 2)
				) ||
				attrValue != null && (
				propName && node[propName] == attrValue ||
				!propName && node.getAttribute && node.getAttribute(attrName, 2) == attrValue
				)) {
				return true;
			}
			else {
				return false;
			}
		},
		getDescendantNodes: function (test, node, nodeset, attrName, attrValue, prevNodeset, prevIndex) {
			if (prevNodeset) {
				prevNodeset.delDescendant(node, prevIndex);
			}
			try {
				if (!test.notOnlyElement || test.type == 8 || (attrName && test.type == 0)) {

					var all = node.all;
					if (!all) {
						return nodeset;
					}

					var name = test.name;
					if (test.type == 8) name = '!';
					else if (test.type == 0) name = '*';

					if (name != '*') {
						all = all.tags(name);
						if (!all) {
							return nodeset;
						}
					}

					if (attrName) {
						var result = []
						var i = 0;
						if (attrValue != null && (attrName == 'id' || attrName == 'name')) {
							all = all[attrValue];
							if (!all) {
								return nodeset;
							}
							if (!all.length || all.nodeType) {
								all = [all];
							}
						}

						while (node = all[i++]) {
							if (NodeUtil.attrMatch(node, attrName, attrValue)) result.push(node);
						}

						all = result;
					}

					var i = 0;
					while (node = all[i++]) {
						if (name != '*' || node.tagName != '!') {
							nodeset.push(node);
						}
					}

					return nodeset;
				}

				(function (parent) {
					var g = arguments.callee;
					var node = parent.firstChild;
					if (node) {
						for (; node; node = node.nextSibling) {
							if (NodeUtil.attrMatch(node, attrName, attrValue)) {
								if (test.match(node)) nodeset.push(node);
							}
							g(node);
						}
					}
				})(node);

				return nodeset;
			}
			catch (e) {
				if (attrValue && attrName == 'id' && node.getElementById) {
					node = node.getElementById(attrValue);
					if (node && test.match(node)) {
						nodeset.push(node);
					}
				}
				else if (attrValue && attrName == 'name' && node.getElementsByName) {
					var nodes = node.getElementsByName(attrValue);
					for (var i = 0, l = nodes.length; i < l; i++) {
						node = nodes[i];
						if (uai.opera ? (node.name == attrValue && test.match(node)) : test.match(node)) {
							nodeset.push(node);
						}
					}
				}
				else if (attrValue && attrName == 'class' && node.getElementsByClassName) {
					var nodes = node.getElementsByClassName(attrValue);
					for (var i = 0, l = nodes.length; i < l; i++) {
						node = nodes[i];
						if (node.className == attrValue && test.match(node)) {
							nodeset.push(node);
						}
					}
				}
				else if (test.notOnlyElement) {
					(function (parent) {
						var f = arguments.callee;
						for (var node = parent.firstChild; node; node = node.nextSibling) {
							if (NodeUtil.attrMatch(node, attrName, attrValue)) {
								if (test.match(node.nodeType)) nodeset.push(node);
							}
							f(node);
						}
					})(node);
				}
				else {
					var name = test.name;
					if (node.getElementsByTagName) {
						var nodes = node.getElementsByTagName(name);
						if (nodes) {
							var i = 0;
							while (node = nodes[i++]) {
								if (NodeUtil.attrMatch(node, attrName, attrValue)) nodeset.push(node);
							}
						}
					}
				}
				return nodeset;
			}
		},

		getChildNodes: function (test, node, nodeset, attrName, attrValue) {
			try {
				var children;

				if ((!test.notOnlyElement || test.type == 8 || (attrName && test.type == 0)) && (children = node.children)) {
					var name, elm;

					name = test.name;
					if (test.type == 8) name = '!';
					else if (test.type == 0) name = '*';

					if (name != '*') {
						children = children.tags(name);
						if (!children) {
							return nodeset;
						}
					}

					if (attrName) {
						var result = []
						var i = 0;
						if (attrName == 'id' || attrName == 'name') {
							children = children[attrValue];

							if (!children) {
								return nodeset;
							}

							if (!children.length || children.nodeType) {
								children = [children];
							}
						}

						while (node = children[i++]) {
							if (NodeUtil.attrMatch(node, attrName, attrValue)) result.push(node);
						}
						children = result;
					}

					var i = 0;
					while (node = children[i++]) {
						if (name != '*' || node.tagName != '!') {
							nodeset.push(node);
						}
					}

					return nodeset;
				}

				for (var i = 0, node = node.firstChild; node; i++, node = node.nextSibling) {
					if (NodeUtil.attrMatch(node, attrName, attrValue)) {
						if (test.match(node)) nodeset.push(node);
					}
				}

				return nodeset;
			} catch (e) {
				for (var node = node.firstChild; node; node = node.nextSibling) {
					if (NodeUtil.attrMatch(node, attrName, attrValue)) {
						if (test.match(node)) nodeset.push(node);
					}
				}
				return nodeset;
			}
		}
	};

	var AttributeWrapper = function (node, parent, sourceIndex) {
		this.node = node;
		this.nodeType = 2;
		this.nodeValue = node.nodeValue;
		this.value = this.nodeValue;
		this.nodeName = node.nodeName;
		this.parentNode = parent;
		this.ownerElement = parent;
		this.parentSourceIndex = sourceIndex;
	};


	/**
	 * class: Step
	 */
	if (!window.Step && window.defaultConfig)
		window.Step = null;

	Step = function (axis, test) {
		// TODO check arguments and throw axis error
		this.axis = axis;
		this.reverse = Step.axises[axis][0];
		this.func = Step.axises[axis][1];
		this.test = test;
		this.predicates = [];
		this._quickAttr = Step.axises[axis][2]
	};

	Step.axises = {

		ancestor: [true, function (test, node, nodeset, _, __, prevNodeset, prevIndex) {
			while (node = node.parentNode) {
				if (prevNodeset && node.nodeType == 1) {
					prevNodeset.reserveDelByNode(node, prevIndex, true);
				}
				if (test.match(node)) nodeset.unshift(node);
			}
			return nodeset;
		}],

		'ancestor-or-self': [true, function (test, node, nodeset, _, __, prevNodeset, prevIndex) {
			do {
				if (prevNodeset && node.nodeType == 1) {
					prevNodeset.reserveDelByNode(node, prevIndex, true);
				}
				if (test.match(node)) nodeset.unshift(node);
			} while (node = node.parentNode)
			return nodeset;
		}],

		attribute: [false, function (test, node, nodeset) {
			var attrs = node.attributes;
			if (attrs) {
				var sourceIndex = node.sourceIndex;
				if ((test.notOnlyElement && test.type == 0) || test.name == '*') {
					for (var i = 0, attr; attr = attrs[i]; i++) {
						if (attr.nodeValue) {
							nodeset.push(new AttributeWrapper(attr, node, sourceIndex));
						}
					}
				}
				else {
					var attr = attrs.getNamedItem(test.name);
					if (attr && attr.nodeValue) {
						attr = new AttributeWrapper(attr, node, sourceIndex);
						nodeset.push(attr);
					}
				}
			}
			return nodeset;
		}],

		child: [false, NodeUtil.getChildNodes, true],

		descendant: [false, NodeUtil.getDescendantNodes, true],

		'descendant-or-self': [false, function (test, node, nodeset, attrName, attrValue, prevNodeset, prevIndex) {
			if (NodeUtil.attrMatch(node, attrName, attrValue)) {
				if (test.match(node)) nodeset.push(node);
			}
			return NodeUtil.getDescendantNodes(test, node, nodeset, attrName, attrValue, prevNodeset, prevIndex);
		}, true],

		following: [false, function (test, node, nodeset, attrName, attrValue) {
			do {
				var child = node;
				while (child = child.nextSibling) {
					if (NodeUtil.attrMatch(child, attrName, attrValue)) {
						if (test.match(child)) nodeset.push(child);
					}
					nodeset = NodeUtil.getDescendantNodes(test, child, nodeset, attrName, attrValue);
				}
			} while (node = node.parentNode);
			return nodeset;
		}, true],

		'following-sibling': [false, function (test, node, nodeset, _, __, prevNodeset, prevIndex) {
			while (node = node.nextSibling) {

				if (prevNodeset && node.nodeType == 1) {
					prevNodeset.reserveDelByNode(node, prevIndex);
				}

				if (test.match(node)) {
					nodeset.push(node);
				}
			}
			return nodeset;
		}],

		namespace: [false, function (test, node, nodeset) {
			// not implemented
			return nodeset;
		}],

		parent: [false, function (test, node, nodeset) {
			if (node.nodeType == 9) {
				return nodeset;
			}
			if (node.nodeType == 2) {
				nodeset.push(node.ownerElement);
				return nodeset;
			}
			var node = node.parentNode;
			if (test.match(node)) nodeset.push(node);
			return nodeset;
		}],

		preceding: [true, function (test, node, nodeset, attrName, attrValue) {
			var parents = [];
			do {
				parents.unshift(node);
			} while (node = node.parentNode);

			for (var i = 1, l0 = parents.length; i < l0; i++) {
				var siblings = [];
				node = parents[i];
				while (node = node.previousSibling) {
					siblings.unshift(node);
				}

				for (var j = 0, l1 = siblings.length; j < l1; j++) {
					node = siblings[j];
					if (NodeUtil.attrMatch(node, attrName, attrValue)) {
						if (test.match(node)) nodeset.push(node);
					}
					nodeset = NodeUtil.getDescendantNodes(test, node, nodeset, attrName, attrValue);
				}
			}
			return nodeset;
		}, true],

		'preceding-sibling': [true, function (test, node, nodeset, _, __, prevNodeset, prevIndex) {
			while (node = node.previousSibling) {

				if (prevNodeset && node.nodeType == 1) {
					prevNodeset.reserveDelByNode(node, prevIndex, true);
				}

				if (test.match(node)) {
					nodeset.unshift(node)
				}
			}
			return nodeset;
		}],

		self: [false, function (test, node, nodeset) {
			if (test.match(node)) nodeset.push(node);
			return nodeset;
		}]
	};

	Step.parse = function (lexer) {
		var axis, test, step, token;

		if (lexer.peek() == '.') {
			step = this.self();
			lexer.next();
		}
		else if (lexer.peek() == '..') {
			step = this.parent();
			lexer.next();
		}
		else {
			if (lexer.peek() == '@') {
				axis = 'attribute';
				lexer.next();
				if (lexer.empty()) {
					throw Error('missing attribute name');
				}
			}
			else {
				if (lexer.peek(1) == '::') {

					if (!/(?![0-9])[\w]/.test(lexer.peek().charAt(0))) {
						throw Error('bad token: ' + lexer.next());
					}

					axis = lexer.next();
					lexer.next();

					if (!this.axises[axis]) {
						throw Error('invalid axis: ' + axis);
					}
					if (lexer.empty()) {
						throw Error('missing node name');
					}
				}
				else {
					axis = 'child';
				}
			}

			token = lexer.peek();
			if (!/(?![0-9])[\w]/.test(token.charAt(0))) {
				if (token == '*') {
					test = NameTest.parse(lexer)
				}
				else {
					throw Error('bad token: ' + lexer.next());
				}
			}
			else {
				if (lexer.peek(1) == '(') {
					if (!NodeType.types[token]) {
						throw Error('invalid node type: ' + token);
					}
					test = NodeType.parse(lexer)
				}
				else {
					test = NameTest.parse(lexer);
				}
			}
			step = new Step(axis, test);
		}

		BaseExprHasPredicates.parsePredicates(lexer, step);

		return step;
	};

	Step.self = function () {
		return new Step('self', new NodeType('node'));
	};

	Step.parent = function () {
		return new Step('parent', new NodeType('node'));
	};

	Step.prototype = new BaseExprHasPredicates();

	Step.prototype.evaluate = function (ctx, special, prevNodeset, prevIndex) {
		var node = ctx.node;
		var reverse = false;

		if (!special && this.op == '//') {

			if (!this.needContextPosition && this.axis == 'child') {
				if (this.quickAttr) {
					var attrValue = this.attrValueExpr ? this.attrValueExpr.string(ctx) : null;
					var nodeset = NodeUtil.getDescendantNodes(this.test, node, new NodeSet(), this.attrName, attrValue, prevNodeset, prevIndex);
					nodeset = this.evaluatePredicates(nodeset, 1);
				}
				else {
					var nodeset = NodeUtil.getDescendantNodes(this.test, node, new NodeSet(), null, null, prevNodeset, prevIndex);
					nodeset = this.evaluatePredicates(nodeset);
				}
			}
			else {
				var step = new Step('descendant-or-self', new NodeType('node'));
				var nodes = step.evaluate(ctx, false, prevNodeset, prevIndex).list();
				var nodeset = null;
				step.op = '/';
				for (var i = 0, l = nodes.length; i < l; i++) {
					if (!nodeset) {
						nodeset = this.evaluate(new Ctx(nodes[i]), true);
					}
					else {
						nodeset.merge(this.evaluate(new Ctx(nodes[i]), true));
					}
				}
				nodeset = nodeset || new NodeSet();
			}
		}
		else {

			if (this.needContextPosition) {
				prevNodeset = null;
				prevIndex = null;
			}

			if (this.quickAttr) {
				var attrValue = this.attrValueExpr ? this.attrValueExpr.string(ctx) : null;
				var nodeset = this.func(this.test, node, new NodeSet(), this.attrName, attrValue, prevNodeset, prevIndex);
				nodeset = this.evaluatePredicates(nodeset, 1);
			}
			else {
				var nodeset = this.func(this.test, node, new NodeSet(), null, null, prevNodeset, prevIndex);
				nodeset = this.evaluatePredicates(nodeset);
			}
			if (prevNodeset) {
				prevNodeset.doDel();
			}
		}
		return nodeset;
	};

	Step.prototype.predicate = function (predicate) {
		this.predicates.push(predicate);

		if (predicate.needContextPosition ||
			predicate.datatype == 'number' ||
			predicate.datatype == 'void') {
			this.needContextPosition = true;
		}

		if (this._quickAttr && this.predicates.length == 1 && predicate.quickAttr) {
			var attrName = predicate.attrName;
			this.attrName = attrName.toLowerCase();
			this.attrValueExpr = predicate.attrValueExpr;
			this.quickAttr = true;
		}
	};

	Step.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'step: ' + '\n';
		indent += '	';
		if (this.axis) t += indent + 'axis: ' + this.axis + '\n';
		t += this.test.show(indent);
		if (this.predicates.length) {
			t += indent + 'predicates: ' + '\n';
			indent += '	';
			for (var i = 0; i < this.predicates.length; i++) {
				t += this.predicates[i].show(indent);
			}
		}
		return t;
	};


	/**
	 * NodeType
	 */
	if (!window.NodeType && window.defaultConfig)
		window.NodeType = null;

	NodeType = function (name, literal) {
		this.name = name;
		this.literal = literal;

		switch (name) {
			case 'comment':
				this.type = 8;
				break;
			case 'text':
				this.type = 3;
				break;
			case 'processing-instruction':
				this.type = 7;
				break;
			case 'node':
				this.type = 0;
				break;
		}
	};

	NodeType.types = {
		'comment': 1, 'text': 1, 'processing-instruction': 1, 'node': 1
	};

	NodeType.parse = function (lexer) {
		var type, literal, ch;
		type = lexer.next();
		lexer.next();
		if (lexer.empty()) {
			throw Error('bad nodetype');
		}
		ch = lexer.peek().charAt(0);
		if (ch == '"' || ch == "'") {
			literal = Literal.parse(lexer);
		}
		if (lexer.empty()) {
			throw Error('bad nodetype');
		}
		if (lexer.next() != ')') {
			lexer.back();
			throw Error('bad token ' + lexer.next());
		}
		return new NodeType(type, literal);
	};

	NodeType.prototype = new BaseExpr();

	NodeType.prototype.notOnlyElement = true;

	NodeType.prototype.match = function (node) {
		return !this.type || this.type == node.nodeType;
	};

	NodeType.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'nodetype: ' + this.type + '\n';
		if (this.literal) {
			indent += '	';
			t += this.literal.show(indent);
		}
		return t;
	};


	/**
	 * NodeType
	 */
	if (!window.NameTest && window.defaultConfig)
		window.NameTest = null;

	NameTest = function (name) {
		this.name = name.toLowerCase();
	};

	NameTest.parse = function (lexer) {
		if (lexer.peek() != '*' && lexer.peek(1) == ':' && lexer.peek(2) == '*') {
			return new NameTest(lexer.next() + lexer.next() + lexer.next());
		}
		return new NameTest(lexer.next());
	};

	NameTest.prototype = new BaseExpr();

	NameTest.prototype.match = function (node) {
		var type = node.nodeType;

		if (type == 1 || type == 2) {
			if (this.name == '*' || this.name == node.nodeName.toLowerCase()) {
				return true;
			}
		}
		return false;
	};

	NameTest.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'nametest: ' + this.name + '\n';
		return t;
	};


	/**
	 * class: VariableRefernce
	 */
	if (!window.VariableReference && window.defaultConfig)
		window.VariableReference = null;

	VariableReference = function (name) {
		this.name = name.substring(1);
	};


	VariableReference.parse = function (lexer) {
		var token = lexer.next();
		if (token.length < 2) {
			throw Error('unnamed variable reference');
		}
		return new VariableReference(token)
	};

	VariableReference.prototype = new BaseExpr();

	VariableReference.prototype.datatype = 'void';

	VariableReference.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'variable: ' + this.name + '\n';
		return t;
	};


	/**
	 * class: Literal
	 */
	if (!window.Literal && window.defaultConfig)
		window.Literal = null;

	Literal = function (text) {
		this.text = text.substring(1, text.length - 1);
	};

	Literal.parse = function (lexer) {
		var token = lexer.next();
		if (token.length < 2) {
			throw Error('unclosed literal string');
		}
		return new Literal(token)
	};

	Literal.prototype = new BaseExpr();

	Literal.prototype.datatype = 'string';

	Literal.prototype.evaluate = function (ctx) {
		return this.text;
	};

	Literal.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'literal: ' + this.text + '\n';
		return t;
	};


	/**
	 * class: Number
	 */
	if (!window.Number && window.defaultConfig)
		window.Number = null;

	Number = function (digit) {
		this.digit = +digit;
	};


	Number.parse = function (lexer) {
		return new Number(lexer.next());
	};

	Number.prototype = new BaseExpr();

	Number.prototype.datatype = 'number';

	Number.prototype.evaluate = function (ctx) {
		return this.digit;
	};

	Number.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'number: ' + this.digit + '\n';
		return t;
	};


	/**
	 * class: FunctionCall
	 */
	if (!window.FunctionCall && window.defaultConfig)
		window.FunctionCall = null;

	FunctionCall = function (name) {
		var info = FunctionCall.funcs[name];
		if (!info)
			throw Error(name + ' is not a function');

		this.name = name;
		this.func = info[0];
		this.args = [];

		this.datatype = info[1];

		if (info[2]) {
			this.needContextPosition = true;
		}

		this.needContextNodeInfo = info[3];
		this.needContextNode = this.needContextNodeInfo[0]
	};

	FunctionCall.funcs = {

		// Original Function
		'context-node': [function () {
			if (arguments.length != 0) {
				throw Error('Function context-node expects ()');
			}
			var ns;
			ns = new NodeSet();
			ns.push(this.node);
			return ns;
		}, 'nodeset', false, [true]],

		// Original Function
		'root-node': [function () {
			if (arguments.length != 0) {
				throw Error('Function root-node expects ()');
			}
			var ns, ctxn;
			ns = new NodeSet();
			ctxn = this.node;
			if (ctxn.nodeType == 9)
				ns.push(ctxn);
			else
				ns.push(ctxn.ownerDocument);
			return ns;
		}, 'nodeset', false, []],

		last: [function () {
			if (arguments.length != 0) {
				throw Error('Function last expects ()');
			}
			return this.last;
		}, 'number', true, []],

		position: [function () {
			if (arguments.length != 0) {
				throw Error('Function position expects ()');
			}
			return this.position;
		}, 'number', true, []],

		count: [function (ns) {
			if (arguments.length != 1 || !(ns = ns.evaluate(this)).isNodeSet) {
				throw Error('Function count expects (nodeset)');
			}
			return ns.length;
		}, 'number', false, []],

		id: [function (s) {
			var ids, ns, i, id, elm, ctxn, doc;
			if (arguments.length != 1) {
				throw Error('Function id expects (object)');
			}
			ctxn = this.node;
			if (ctxn.nodeType == 9)
				doc = ctxn;
			else
				doc = ctxn.ownerDocument;
			all = doc.all;
			s = s.string(this);
			ids = s.split(/\s+/);
			ns = new NodeSet();
			for (i = 0, l = ids.length; i < l; i++) {
				id = ids[i];
				elm = all[id];
				if (elm) {
					if ((!elm.length || elm.nodeType) && id == elm.id) {
						ns.push(elm)
					}
					else if (elm.length) {
						var elms = elm;
						for (var j = 0, l0 = elms.length; j < l0; j++) {
							var elem = elms[j];
							if (id == elem.id) {
								ns.push(elem);
								break;
							}
						}
					}
				}
			}
			ns.isSorted = false;
			return ns;
		}, 'nodeset', false, []],

		'local-name': [function (ns) {
			var nd;
			switch (arguments.length) {
				case 0:
					nd = this.node;
					break;
				case 1:
					if ((ns = ns.evaluate(this)).isNodeSet) {
						nd = ns.first();
						break;
					}
				default:
					throw Error('Function local-name expects (nodeset?)');
					break;
			}
			return '' + nd.nodeName.toLowerCase();
		}, 'string', false, [true, false]],

		name: [function (ns) {
			// not implemented
			return FunctionCall.funcs['local-name'][0].apply(this, arguments);
		}, 'string', false, [true, false]],

		'namespace-uri': [function (ns) {
			// not implemented
			return '';
		}, 'string', false, [true, false]],

		string: [function (s) {
			switch (arguments.length) {
				case 0:
					s = NodeUtil.to('string', this.node);
					break;
				case 1:
					s = s.string(this);
					break;
				default:
					throw Error('Function string expects (object?)');
					break;
			}
			return s;
		}, 'string', false, [true, false]],

		concat: [function (s1, s2) {
			if (arguments.length < 2) {
				throw Error('Function concat expects (string, string[, ...])');
			}
			for (var t = '', i = 0, l = arguments.length; i < l; i++) {
				t += arguments[i].string(this);
			}
			return t;
		}, 'string', false, []],

		'starts-with': [function (s1, s2) {
			if (arguments.length != 2) {
				throw Error('Function starts-with expects (string, string)');
			}
			s1 = s1.string(this);
			s2 = s2.string(this);
			return s1.indexOf(s2) == 0;
		}, 'boolean', false, []],

		contains: [function (s1, s2) {
			if (arguments.length != 2) {
				throw Error('Function contains expects (string, string)');
			}
			s1 = s1.string(this);
			s2 = s2.string(this);
			return s1.indexOf(s2) != -1;
		}, 'boolean', false, []],

		substring: [function (s, n1, n2) {
			var a1, a2;
			s = s.string(this);
			n1 = n1.number(this);
			switch (arguments.length) {
				case 2:
					n2 = s.length - n1 + 1;
					break;
				case 3:
					n2 = n2.number(this);
					break;
				default:
					throw Error('Function substring expects (string, string)');
					break;
			}
			n1 = Math.round(n1);
			n2 = Math.round(n2);
			a1 = n1 - 1;
			a2 = n1 + n2 - 1;
			if (a2 == Infinity) {
				return s.substring(a1 < 0 ? 0 : a1);
			}
			else {
				return s.substring(a1 < 0 ? 0 : a1, a2)
			}
		}, 'string', false, []],

		'substring-before': [function (s1, s2) {
			var n;
			if (arguments.length != 2) {
				throw Error('Function substring-before expects (string, string)');
			}
			s1 = s1.string(this);
			s2 = s2.string(this);
			n = s1.indexOf(s2);
			if (n == -1) return '';
			return s1.substring(0, n);
		}, 'string', false, []],

		'substring-after': [function (s1, s2) {
			if (arguments.length != 2) {
				throw Error('Function substring-after expects (string, string)');
			}
			s1 = s1.string(this);
			s2 = s2.string(this);
			var n = s1.indexOf(s2);
			if (n == -1) return '';
			return s1.substring(n + s2.length);
		}, 'string', false, []],

		'string-length': [function (s) {
			switch (arguments.length) {
				case 0:
					s = NodeUtil.to('string', this.node);
					break;
				case 1:
					s = s.string(this);
					break;
				default:
					throw Error('Function string-length expects (string?)');
					break;
			}
			return s.length;
		}, 'number', false, [true, false]],

		'normalize-space': [function (s) {
			switch (arguments.length) {
				case 0:
					s = NodeUtil.to('string', this.node);
					break;
				case 1:
					s = s.string(this);
					break;
				default:
					throw Error('Function normalize-space expects (string?)');
					break;
			}
			return s.replace(/\s+/g, ' ').replace(/^ /, '').replace(/ $/, '');
		}, 'string', false, [true, false]],

		translate: [function (s1, s2, s3) {
			if (arguments.length != 3) {
				throw Error('Function translate expects (string, string, string)');
			}
			s1 = s1.string(this);
			s2 = s2.string(this);
			s3 = s3.string(this);

			var map = [];
			for (var i = 0, l = s2.length; i < l; i++) {
				var ch = s2.charAt(i);
				if (!map[ch]) map[ch] = s3.charAt(i) || '';
			}
			for (var t = '', i = 0, l = s1.length; i < l; i++) {
				var ch = s1.charAt(i);
				var replace = map[ch]
				t += (replace != undefined) ? replace : ch;
			}
			return t;
		}, 'string', false, []],

		'boolean': [function (b) {
			if (arguments.length != 1) {
				throw Error('Function boolean expects (object)');
			}
			return b.bool(this)
		}, 'boolean', false, []],

		not: [function (b) {
			if (arguments.length != 1) {
				throw Error('Function not expects (object)');
			}
			return !b.bool(this)
		}, 'boolean', false, []],

		'true': [function () {
			if (arguments.length != 0) {
				throw Error('Function true expects ()');
			}
			return true;
		}, 'boolean', false, []],

		'false': [function () {
			if (arguments.length != 0) {
				throw Error('Function false expects ()');
			}
			return false;
		}, 'boolean', false, []],

		lang: [function (s) {
			// not implemented
			return false;
		}, 'boolean', false, []],

		number: [function (n) {
			switch (arguments.length) {
				case 0:
					n = NodeUtil.to('number', this.node);
					break;
				case 1:
					n = n.number(this);
					break;
				default:
					throw Error('Function number expects (object?)');
					break;
			}
			return n;
		}, 'number', false, [true, false]],

		sum: [function (ns) {
			var nodes, n, i, l;
			if (arguments.length != 1 || !(ns = ns.evaluate(this)).isNodeSet) {
				throw Error('Function sum expects (nodeset)');
			}
			nodes = ns.list();
			n = 0;
			for (i = 0, l = nodes.length; i < l; i++) {
				n += NodeUtil.to('number', nodes[i]);
			}
			return n;
		}, 'number', false, []],

		floor: [function (n) {
			if (arguments.length != 1) {
				throw Error('Function floor expects (number)');
			}
			n = n.number(this);
			return Math.floor(n);
		}, 'number', false, []],

		ceiling: [function (n) {
			if (arguments.length != 1) {
				throw Error('Function ceiling expects (number)');
			}
			n = n.number(this);
			return Math.ceil(n);
		}, 'number', false, []],

		round: [function (n) {
			if (arguments.length != 1) {
				throw Error('Function round expects (number)');
			}
			n = n.number(this);
			return Math.round(n);
		}, 'number', false, []]
	};

	FunctionCall.parse = function (lexer) {
		var expr, func = new FunctionCall(lexer.next());
		lexer.next();
		while (lexer.peek() != ')') {
			if (lexer.empty()) {
				throw Error('missing function argument list');
			}
			expr = BinaryExpr.parse(lexer);
			func.arg(expr);
			if (lexer.peek() != ',') break;
			lexer.next();
		}
		if (lexer.empty()) {
			throw Error('unclosed function argument list');
		}
		if (lexer.next() != ')') {
			lexer.back();
			throw Error('bad token: ' + lexer.next());
		}
		return func
	};

	FunctionCall.prototype = new BaseExpr();

	FunctionCall.prototype.evaluate = function (ctx) {
		return this.func.apply(ctx, this.args);
	};

	FunctionCall.prototype.arg = function (arg) {
		this.args.push(arg);

		if (arg.needContextPosition) {
			this.needContextPosition = true;
		}

		var args = this.args;
		if (arg.needContextNode) {
			args.needContexNode = true;
		}
		this.needContextNode = args.needContextNode ||
		this.needContextNodeInfo[args.length];
	};

	FunctionCall.prototype.show = function (indent) {
		indent = indent || '';
		var t = '';
		t += indent + 'function: ' + this.name + '\n';
		indent += '	';

		if (this.args.length) {
			t += indent + 'arguments: ' + '\n';
			indent += '	';
			for (var i = 0; i < this.args.length; i++) {
				t += this.args[i].show(indent);
			}
		}

		return t;
	};


	var NodeWrapper = function (node, sourceIndex, subIndex, attributeName) {
		this.node = node;
		this.nodeType = node.nodeType;
		this.sourceIndex = sourceIndex;
		this.subIndex = subIndex;
		this.attributeName = attributeName || '';
		this.order = String.fromCharCode(sourceIndex) + String.fromCharCode(subIndex) + attributeName;
	};

	NodeWrapper.prototype.toString = function () {
		return this.order;
	};

	if (!window.NodeSet && window.defaultConfig)
		window.NodeSet = null;

	NodeSet = function () {
		this.length = 0;
		this.nodes = [];
		this.seen = {};
		this.idIndexMap = null;
		this.reserveDels = [];
	};

	NodeSet.prototype.isNodeSet = true;
	NodeSet.prototype.isSorted = true;
	NodeSet.prototype.shortcut = true;

	NodeSet.prototype.merge = function (nodeset) {
		this.isSorted = false;
		if (nodeset.only) {
			return this.push(nodeset.only);
		}

		if (this.only) {
			var only = this.only;
			delete this.only;
			this.push(only);
			this.length--;
		}

		var nodes = nodeset.nodes;
		for (var i = 0, l = nodes.length; i < l; i++) {
			this._add(nodes[i]);
		}
	};

	NodeSet.prototype.sort = function () {
		if (this.only) return;
		if (this.sortOff) return;

		if (!this.isSorted) {
			this.isSorted = true;
			this.idIndexMap = null;

			if (this.shortcut) {
				this.nodes.sort();
			}
			else {
				this.nodes.sort(function (a, b) {
					var result;
					result = a.sourceIndex - b.sourceIndex;
					if (result == 0)
						return a.subIndex - a.subIndex;
					else
						return result;
				});
			}
			return;
			var nodes = this.nodes;
			nodes.sort(function (a, b) {
				if (a == b) return 0;

				if (a.compareDocumentPosition) {
					var result = a.compareDocumentPosition(b);
					if (result & 2) return 1;
					if (result & 4) return -1;
					return 0;
				}
				else {
					var node1 = a, node2 = b, ancestor1 = a, ancestor2 = b, deep1 = 0, deep2 = 0;

					while (ancestor1 = ancestor1.parentNode) deep1++;
					while (ancestor2 = ancestor2.parentNode) deep2++;

					// same deep
					if (deep1 > deep2) {
						while (deep1-- != deep2) node1 = node1.parentNode;
						if (node1 == node2) return 1;
					}
					else if (deep2 > deep1) {
						while (deep2-- != deep1) node2 = node2.parentNode;
						if (node1 == node2) return -1;
					}

					while ((ancestor1 = node1.parentNode) != (ancestor2 = node2.parentNode)) {
						node1 = ancestor1;
						node2 = ancestor2;
					}

					// node1 is node2's sibling
					while (node1 = node1.nextSibling) if (node1 == node2) return -1;

					return 1;
				}
			});
		}
	};


	NodeSet.prototype.sourceOffset = 1;
	NodeSet.prototype.subOffset = 2;
	NodeSet.prototype.createWrapper = function (node) {
		var parent, child, attributes, attributesLength, sourceIndex, subIndex, attributeName;

		sourceIndex = node.sourceIndex;

		if (typeof sourceIndex != 'number') {
			type = node.nodeType;
			switch (type) {
				case 2:
					parent = node.parentNode;
					sourceIndex = node.parentSourceIndex;
					subIndex = -1;
					attributeName = node.nodeName;
					break;
				case 9:
					subIndex = -2;
					sourceIndex = -1;
					break;
				default:
					child = node;
					subIndex = 0;
					do {
						subIndex++;
						sourceIndex = child.sourceIndex;
						if (sourceIndex) {
							parent = child;
							child = child.lastChild;
							if (!child) {
								child = parent;
								break;
							}
							subIndex++;
						}
					} while (child = child.previousSibling);
					if (!sourceIndex) {
						sourceIndex = node.parentNode.sourceIndex;
					}
					break;
			}
		}
		else {
			subIndex = -2;
		}

		sourceIndex += this.sourceOffset;
		subIndex += this.subOffset;

		return new NodeWrapper(node, sourceIndex, subIndex, attributeName);
	};

	NodeSet.prototype.reserveDelBySourceIndexAndSubIndex = function (sourceIndex, subIndex, offset, reverse) {
		var map = this.createIdIndexMap();
		var index;
		if ((map = map[sourceIndex]) && (index = map[subIndex])) {
			if (reverse && (this.length - offset - 1) > index || !reverse && offset < index) {
				var obj = {
					value: index,
					order: String.fromCharCode(index),
					toString: function () {
						return this.order
					},
					valueOf: function () {
						return this.value
					}
				};
				this.reserveDels.push(obj);
			}
		}
	};


	NodeSet.prototype.reserveDelByNode = function (node, offset, reverse) {
		node = this.createWrapper(node);
		this.reserveDelBySourceIndexAndSubIndex(node.sourceIndex, node.subIndex, offset, reverse);
	};

	NodeSet.prototype.doDel = function () {
		if (!this.reserveDels.length) return;

		if (this.length < 0x10000) {
			var dels = this.reserveDels.sort(function (a, b) {
				return b - a
			});
		}
		else {
			var dels = this.reserveDels.sort(function (a, b) {
				return b - a
			});
		}
		for (var i = 0, l = dels.length; i < l; i++) {
			this.del(dels[i]);
		}
		this.reserveDels = [];
		this.idIndexMap = null;
	};

	NodeSet.prototype.createIdIndexMap = function () {
		if (this.idIndexMap) {
			return this.idIndexMap;
		}
		else {
			var map = this.idIndexMap = {};
			var nodes = this.nodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var node = nodes[i];
				var sourceIndex = node.sourceIndex;
				var subIndex = node.subIndex;
				if (!map[sourceIndex]) map[sourceIndex] = {};
				map[sourceIndex][subIndex] = i;
			}
			return map;
		}
	};

	NodeSet.prototype.del = function (index) {
		this.length--;
		if (this.only) {
			delete this.only;
		}
		else {
			var node = this.nodes.splice(index, 1)[0];

			if (this._first == node) {
				delete this._first;
				delete this._firstSourceIndex;
				delete this._firstSubIndex;
			}

			delete this.seen[node.sourceIndex][node.subIndex];
		}
	};


	NodeSet.prototype.delDescendant = function (elm, offset) {
		if (this.only) return;
		var nodeType = elm.nodeType;
		if (nodeType != 1 && nodeType != 9) return;
		if (uai.applewebkit2) return;

		// element || document
		if (!elm.contains) {
			if (nodeType == 1) {
				var _elm = elm;
				elm = {
					contains: function (node) {
						return node.compareDocumentPosition(_elm) & 8;
					}
				};
			}
			else {
				// document
				elm = {
					contains: function () {
						return true;
					}
				};
			}
		}

		var nodes = this.nodes;
		for (var i = offset + 1; i < nodes.length; i++) {

			if (nodes[i].node.nodeType == 1 && elm.contains(nodes[i].node)) {
				this.del(i);
				i--;
			}
		}
	};

	NodeSet.prototype._add = function (node, reverse) {
		var first, firstSourceIndex, firstSubIndex, sourceIndex, subIndex, attributeName;

		sourceIndex = node.sourceIndex;
		subIndex = node.subIndex;
		attributeName = node.attributeName;
		seen = this.seen;

		seen = seen[sourceIndex] || (seen[sourceIndex] = {});

		if (node.nodeType == 2) {
			seen = seen[subIndex] || (seen[subIndex] = {});
			if (seen[attributeName]) {
				return true;
			}
			seen[attributeName] = true;
		}
		else {
			if (seen[subIndex]) {
				return true;
			}
			seen[subIndex] = true;
		}

		if (sourceIndex >= 0x10000 || subIndex >= 0x10000) {
			this.shortcut = false;
		}

		// if this._first is undefined and this.nodes is not empty
		// then first node shortcut is disabled.
		if (this._first || this.nodes.length == 0) {
			first = this._first;
			firstSourceIndex = this._firstSourceIndex;
			firstSubIndex = this._firstSubIndex;
			if (!first || firstSourceIndex > sourceIndex || (firstSourceIndex == sourceIndex && firstSubIndex > subIndex)) {
				this._first = node;
				this._firstSourceIndex = sourceIndex;
				this._firstSubIndex = subIndex
			}
		}

		this.length++;
		if (reverse)
			this.nodes.unshift(node);
		else
			this.nodes.push(node);
	};


	NodeSet.prototype.unshift = function (node) {
		if (!this.length) {
			this.length++;
			this.only = node;
			return
		}
		if (this.only) {
			var only = this.only;
			delete this.only;
			this.unshift(only);
			this.length--;
		}
		node = this.createWrapper(node);
		return this._add(node, true);
	};


	NodeSet.prototype.push = function (node) {
		if (!this.length) {
			this.length++;
			this.only = node;
			return;
		}
		if (this.only) {
			var only = this.only;
			delete this.only;
			this.push(only);
			this.length--;
		}
		node = this.createWrapper(node);
		return this._add(node);
	};

	NodeSet.prototype.first = function () {
		if (this.only) return this.only;
		if (this._first) return this._first.node;
		if (this.nodes.length > 1) this.sort();
		var node = this.nodes[0];
		return node ? node.node : undefined;
		if (this.nodes.length > 1) this.sort();
		return this.nodes[0];
	};

	NodeSet.prototype.list = function () {
		if (this.only) return [this.only];
		this.sort();
		var i, l, nodes, results;
		nodes = this.nodes;
		results = [];
		for (i = 0, l = nodes.length; i < l; i++) {
			results.push(nodes[i].node);
		}
		return results;
	};

	NodeSet.prototype.string = function () {
		var node = this.only || this.first();
		return node ? NodeUtil.to('string', node) : '';
	};

	NodeSet.prototype.bool = function () {
		return !!(this.length || this.only);
	};

	NodeSet.prototype.number = function () {
		return +this.string();
	};

	NodeSet.prototype.iterator = function (reverse) {
		this.sort();
		var nodeset = this;

		if (!reverse) {
			var count = 0;
			return function () {
				if (nodeset.only && count++ == 0) return nodeset.only;
				var wrapper = nodeset.nodes[count++];
				if (wrapper) return wrapper.node;
				return undefined;
			};
		}
		else {
			var count = 0;
			return function () {
				var index = nodeset.length - (count++) - 1;
				if (nodeset.only && index == 0) return nodeset.only;
				var wrapper = nodeset.nodes[index];
				if (wrapper) return wrapper.node;
				return undefined;
			};
		}
	};


	var install = function (win) {

		win = win || this;
		var doc = win.document;
		var undefined = win.undefined;

		win.XPathExpression = function (expr) {
			if (!expr.length) {
				throw win.Error('no expression');
			}
			var lexer = this.lexer = Lexer(expr);
			if (lexer.empty()) {
				throw win.Error('no expression');
			}
			this.expr = BinaryExpr.parse(lexer);
			if (!lexer.empty()) {
				throw win.Error('bad token: ' + lexer.next());
			}
		};

		win.XPathExpression.prototype.evaluate = function (node, type) {
			return new win.XPathResult(this.expr.evaluate(new Ctx(node)), type);
		};

		win.XPathResult = function (value, type) {
			if (type == 0) {
				switch (typeof value) {
					case 'object':
						type++; // 4
					case 'boolean':
						type++; // 3
					case 'string':
						type++; // 2
					case 'number':
						type++; // 1
				}
			}

			this.resultType = type;

			switch (type) {
				case 1:
					this.numberValue = value.isNodeSet ? value.number() : +value;
					return;
				case 2:
					this.stringValue = value.isNodeSet ? value.string() : '' + value;
					return;
				case 3:
					this.booleanValue = value.isNodeSet ? value.bool() : !!value;
					return;
				case 4:
				case 5:
				case 6:
				case 7:
					this.nodes = value.list();
					this.snapshotLength = value.length;
					this.index = 0;
					this.invalidIteratorState = false;
					break;
				case 8:
				case 9:
					this.singleNodeValue = value.first();
					return;
			}
		};

		win.XPathResult.prototype.iterateNext = function () {
			return this.nodes[this.index++]
		};
		win.XPathResult.prototype.snapshotItem = function (i) {
			return this.nodes[i]
		};

		win.XPathResult.ANY_TYPE = 0;
		win.XPathResult.NUMBER_TYPE = 1;
		win.XPathResult.STRING_TYPE = 2;
		win.XPathResult.BOOLEAN_TYPE = 3;
		win.XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
		win.XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
		win.XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
		win.XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
		win.XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
		win.XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

		doc.createNSResolver = function () {
			return null
		};

		doc.createExpression = function (expr) {
			return new win.XPathExpression(expr, null);
		};

		doc.evaluate = function (expr, context, _, type) {
			return doc.createExpression(expr, null).evaluate(context, type);
		};
	};

	var win;

	if (config.targetFrame) {
		var frame = document.getElementById(config.targetFrame);
		if (frame) win = frame.contentWindow;
	}

	if (config.exportInstaller) {
		window.installXPathIfNecessary = install;
	}

	if (!config.hasNative || !config.useNative) {
		install(win || window);
	}
})();

}

/******* END inject_ie_compat.js *********/

if(document.readyState && document.readyState !== "interactive" && document.readyState !== "complete") {
	window.onload = startTranslation;
} else {
	startTranslation();
}

/******** END inject_base.js ********/
